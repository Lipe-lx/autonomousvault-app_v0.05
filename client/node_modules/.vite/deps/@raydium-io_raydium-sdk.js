import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  decimal_default
} from "./chunk-XA6DZQG7.js";
import {
  bool,
  publicKey,
  u64
} from "./chunk-GKM63JYJ.js";
import {
  AddressLookupTableAccount,
  ComputeBudgetProgram,
  Keypair,
  PublicKey,
  SYSVAR_CLOCK_PUBKEY,
  SYSVAR_RENT_PUBKEY,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  TransactionMessage,
  VersionedTransaction,
  require_Layout,
  require_bn
} from "./chunk-7NKX5NPW.js";
import "./chunk-MAUFCNZG.js";
import "./chunk-DZ5OCXWV.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-6UDUTSRU.js";

// node_modules/toformat/toFormat.js
var require_toFormat = __commonJS({
  "node_modules/toformat/toFormat.js"(exports, module) {
    var import_dist328 = __toESM(require_dist());
    var import_dist329 = __toESM(require_dist2());
    var import_dist330 = __toESM(require_dist3());
    function toFormat2(Ctor) {
      "use strict";
      Ctor.prototype.toFormat = function toFormat3(dp, rm, fmt) {
        if (!this.e && this.e !== 0) return this.toString();
        var arr, g1, g2, i, u, nd, intd, intp, fracp, dsep, gsep, gsize, sgsize, fgsep, fgsize, tfmt = this.format || {}, cfmt = this.constructor.format || {};
        if (dp != u) {
          if (typeof dp == "object") {
            fmt = dp;
            dp = u;
          } else if (rm != u) {
            if (typeof rm == "object") {
              fmt = rm;
              rm = u;
            } else if (typeof fmt != "object") {
              fmt = {};
            }
          } else {
            fmt = {};
          }
        } else {
          fmt = {};
        }
        arr = this.toFixed(dp, rm).split(".");
        intp = arr[0];
        fracp = arr[1];
        intd = this.s < 0 ? intp.slice(1) : intp;
        nd = intd.length;
        dsep = fmt.decimalSeparator;
        if (dsep == u) {
          dsep = tfmt.decimalSeparator;
          if (dsep == u) {
            dsep = cfmt.decimalSeparator;
            if (dsep == u) dsep = ".";
          }
        }
        gsep = fmt.groupSeparator;
        if (gsep == u) {
          gsep = tfmt.groupSeparator;
          if (gsep == u) gsep = cfmt.groupSeparator;
        }
        if (gsep) {
          gsize = fmt.groupSize;
          if (gsize == u) {
            gsize = tfmt.groupSize;
            if (gsize == u) {
              gsize = cfmt.groupSize;
              if (gsize == u) gsize = 0;
            }
          }
          sgsize = fmt.secondaryGroupSize;
          if (sgsize == u) {
            sgsize = tfmt.secondaryGroupSize;
            if (sgsize == u) {
              sgsize = cfmt.secondaryGroupSize;
              if (sgsize == u) sgsize = 0;
            }
          }
          if (sgsize) {
            g1 = +sgsize;
            g2 = +gsize;
            nd -= g2;
          } else {
            g1 = +gsize;
            g2 = +sgsize;
          }
          if (g1 > 0 && nd > 0) {
            i = nd % g1 || g1;
            intp = intd.substr(0, i);
            for (; i < nd; i += g1) intp += gsep + intd.substr(i, g1);
            if (g2 > 0) intp += gsep + intd.slice(i);
            if (this.s < 0) intp = "-" + intp;
          }
        }
        if (fracp) {
          fgsep = fmt.fractionGroupSeparator;
          if (fgsep == u) {
            fgsep = tfmt.fractionGroupSeparator;
            if (fgsep == u) fgsep = cfmt.fractionGroupSeparator;
          }
          if (fgsep) {
            fgsize = fmt.fractionGroupSize;
            if (fgsize == u) {
              fgsize = tfmt.fractionGroupSize;
              if (fgsize == u) {
                fgsize = cfmt.fractionGroupSize;
                if (fgsize == u) fgsize = 0;
              }
            }
            fgsize = +fgsize;
            if (fgsize) {
              fracp = fracp.replace(new RegExp("\\d{" + fgsize + "}\\B", "g"), "$&" + fgsep);
            }
          }
          return intp + dsep + fracp;
        } else {
          return intp;
        }
      };
      Ctor.format = {
        decimalSeparator: ".",
        groupSeparator: ",",
        groupSize: 3,
        secondaryGroupSize: 0,
        fractionGroupSeparator: "",
        fractionGroupSize: 0
      };
      return Ctor;
    }
    if (typeof module !== "undefined" && module.exports) module.exports = toFormat2;
  }
});

// node_modules/@raydium-io/raydium-sdk/dist/index.mjs
var import_dist325 = __toESM(require_dist(), 1);
var import_dist326 = __toESM(require_dist2(), 1);
var import_dist327 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/index.js
var import_dist316 = __toESM(require_dist());
var import_dist317 = __toESM(require_dist2());
var import_dist318 = __toESM(require_dist3());

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/index.js
var import_dist250 = __toESM(require_dist(), 1);
var import_dist251 = __toESM(require_dist2(), 1);
var import_dist252 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/amountToUiAmount.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/constants.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var TOKEN_2022_PROGRAM_ID = new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT = new PublicKey("So11111111111111111111111111111111111111112");
var NATIVE_MINT_2022 = new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/amountToUiAmount.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
var import_buffer_layout = __toESM(require_Layout(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/errors.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var TokenError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var TokenAccountNotFoundError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenAccountNotFoundError";
  }
};
var TokenInvalidAccountOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountOwnerError";
  }
};
var TokenInvalidAccountSizeError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountSizeError";
  }
};
var TokenInvalidMintError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidMintError";
  }
};

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/types.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);
var TokenInstruction;
(function(TokenInstruction2) {
  TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
  TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
  TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
  TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
  TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
  TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
  TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
  TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
  TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
  TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
  TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
  TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
  TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
  TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
  TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
  TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
  TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
  TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
  TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
  TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
  TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
  TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
  TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
  TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
  TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
  TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
  TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
  TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
  TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
  TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
  TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
  TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
  TokenInstruction2[TokenInstruction2["TransferHookExtension"] = 36] = "TransferHookExtension";
  TokenInstruction2[TokenInstruction2["MetadataPointerExtension"] = 39] = "MetadataPointerExtension";
})(TokenInstruction || (TokenInstruction = {}));

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/amountToUiAmount.js
var amountToUiAmountInstructionData = (0, import_buffer_layout.struct)([
  (0, import_buffer_layout.u8)("instruction"),
  u64("amount")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/approve.js
var import_dist25 = __toESM(require_dist(), 1);
var import_dist26 = __toESM(require_dist2(), 1);
var import_dist27 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/approve.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
var import_buffer_layout2 = __toESM(require_Layout(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/internal.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);
function addSigners(keys, ownerOrAuthority, multiSigners) {
  if (multiSigners.length) {
    keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
    for (const signer of multiSigners) {
      keys.push({
        pubkey: signer instanceof PublicKey ? signer : signer.publicKey,
        isSigner: true,
        isWritable: false
      });
    }
  } else {
    keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
  }
  return keys;
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/approve.js
var approveInstructionData = (0, import_buffer_layout2.struct)([(0, import_buffer_layout2.u8)("instruction"), u64("amount")]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/internal.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/approveChecked.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/approveChecked.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);
var import_buffer_layout3 = __toESM(require_Layout(), 1);
var approveCheckedInstructionData = (0, import_buffer_layout3.struct)([
  (0, import_buffer_layout3.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout3.u8)("decimals")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/burn.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/burn.js
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);
var import_buffer_layout4 = __toESM(require_Layout(), 1);
var burnInstructionData = (0, import_buffer_layout4.struct)([(0, import_buffer_layout4.u8)("instruction"), u64("amount")]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/burnChecked.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/burnChecked.js
var import_dist40 = __toESM(require_dist(), 1);
var import_dist41 = __toESM(require_dist2(), 1);
var import_dist42 = __toESM(require_dist3(), 1);
var import_buffer_layout5 = __toESM(require_Layout(), 1);
var burnCheckedInstructionData = (0, import_buffer_layout5.struct)([
  (0, import_buffer_layout5.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout5.u8)("decimals")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/closeAccount.js
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/closeAccount.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);
var import_buffer_layout6 = __toESM(require_Layout(), 1);
var closeAccountInstructionData = (0, import_buffer_layout6.struct)([(0, import_buffer_layout6.u8)("instruction")]);
function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(closeAccountInstructionData.span);
  closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/createAccount.js
var import_dist160 = __toESM(require_dist(), 1);
var import_dist161 = __toESM(require_dist2(), 1);
var import_dist162 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/extensionType.js
var import_dist148 = __toESM(require_dist(), 1);
var import_dist149 = __toESM(require_dist2(), 1);
var import_dist150 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/state/account.js
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);
var import_buffer_layout8 = __toESM(require_Layout(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/accountType.js
var import_dist52 = __toESM(require_dist(), 1);
var import_dist53 = __toESM(require_dist2(), 1);
var import_dist54 = __toESM(require_dist3(), 1);
var AccountType;
(function(AccountType2) {
  AccountType2[AccountType2["Uninitialized"] = 0] = "Uninitialized";
  AccountType2[AccountType2["Mint"] = 1] = "Mint";
  AccountType2[AccountType2["Account"] = 2] = "Account";
})(AccountType || (AccountType = {}));
var ACCOUNT_TYPE_SIZE = 1;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/state/multisig.js
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);
var import_buffer_layout7 = __toESM(require_Layout(), 1);
var MultisigLayout = (0, import_buffer_layout7.struct)([
  (0, import_buffer_layout7.u8)("m"),
  (0, import_buffer_layout7.u8)("n"),
  bool("isInitialized"),
  publicKey("signer1"),
  publicKey("signer2"),
  publicKey("signer3"),
  publicKey("signer4"),
  publicKey("signer5"),
  publicKey("signer6"),
  publicKey("signer7"),
  publicKey("signer8"),
  publicKey("signer9"),
  publicKey("signer10"),
  publicKey("signer11")
]);
var MULTISIG_SIZE = MultisigLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/state/account.js
var AccountState;
(function(AccountState2) {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
var AccountLayout = (0, import_buffer_layout8.struct)([
  publicKey("mint"),
  publicKey("owner"),
  u64("amount"),
  (0, import_buffer_layout8.u32)("delegateOption"),
  publicKey("delegate"),
  (0, import_buffer_layout8.u8)("state"),
  (0, import_buffer_layout8.u32)("isNativeOption"),
  u64("isNative"),
  u64("delegatedAmount"),
  (0, import_buffer_layout8.u32)("closeAuthorityOption"),
  publicKey("closeAuthority")
]);
var ACCOUNT_SIZE = AccountLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/state/mint.js
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);
var import_buffer_layout9 = __toESM(require_Layout(), 1);
var MintLayout = (0, import_buffer_layout9.struct)([
  (0, import_buffer_layout9.u32)("mintAuthorityOption"),
  publicKey("mintAuthority"),
  u64("supply"),
  (0, import_buffer_layout9.u8)("decimals"),
  bool("isInitialized"),
  (0, import_buffer_layout9.u32)("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]);
var MINT_SIZE = MintLayout.span;
function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length < MINT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));
  let tlvData = Buffer.alloc(0);
  if (info.data.length > MINT_SIZE) {
    if (info.data.length <= ACCOUNT_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data[ACCOUNT_SIZE] != AccountType.Mint)
      throw new TokenInvalidMintError();
    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address,
    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
    supply: rawMint.supply,
    decimals: rawMint.decimals,
    isInitialized: rawMint.isInitialized,
    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
    tlvData
  };
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/index.js
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/actions.js
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/instructions.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);
var import_buffer_layout10 = __toESM(require_Layout(), 1);
var CpiGuardInstruction;
(function(CpiGuardInstruction2) {
  CpiGuardInstruction2[CpiGuardInstruction2["Enable"] = 0] = "Enable";
  CpiGuardInstruction2[CpiGuardInstruction2["Disable"] = 1] = "Disable";
})(CpiGuardInstruction || (CpiGuardInstruction = {}));
var cpiGuardInstructionData = (0, import_buffer_layout10.struct)([(0, import_buffer_layout10.u8)("instruction"), (0, import_buffer_layout10.u8)("cpiGuardInstruction")]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/cpiGuard/state.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);
var import_buffer_layout11 = __toESM(require_Layout(), 1);
var CpiGuardLayout = (0, import_buffer_layout11.struct)([bool("lockCpi")]);
var CPI_GUARD_SIZE = CpiGuardLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/index.js
var import_dist85 = __toESM(require_dist(), 1);
var import_dist86 = __toESM(require_dist2(), 1);
var import_dist87 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/actions.js
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/instructions.js
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);
var import_buffer_layout12 = __toESM(require_Layout(), 1);
var DefaultAccountStateInstruction;
(function(DefaultAccountStateInstruction2) {
  DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Initialize"] = 0] = "Initialize";
  DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Update"] = 1] = "Update";
})(DefaultAccountStateInstruction || (DefaultAccountStateInstruction = {}));
var defaultAccountStateInstructionData = (0, import_buffer_layout12.struct)([
  (0, import_buffer_layout12.u8)("instruction"),
  (0, import_buffer_layout12.u8)("defaultAccountStateInstruction"),
  (0, import_buffer_layout12.u8)("accountState")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/defaultAccountState/state.js
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);
var import_buffer_layout13 = __toESM(require_Layout(), 1);
var DefaultAccountStateLayout = (0, import_buffer_layout13.struct)([(0, import_buffer_layout13.u8)("state")]);
var DEFAULT_ACCOUNT_STATE_SIZE = DefaultAccountStateLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/immutableOwner.js
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);
var import_buffer_layout14 = __toESM(require_Layout(), 1);
var ImmutableOwnerLayout = (0, import_buffer_layout14.struct)([]);
var IMMUTABLE_OWNER_SIZE = ImmutableOwnerLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/state.js
var import_dist91 = __toESM(require_dist(), 1);
var import_dist92 = __toESM(require_dist2(), 1);
var import_dist93 = __toESM(require_dist3(), 1);
var import_buffer_layout15 = __toESM(require_Layout(), 1);
var InterestBearingMintConfigStateLayout = (0, import_buffer_layout15.struct)([
  publicKey("rateAuthority"),
  (0, import_buffer_layout15.ns64)("initializationTimestamp"),
  (0, import_buffer_layout15.s16)("preUpdateAverageRate"),
  (0, import_buffer_layout15.ns64)("lastUpdateTimestamp"),
  (0, import_buffer_layout15.s16)("currentRate")
]);
var INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = InterestBearingMintConfigStateLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/index.js
var import_dist103 = __toESM(require_dist(), 1);
var import_dist104 = __toESM(require_dist2(), 1);
var import_dist105 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/actions.js
var import_dist97 = __toESM(require_dist(), 1);
var import_dist98 = __toESM(require_dist2(), 1);
var import_dist99 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/instructions.js
var import_dist94 = __toESM(require_dist(), 1);
var import_dist95 = __toESM(require_dist2(), 1);
var import_dist96 = __toESM(require_dist3(), 1);
var import_buffer_layout16 = __toESM(require_Layout(), 1);
var MemoTransferInstruction;
(function(MemoTransferInstruction2) {
  MemoTransferInstruction2[MemoTransferInstruction2["Enable"] = 0] = "Enable";
  MemoTransferInstruction2[MemoTransferInstruction2["Disable"] = 1] = "Disable";
})(MemoTransferInstruction || (MemoTransferInstruction = {}));
var memoTransferInstructionData = (0, import_buffer_layout16.struct)([
  (0, import_buffer_layout16.u8)("instruction"),
  (0, import_buffer_layout16.u8)("memoTransferInstruction")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/memoTransfer/state.js
var import_dist100 = __toESM(require_dist(), 1);
var import_dist101 = __toESM(require_dist2(), 1);
var import_dist102 = __toESM(require_dist3(), 1);
var import_buffer_layout17 = __toESM(require_Layout(), 1);
var MemoTransferLayout = (0, import_buffer_layout17.struct)([bool("requireIncomingTransferMemos")]);
var MEMO_TRANSFER_SIZE = MemoTransferLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/metadataPointer/state.js
var import_dist106 = __toESM(require_dist(), 1);
var import_dist107 = __toESM(require_dist2(), 1);
var import_dist108 = __toESM(require_dist3(), 1);
var import_buffer_layout18 = __toESM(require_Layout(), 1);
var MetadataPointerLayout = (0, import_buffer_layout18.struct)([
  publicKey("authority"),
  publicKey("metadataAddress")
]);
var METADATA_POINTER_SIZE = MetadataPointerLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/mintCloseAuthority.js
var import_dist109 = __toESM(require_dist(), 1);
var import_dist110 = __toESM(require_dist2(), 1);
var import_dist111 = __toESM(require_dist3(), 1);
var import_buffer_layout19 = __toESM(require_Layout(), 1);
var MintCloseAuthorityLayout = (0, import_buffer_layout19.struct)([publicKey("closeAuthority")]);
var MINT_CLOSE_AUTHORITY_SIZE = MintCloseAuthorityLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/nonTransferable.js
var import_dist112 = __toESM(require_dist(), 1);
var import_dist113 = __toESM(require_dist2(), 1);
var import_dist114 = __toESM(require_dist3(), 1);
var import_buffer_layout20 = __toESM(require_Layout(), 1);
var NonTransferableLayout = (0, import_buffer_layout20.struct)([]);
var NON_TRANSFERABLE_SIZE = NonTransferableLayout.span;
var NON_TRANSFERABLE_ACCOUNT_SIZE = NonTransferableLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/permanentDelegate.js
var import_dist115 = __toESM(require_dist(), 1);
var import_dist116 = __toESM(require_dist2(), 1);
var import_dist117 = __toESM(require_dist3(), 1);
var import_buffer_layout21 = __toESM(require_Layout(), 1);
var PermanentDelegateLayout = (0, import_buffer_layout21.struct)([publicKey("delegate")]);
var PERMANENT_DELEGATE_SIZE = PermanentDelegateLayout.span;

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferFee/index.js
var import_dist127 = __toESM(require_dist(), 1);
var import_dist128 = __toESM(require_dist2(), 1);
var import_dist129 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferFee/actions.js
var import_dist121 = __toESM(require_dist(), 1);
var import_dist122 = __toESM(require_dist2(), 1);
var import_dist123 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferFee/instructions.js
var import_dist118 = __toESM(require_dist(), 1);
var import_dist119 = __toESM(require_dist2(), 1);
var import_dist120 = __toESM(require_dist3(), 1);
var import_buffer_layout22 = __toESM(require_Layout(), 1);
var TransferFeeInstruction;
(function(TransferFeeInstruction2) {
  TransferFeeInstruction2[TransferFeeInstruction2["InitializeTransferFeeConfig"] = 0] = "InitializeTransferFeeConfig";
  TransferFeeInstruction2[TransferFeeInstruction2["TransferCheckedWithFee"] = 1] = "TransferCheckedWithFee";
  TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromMint"] = 2] = "WithdrawWithheldTokensFromMint";
  TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromAccounts"] = 3] = "WithdrawWithheldTokensFromAccounts";
  TransferFeeInstruction2[TransferFeeInstruction2["HarvestWithheldTokensToMint"] = 4] = "HarvestWithheldTokensToMint";
  TransferFeeInstruction2[TransferFeeInstruction2["SetTransferFee"] = 5] = "SetTransferFee";
})(TransferFeeInstruction || (TransferFeeInstruction = {}));
var initializeTransferFeeConfigInstructionData = (0, import_buffer_layout22.struct)([
  (0, import_buffer_layout22.u8)("instruction"),
  (0, import_buffer_layout22.u8)("transferFeeInstruction"),
  (0, import_buffer_layout22.u8)("transferFeeConfigAuthorityOption"),
  publicKey("transferFeeConfigAuthority"),
  (0, import_buffer_layout22.u8)("withdrawWithheldAuthorityOption"),
  publicKey("withdrawWithheldAuthority"),
  (0, import_buffer_layout22.u16)("transferFeeBasisPoints"),
  u64("maximumFee")
]);
var transferCheckedWithFeeInstructionData = (0, import_buffer_layout22.struct)([
  (0, import_buffer_layout22.u8)("instruction"),
  (0, import_buffer_layout22.u8)("transferFeeInstruction"),
  u64("amount"),
  (0, import_buffer_layout22.u8)("decimals"),
  u64("fee")
]);
var withdrawWithheldTokensFromMintInstructionData = (0, import_buffer_layout22.struct)([
  (0, import_buffer_layout22.u8)("instruction"),
  (0, import_buffer_layout22.u8)("transferFeeInstruction")
]);
var withdrawWithheldTokensFromAccountsInstructionData = (0, import_buffer_layout22.struct)([
  (0, import_buffer_layout22.u8)("instruction"),
  (0, import_buffer_layout22.u8)("transferFeeInstruction"),
  (0, import_buffer_layout22.u8)("numTokenAccounts")
]);
var harvestWithheldTokensToMintInstructionData = (0, import_buffer_layout22.struct)([
  (0, import_buffer_layout22.u8)("instruction"),
  (0, import_buffer_layout22.u8)("transferFeeInstruction")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferFee/state.js
var import_dist124 = __toESM(require_dist(), 1);
var import_dist125 = __toESM(require_dist2(), 1);
var import_dist126 = __toESM(require_dist3(), 1);
var import_buffer_layout23 = __toESM(require_Layout(), 1);
var MAX_FEE_BASIS_POINTS = 1e4;
var ONE_IN_BASIS_POINTS = BigInt(MAX_FEE_BASIS_POINTS);
function transferFeeLayout(property) {
  return (0, import_buffer_layout23.struct)([u64("epoch"), u64("maximumFee"), (0, import_buffer_layout23.u16)("transferFeeBasisPoints")], property);
}
var TransferFeeConfigLayout = (0, import_buffer_layout23.struct)([
  publicKey("transferFeeConfigAuthority"),
  publicKey("withdrawWithheldAuthority"),
  u64("withheldAmount"),
  transferFeeLayout("olderTransferFee"),
  transferFeeLayout("newerTransferFee")
]);
var TRANSFER_FEE_CONFIG_SIZE = TransferFeeConfigLayout.span;
var TransferFeeAmountLayout = (0, import_buffer_layout23.struct)([u64("withheldAmount")]);
var TRANSFER_FEE_AMOUNT_SIZE = TransferFeeAmountLayout.span;
function getTransferFeeConfig(mint) {
  const extensionData = getExtensionData(ExtensionType.TransferFeeConfig, mint.tlvData);
  if (extensionData !== null) {
    return TransferFeeConfigLayout.decode(extensionData);
  } else {
    return null;
  }
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/index.js
var import_dist145 = __toESM(require_dist(), 1);
var import_dist146 = __toESM(require_dist2(), 1);
var import_dist147 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/actions.js
var import_dist142 = __toESM(require_dist(), 1);
var import_dist143 = __toESM(require_dist2(), 1);
var import_dist144 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/instructions.js
var import_dist139 = __toESM(require_dist(), 1);
var import_dist140 = __toESM(require_dist2(), 1);
var import_dist141 = __toESM(require_dist3(), 1);
var import_buffer_layout26 = __toESM(require_Layout(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/transferChecked.js
var import_dist130 = __toESM(require_dist(), 1);
var import_dist131 = __toESM(require_dist2(), 1);
var import_dist132 = __toESM(require_dist3(), 1);
var import_buffer_layout24 = __toESM(require_Layout(), 1);
var transferCheckedInstructionData = (0, import_buffer_layout24.struct)([
  (0, import_buffer_layout24.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout24.u8)("decimals")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/state.js
var import_dist136 = __toESM(require_dist(), 1);
var import_dist137 = __toESM(require_dist2(), 1);
var import_dist138 = __toESM(require_dist3(), 1);
var import_buffer_layout25 = __toESM(require_Layout(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/seeds.js
var import_dist133 = __toESM(require_dist(), 1);
var import_dist134 = __toESM(require_dist2(), 1);
var import_dist135 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/state.js
var TransferHookLayout = (0, import_buffer_layout25.struct)([publicKey("authority"), publicKey("programId")]);
var TRANSFER_HOOK_SIZE = TransferHookLayout.span;
var TransferHookAccountLayout = (0, import_buffer_layout25.struct)([bool("transferring")]);
var TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;
var ExtraAccountMetaLayout = (0, import_buffer_layout25.struct)([
  (0, import_buffer_layout25.u8)("discriminator"),
  (0, import_buffer_layout25.blob)(32, "addressConfig"),
  bool("isSigner"),
  bool("isWritable")
]);
var ExtraAccountMetaListLayout = (0, import_buffer_layout25.struct)([
  (0, import_buffer_layout25.u32)("count"),
  (0, import_buffer_layout25.seq)(ExtraAccountMetaLayout, (0, import_buffer_layout25.greedy)(ExtraAccountMetaLayout.span), "extraAccounts")
]);
var ExtraAccountMetaAccountDataLayout = (0, import_buffer_layout25.struct)([
  u64("instructionDiscriminator"),
  (0, import_buffer_layout25.u32)("length"),
  ExtraAccountMetaListLayout.replicate("extraAccountsList")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/transferHook/instructions.js
var TransferHookInstruction;
(function(TransferHookInstruction2) {
  TransferHookInstruction2[TransferHookInstruction2["Initialize"] = 0] = "Initialize";
  TransferHookInstruction2[TransferHookInstruction2["Update"] = 1] = "Update";
})(TransferHookInstruction || (TransferHookInstruction = {}));
var initializeTransferHookInstructionData = (0, import_buffer_layout26.struct)([
  (0, import_buffer_layout26.u8)("instruction"),
  (0, import_buffer_layout26.u8)("transferHookInstruction"),
  publicKey("authority"),
  publicKey("transferHookProgramId")
]);
var updateTransferHookInstructionData = (0, import_buffer_layout26.struct)([
  (0, import_buffer_layout26.u8)("instruction"),
  (0, import_buffer_layout26.u8)("transferHookInstruction"),
  publicKey("transferHookProgramId")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/extensionType.js
var ExtensionType;
(function(ExtensionType2) {
  ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
  ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
  ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
  ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
  ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
  ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
  ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
  ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
  ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
  ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
  ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
  ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
  ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
  ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
  ExtensionType2[ExtensionType2["TransferHook"] = 14] = "TransferHook";
  ExtensionType2[ExtensionType2["TransferHookAccount"] = 15] = "TransferHookAccount";
  ExtensionType2[ExtensionType2["MetadataPointer"] = 18] = "MetadataPointer";
  ExtensionType2[ExtensionType2["TokenMetadata"] = 19] = "TokenMetadata";
})(ExtensionType || (ExtensionType = {}));
var TYPE_SIZE = 2;
var LENGTH_SIZE = 2;
function addTypeAndLengthToLen(len) {
  return len + TYPE_SIZE + LENGTH_SIZE;
}
function getExtensionData(extension, tlvData) {
  let extensionTypeIndex = 0;
  while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {
    const entryType = tlvData.readUInt16LE(extensionTypeIndex);
    const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);
    const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);
    if (entryType == extension) {
      return tlvData.slice(typeIndex, typeIndex + entryLength);
    }
    extensionTypeIndex = typeIndex + entryLength;
  }
  return null;
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount.js
var import_dist151 = __toESM(require_dist(), 1);
var import_dist152 = __toESM(require_dist2(), 1);
var import_dist153 = __toESM(require_dist3(), 1);
var import_buffer_layout27 = __toESM(require_Layout(), 1);
var initializeAccountInstructionData = (0, import_buffer_layout27.struct)([(0, import_buffer_layout27.u8)("instruction")]);
function createInitializeAccountInstruction(account, mint, owner, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: account, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(initializeAccountInstructionData.span);
  initializeAccountInstructionData.encode({ instruction: TokenInstruction.InitializeAccount }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/createAssociatedTokenAccount.js
var import_dist157 = __toESM(require_dist(), 1);
var import_dist158 = __toESM(require_dist2(), 1);
var import_dist159 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/associatedTokenAccount.js
var import_dist154 = __toESM(require_dist(), 1);
var import_dist155 = __toESM(require_dist2(), 1);
var import_dist156 = __toESM(require_dist3(), 1);
function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.alloc(0), programId, associatedTokenProgramId);
}
function buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedToken, isSigner: false, isWritable: true },
    { pubkey: owner, isSigner: false, isWritable: false },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
    { pubkey: programId, isSigner: false, isWritable: false }
  ];
  return new TransactionInstruction({
    keys,
    programId: associatedTokenProgramId,
    data: instructionData
  });
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/createAssociatedTokenAccountIdempotent.js
var import_dist163 = __toESM(require_dist(), 1);
var import_dist164 = __toESM(require_dist2(), 1);
var import_dist165 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/createMint.js
var import_dist169 = __toESM(require_dist(), 1);
var import_dist170 = __toESM(require_dist2(), 1);
var import_dist171 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeMint2.js
var import_dist166 = __toESM(require_dist(), 1);
var import_dist167 = __toESM(require_dist2(), 1);
var import_dist168 = __toESM(require_dist3(), 1);
var import_buffer_layout28 = __toESM(require_Layout(), 1);
var initializeMint2InstructionData = (0, import_buffer_layout28.struct)([
  (0, import_buffer_layout28.u8)("instruction"),
  (0, import_buffer_layout28.u8)("decimals"),
  publicKey("mintAuthority"),
  (0, import_buffer_layout28.u8)("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/createMultisig.js
var import_dist175 = __toESM(require_dist(), 1);
var import_dist176 = __toESM(require_dist2(), 1);
var import_dist177 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeMultisig.js
var import_dist172 = __toESM(require_dist(), 1);
var import_dist173 = __toESM(require_dist2(), 1);
var import_dist174 = __toESM(require_dist3(), 1);
var import_buffer_layout29 = __toESM(require_Layout(), 1);
var initializeMultisigInstructionData = (0, import_buffer_layout29.struct)([
  (0, import_buffer_layout29.u8)("instruction"),
  (0, import_buffer_layout29.u8)("m")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/createNativeMint.js
var import_dist181 = __toESM(require_dist(), 1);
var import_dist182 = __toESM(require_dist2(), 1);
var import_dist183 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/createNativeMint.js
var import_dist178 = __toESM(require_dist(), 1);
var import_dist179 = __toESM(require_dist2(), 1);
var import_dist180 = __toESM(require_dist3(), 1);
var import_buffer_layout30 = __toESM(require_Layout(), 1);
var createNativeMintInstructionData = (0, import_buffer_layout30.struct)([(0, import_buffer_layout30.u8)("instruction")]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/createWrappedNativeAccount.js
var import_dist187 = __toESM(require_dist(), 1);
var import_dist188 = __toESM(require_dist2(), 1);
var import_dist189 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/syncNative.js
var import_dist184 = __toESM(require_dist(), 1);
var import_dist185 = __toESM(require_dist2(), 1);
var import_dist186 = __toESM(require_dist3(), 1);
var import_buffer_layout31 = __toESM(require_Layout(), 1);
var syncNativeInstructionData = (0, import_buffer_layout31.struct)([(0, import_buffer_layout31.u8)("instruction")]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/freezeAccount.js
var import_dist193 = __toESM(require_dist(), 1);
var import_dist194 = __toESM(require_dist2(), 1);
var import_dist195 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/freezeAccount.js
var import_dist190 = __toESM(require_dist(), 1);
var import_dist191 = __toESM(require_dist2(), 1);
var import_dist192 = __toESM(require_dist3(), 1);
var import_buffer_layout32 = __toESM(require_Layout(), 1);
var freezeAccountInstructionData = (0, import_buffer_layout32.struct)([(0, import_buffer_layout32.u8)("instruction")]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/getOrCreateAssociatedTokenAccount.js
var import_dist196 = __toESM(require_dist(), 1);
var import_dist197 = __toESM(require_dist2(), 1);
var import_dist198 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/mintTo.js
var import_dist202 = __toESM(require_dist(), 1);
var import_dist203 = __toESM(require_dist2(), 1);
var import_dist204 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/mintTo.js
var import_dist199 = __toESM(require_dist(), 1);
var import_dist200 = __toESM(require_dist2(), 1);
var import_dist201 = __toESM(require_dist3(), 1);
var import_buffer_layout33 = __toESM(require_Layout(), 1);
var mintToInstructionData = (0, import_buffer_layout33.struct)([(0, import_buffer_layout33.u8)("instruction"), u64("amount")]);
function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], authority, multiSigners);
  const data = Buffer.alloc(mintToInstructionData.span);
  mintToInstructionData.encode({
    instruction: TokenInstruction.MintTo,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/mintToChecked.js
var import_dist208 = __toESM(require_dist(), 1);
var import_dist209 = __toESM(require_dist2(), 1);
var import_dist210 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/mintToChecked.js
var import_dist205 = __toESM(require_dist(), 1);
var import_dist206 = __toESM(require_dist2(), 1);
var import_dist207 = __toESM(require_dist3(), 1);
var import_buffer_layout34 = __toESM(require_Layout(), 1);
var mintToCheckedInstructionData = (0, import_buffer_layout34.struct)([
  (0, import_buffer_layout34.u8)("instruction"),
  u64("amount"),
  (0, import_buffer_layout34.u8)("decimals")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/recoverNested.js
var import_dist211 = __toESM(require_dist(), 1);
var import_dist212 = __toESM(require_dist2(), 1);
var import_dist213 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/revoke.js
var import_dist217 = __toESM(require_dist(), 1);
var import_dist218 = __toESM(require_dist2(), 1);
var import_dist219 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/revoke.js
var import_dist214 = __toESM(require_dist(), 1);
var import_dist215 = __toESM(require_dist2(), 1);
var import_dist216 = __toESM(require_dist3(), 1);
var import_buffer_layout35 = __toESM(require_Layout(), 1);
var revokeInstructionData = (0, import_buffer_layout35.struct)([(0, import_buffer_layout35.u8)("instruction")]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/setAuthority.js
var import_dist223 = __toESM(require_dist(), 1);
var import_dist224 = __toESM(require_dist2(), 1);
var import_dist225 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/setAuthority.js
var import_dist220 = __toESM(require_dist(), 1);
var import_dist221 = __toESM(require_dist2(), 1);
var import_dist222 = __toESM(require_dist3(), 1);
var import_buffer_layout36 = __toESM(require_Layout(), 1);
var AuthorityType;
(function(AuthorityType2) {
  AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
  AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
  AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
  AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
  AuthorityType2[AuthorityType2["TransferFeeConfig"] = 4] = "TransferFeeConfig";
  AuthorityType2[AuthorityType2["WithheldWithdraw"] = 5] = "WithheldWithdraw";
  AuthorityType2[AuthorityType2["CloseMint"] = 6] = "CloseMint";
  AuthorityType2[AuthorityType2["InterestRate"] = 7] = "InterestRate";
  AuthorityType2[AuthorityType2["PermanentDelegate"] = 8] = "PermanentDelegate";
  AuthorityType2[AuthorityType2["ConfidentialTransferMint"] = 9] = "ConfidentialTransferMint";
  AuthorityType2[AuthorityType2["TransferHookProgramId"] = 10] = "TransferHookProgramId";
  AuthorityType2[AuthorityType2["ConfidentialTransferFeeConfig"] = 11] = "ConfidentialTransferFeeConfig";
  AuthorityType2[AuthorityType2["MetadataPointer"] = 12] = "MetadataPointer";
})(AuthorityType || (AuthorityType = {}));
var setAuthorityInstructionData = (0, import_buffer_layout36.struct)([
  (0, import_buffer_layout36.u8)("instruction"),
  (0, import_buffer_layout36.u8)("authorityType"),
  (0, import_buffer_layout36.u8)("newAuthorityOption"),
  publicKey("newAuthority")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/syncNative.js
var import_dist226 = __toESM(require_dist(), 1);
var import_dist227 = __toESM(require_dist2(), 1);
var import_dist228 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/thawAccount.js
var import_dist232 = __toESM(require_dist(), 1);
var import_dist233 = __toESM(require_dist2(), 1);
var import_dist234 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/thawAccount.js
var import_dist229 = __toESM(require_dist(), 1);
var import_dist230 = __toESM(require_dist2(), 1);
var import_dist231 = __toESM(require_dist3(), 1);
var import_buffer_layout37 = __toESM(require_Layout(), 1);
var thawAccountInstructionData = (0, import_buffer_layout37.struct)([(0, import_buffer_layout37.u8)("instruction")]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/transfer.js
var import_dist238 = __toESM(require_dist(), 1);
var import_dist239 = __toESM(require_dist2(), 1);
var import_dist240 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/transfer.js
var import_dist235 = __toESM(require_dist(), 1);
var import_dist236 = __toESM(require_dist2(), 1);
var import_dist237 = __toESM(require_dist3(), 1);
var import_buffer_layout38 = __toESM(require_Layout(), 1);
var transferInstructionData = (0, import_buffer_layout38.struct)([(0, import_buffer_layout38.u8)("instruction"), u64("amount")]);
function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(transferInstructionData.span);
  transferInstructionData.encode({
    instruction: TokenInstruction.Transfer,
    amount: BigInt(amount)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/transferChecked.js
var import_dist241 = __toESM(require_dist(), 1);
var import_dist242 = __toESM(require_dist2(), 1);
var import_dist243 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/actions/uiAmountToAmount.js
var import_dist247 = __toESM(require_dist(), 1);
var import_dist248 = __toESM(require_dist2(), 1);
var import_dist249 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/uiAmountToAmount.js
var import_dist244 = __toESM(require_dist(), 1);
var import_dist245 = __toESM(require_dist2(), 1);
var import_dist246 = __toESM(require_dist3(), 1);
var import_buffer_layout39 = __toESM(require_Layout(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/index.js
var import_dist283 = __toESM(require_dist(), 1);
var import_dist284 = __toESM(require_dist2(), 1);
var import_dist285 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/index.js
var import_dist262 = __toESM(require_dist(), 1);
var import_dist263 = __toESM(require_dist2(), 1);
var import_dist264 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/actions.js
var import_dist259 = __toESM(require_dist(), 1);
var import_dist260 = __toESM(require_dist2(), 1);
var import_dist261 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeMint.js
var import_dist253 = __toESM(require_dist(), 1);
var import_dist254 = __toESM(require_dist2(), 1);
var import_dist255 = __toESM(require_dist3(), 1);
var import_buffer_layout40 = __toESM(require_Layout(), 1);
var initializeMintInstructionData = (0, import_buffer_layout40.struct)([
  (0, import_buffer_layout40.u8)("instruction"),
  (0, import_buffer_layout40.u8)("decimals"),
  publicKey("mintAuthority"),
  (0, import_buffer_layout40.u8)("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]);
function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = TOKEN_PROGRAM_ID) {
  const keys = [
    { pubkey: mint, isSigner: false, isWritable: true },
    { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(initializeMintInstructionData.span);
  initializeMintInstructionData.encode({
    instruction: TokenInstruction.InitializeMint,
    decimals,
    mintAuthority,
    freezeAuthorityOption: freezeAuthority ? 1 : 0,
    freezeAuthority: freezeAuthority || new PublicKey(0)
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/interestBearingMint/instructions.js
var import_dist256 = __toESM(require_dist(), 1);
var import_dist257 = __toESM(require_dist2(), 1);
var import_dist258 = __toESM(require_dist3(), 1);
var import_buffer_layout41 = __toESM(require_Layout(), 1);
var InterestBearingMintInstruction;
(function(InterestBearingMintInstruction2) {
  InterestBearingMintInstruction2[InterestBearingMintInstruction2["Initialize"] = 0] = "Initialize";
  InterestBearingMintInstruction2[InterestBearingMintInstruction2["UpdateRate"] = 1] = "UpdateRate";
})(InterestBearingMintInstruction || (InterestBearingMintInstruction = {}));
var interestBearingMintInitializeInstructionData = (0, import_buffer_layout41.struct)([
  (0, import_buffer_layout41.u8)("instruction"),
  (0, import_buffer_layout41.u8)("interestBearingMintInstruction"),
  // TODO: Make this an optional public key
  publicKey("rateAuthority"),
  (0, import_buffer_layout41.s16)("rate")
]);
var interestBearingMintUpdateRateInstructionData = (0, import_buffer_layout41.struct)([
  (0, import_buffer_layout41.u8)("instruction"),
  (0, import_buffer_layout41.u8)("interestBearingMintInstruction"),
  (0, import_buffer_layout41.s16)("rate")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/metadataPointer/index.js
var import_dist268 = __toESM(require_dist(), 1);
var import_dist269 = __toESM(require_dist2(), 1);
var import_dist270 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/metadataPointer/instructions.js
var import_dist265 = __toESM(require_dist(), 1);
var import_dist266 = __toESM(require_dist2(), 1);
var import_dist267 = __toESM(require_dist3(), 1);
var import_buffer_layout42 = __toESM(require_Layout(), 1);
var MetadataPointerInstruction;
(function(MetadataPointerInstruction2) {
  MetadataPointerInstruction2[MetadataPointerInstruction2["Initialize"] = 0] = "Initialize";
  MetadataPointerInstruction2[MetadataPointerInstruction2["Update"] = 1] = "Update";
})(MetadataPointerInstruction || (MetadataPointerInstruction = {}));
var initializeMetadataPointerData = (0, import_buffer_layout42.struct)([
  // prettier-ignore
  (0, import_buffer_layout42.u8)("instruction"),
  (0, import_buffer_layout42.u8)("metadataPointerInstruction"),
  publicKey("authority"),
  publicKey("metadataAddress")
]);
var updateMetadataPointerData = (0, import_buffer_layout42.struct)([
  // prettier-ignore
  (0, import_buffer_layout42.u8)("instruction"),
  (0, import_buffer_layout42.u8)("metadataPointerInstruction"),
  publicKey("metadataAddress")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/tokenMetadata/index.js
var import_dist280 = __toESM(require_dist(), 1);
var import_dist281 = __toESM(require_dist2(), 1);
var import_dist282 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/tokenMetadata/actions.js
var import_dist277 = __toESM(require_dist(), 1);
var import_dist278 = __toESM(require_dist2(), 1);
var import_dist279 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/extensions/tokenMetadata/state.js
var import_dist271 = __toESM(require_dist(), 1);
var import_dist272 = __toESM(require_dist2(), 1);
var import_dist273 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/state/index.js
var import_dist274 = __toESM(require_dist(), 1);
var import_dist275 = __toESM(require_dist2(), 1);
var import_dist276 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/index.js
var import_dist313 = __toESM(require_dist(), 1);
var import_dist314 = __toESM(require_dist2(), 1);
var import_dist315 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/decode.js
var import_dist292 = __toESM(require_dist(), 1);
var import_dist293 = __toESM(require_dist2(), 1);
var import_dist294 = __toESM(require_dist3(), 1);
var import_buffer_layout45 = __toESM(require_Layout(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount2.js
var import_dist286 = __toESM(require_dist(), 1);
var import_dist287 = __toESM(require_dist2(), 1);
var import_dist288 = __toESM(require_dist3(), 1);
var import_buffer_layout43 = __toESM(require_Layout(), 1);
var initializeAccount2InstructionData = (0, import_buffer_layout43.struct)([
  (0, import_buffer_layout43.u8)("instruction"),
  publicKey("owner")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeAccount3.js
var import_dist289 = __toESM(require_dist(), 1);
var import_dist290 = __toESM(require_dist2(), 1);
var import_dist291 = __toESM(require_dist3(), 1);
var import_buffer_layout44 = __toESM(require_Layout(), 1);
var initializeAccount3InstructionData = (0, import_buffer_layout44.struct)([
  (0, import_buffer_layout44.u8)("instruction"),
  publicKey("owner")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeMultisig2.js
var import_dist295 = __toESM(require_dist(), 1);
var import_dist296 = __toESM(require_dist2(), 1);
var import_dist297 = __toESM(require_dist3(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeImmutableOwner.js
var import_dist298 = __toESM(require_dist(), 1);
var import_dist299 = __toESM(require_dist2(), 1);
var import_dist300 = __toESM(require_dist3(), 1);
var import_buffer_layout46 = __toESM(require_Layout(), 1);
var initializeImmutableOwnerInstructionData = (0, import_buffer_layout46.struct)([
  (0, import_buffer_layout46.u8)("instruction")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeMintCloseAuthority.js
var import_dist301 = __toESM(require_dist(), 1);
var import_dist302 = __toESM(require_dist2(), 1);
var import_dist303 = __toESM(require_dist3(), 1);
var import_buffer_layout47 = __toESM(require_Layout(), 1);
var initializeMintCloseAuthorityInstructionData = (0, import_buffer_layout47.struct)([
  (0, import_buffer_layout47.u8)("instruction"),
  (0, import_buffer_layout47.u8)("closeAuthorityOption"),
  publicKey("closeAuthority")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/reallocate.js
var import_dist304 = __toESM(require_dist(), 1);
var import_dist305 = __toESM(require_dist2(), 1);
var import_dist306 = __toESM(require_dist3(), 1);
var import_buffer_layout48 = __toESM(require_Layout(), 1);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializeNonTransferableMint.js
var import_dist307 = __toESM(require_dist(), 1);
var import_dist308 = __toESM(require_dist2(), 1);
var import_dist309 = __toESM(require_dist3(), 1);
var import_buffer_layout49 = __toESM(require_Layout(), 1);
var initializeNonTransferableMintInstructionData = (0, import_buffer_layout49.struct)([
  (0, import_buffer_layout49.u8)("instruction")
]);

// node_modules/@raydium-io/raydium-sdk/node_modules/@solana/spl-token/lib/esm/instructions/initializePermanentDelegate.js
var import_dist310 = __toESM(require_dist(), 1);
var import_dist311 = __toESM(require_dist2(), 1);
var import_dist312 = __toESM(require_dist3(), 1);
var import_buffer_layout50 = __toESM(require_Layout(), 1);
var initializePermanentDelegateInstructionData = (0, import_buffer_layout50.struct)([
  (0, import_buffer_layout50.u8)("instruction"),
  publicKey("delegate")
]);

// node_modules/big.js/big.mjs
var import_dist319 = __toESM(require_dist(), 1);
var import_dist320 = __toESM(require_dist2(), 1);
var import_dist321 = __toESM(require_dist3(), 1);
var DP = 20;
var RM = 1;
var MAX_DP = 1e6;
var MAX_POWER = 1e6;
var NE = -7;
var PE = 21;
var STRICT = false;
var NAME = "[big.js] ";
var INVALID = NAME + "Invalid ";
var INVALID_DP = INVALID + "decimal places";
var INVALID_RM = INVALID + "rounding mode";
var DIV_BY_ZERO = NAME + "Division by zero";
var P = {};
var UNDEFINED = void 0;
var NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function _Big_() {
  function Big3(n) {
    var x = this;
    if (!(x instanceof Big3)) return n === UNDEFINED ? _Big_() : new Big3(n);
    if (n instanceof Big3) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== "string") {
        if (Big3.strict === true && typeof n !== "bigint") {
          throw TypeError(INVALID + "value");
        }
        n = n === 0 && 1 / n < 0 ? "-0" : String(n);
      }
      parse(x, n);
    }
    x.constructor = Big3;
  }
  Big3.prototype = P;
  Big3.DP = DP;
  Big3.RM = RM;
  Big3.NE = NE;
  Big3.PE = PE;
  Big3.strict = STRICT;
  Big3.roundDown = 0;
  Big3.roundHalfUp = 1;
  Big3.roundHalfEven = 2;
  Big3.roundUp = 3;
  return Big3;
}
function parse(x, n) {
  var e, i, nl;
  if (!NUMERIC.test(n)) {
    throw Error(INVALID + "number");
  }
  x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
  if ((e = n.indexOf(".")) > -1) n = n.replace(".", "");
  if ((i = n.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {
    e = n.length;
  }
  nl = n.length;
  for (i = 0; i < nl && n.charAt(i) == "0"; ) ++i;
  if (i == nl) {
    x.c = [x.e = 0];
  } else {
    for (; nl > 0 && n.charAt(--nl) == "0"; ) ;
    x.e = e - i - 1;
    x.c = [];
    for (e = 0; i <= nl; ) x.c[e++] = +n.charAt(i++);
  }
  return x;
}
function round(x, sd, rm, more) {
  var xc = x.c;
  if (rm === UNDEFINED) rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }
  if (sd < 1) {
    more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
    xc.length = 1;
    if (more) {
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {
    more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);
    xc.length = sd;
    if (more) {
      for (; ++xc[--sd] > 9; ) {
        xc[sd] = 0;
        if (sd === 0) {
          ++x.e;
          xc.unshift(1);
          break;
        }
      }
    }
    for (sd = xc.length; !xc[--sd]; ) xc.pop();
  }
  return x;
}
function stringify(x, doExponential, isNonzero) {
  var e = x.e, s = x.c.join(""), n = s.length;
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    for (; ++e; ) s = "0" + s;
    s = "0." + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--; ) s += "0";
    } else if (e < n) {
      s = s.slice(0, e) + "." + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + "." + s.slice(1);
  }
  return x.s < 0 && isNonzero ? "-" + s : s;
}
P.abs = function() {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};
P.cmp = function(y) {
  var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;
  if (i != j) return i;
  isneg = i < 0;
  if (k != l) return k > l ^ isneg ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = -1; ++i < j; ) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};
P.div = function(y) {
  var x = this, Big3 = x.constructor, a = x.c, b = (y = new Big3(y)).c, k = x.s == y.s ? 1 : -1, dp = Big3.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }
  var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1;
  q.s = k;
  k = p < 0 ? 0 : p;
  bz.unshift(0);
  for (; rl++ < bl; ) r.push(0);
  do {
    for (n = 0; n < 10; n++) {
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl; ) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }
      if (cmp < 0) {
        for (bt = rl == bl ? b : bz; rl; ) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri]; ) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }
        for (; !r[0]; ) r.shift();
      } else {
        break;
      }
    }
    qc[qi++] = cmp ? n : ++n;
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];
  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
  if (!qc[0] && qi != 1) {
    qc.shift();
    q.e--;
    p--;
  }
  if (qi > p) round(q, p, Big3.RM, r[0] !== UNDEFINED);
  return q;
};
P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.gte = function(y) {
  return this.cmp(y) > -1;
};
P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.minus = P.sub = function(y) {
  var i, j, t, xlty, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }
  var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big3(x);
    } else {
      y.s = 1;
    }
    return y;
  }
  if (a = xe - ye) {
    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }
    t.reverse();
    for (b = a; b--; ) t.push(0);
    t.reverse();
  } else {
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;
    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--; ) xc[i++] = 0;
  for (b = i; j > a; ) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i]; ) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }
    xc[j] -= yc[j];
  }
  for (; xc[--b] === 0; ) xc.pop();
  for (; xc[0] === 0; ) {
    xc.shift();
    --ye;
  }
  if (!xc[0]) {
    y.s = 1;
    xc = [ye = 0];
  }
  y.c = xc;
  y.e = ye;
  return y;
};
P.mod = function(y) {
  var ygtx, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }
  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;
  if (ygtx) return new Big3(x);
  a = Big3.DP;
  b = Big3.RM;
  Big3.DP = Big3.RM = 0;
  x = x.div(y);
  Big3.DP = a;
  Big3.RM = b;
  return this.minus(x.times(y));
};
P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return x;
};
P.plus = P.add = function(y) {
  var e, k, t, x = this, Big3 = x.constructor;
  y = new Big3(y);
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big3(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }
  xc = xc.slice();
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }
    t.reverse();
    for (; e--; ) t.push(0);
    t.reverse();
  }
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }
  e = yc.length;
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;
  if (k) {
    xc.unshift(k);
    ++ye;
  }
  for (e = xc.length; xc[--e] === 0; ) xc.pop();
  y.c = xc;
  y.e = ye;
  return y;
};
P.pow = function(n) {
  var x = this, one = new x.constructor("1"), y = one, isneg = n < 0;
  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + "exponent");
  }
  if (isneg) n = -n;
  for (; ; ) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }
  return isneg ? one.div(y) : y;
};
P.prec = function(sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + "precision");
  }
  return round(new this.constructor(this), sd, rm);
};
P.round = function(dp, rm) {
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};
P.sqrt = function() {
  var r, c, t, x = this, Big3 = x.constructor, s = x.s, e = x.e, half = new Big3("0.5");
  if (!x.c[0]) return new Big3(x);
  if (s < 0) {
    throw Error(NAME + "No square root");
  }
  s = Math.sqrt(+stringify(x, true, true));
  if (s === 0 || s === 1 / 0) {
    c = x.c.join("");
    if (!(c.length + e & 1)) c += "0";
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big3((s == 1 / 0 ? "5e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
  } else {
    r = new Big3(s + "");
  }
  e = r.e + (Big3.DP += 4);
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
  return round(r, (Big3.DP -= 4) + r.e + 1, Big3.RM);
};
P.times = P.mul = function(y) {
  var c, x = this, Big3 = x.constructor, xc = x.c, yc = (y = new Big3(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
  y.s = x.s == y.s ? 1 : -1;
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }
  y.e = i + j;
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }
  for (c = new Array(j = a + b); j--; ) c[j] = 0;
  for (i = b; i--; ) {
    b = 0;
    for (j = a + i; j > i; ) {
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;
      b = b / 10 | 0;
    }
    c[j] = b;
  }
  if (b) ++y.e;
  else c.shift();
  for (i = c.length; !c[--i]; ) c.pop();
  y.c = c;
  return y;
};
P.toExponential = function(dp, rm) {
  var x = this, n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp; ) x.c.push(0);
  }
  return stringify(x, true, !!n);
};
P.toFixed = function(dp, rm) {
  var x = this, n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);
    for (dp = dp + x.e + 1; x.c.length < dp; ) x.c.push(0);
  }
  return stringify(x, false, !!n);
};
P[Symbol.for("nodejs.util.inspect.custom")] = P.toJSON = P.toString = function() {
  var x = this, Big3 = x.constructor;
  return stringify(x, x.e <= Big3.NE || x.e >= Big3.PE, !!x.c[0]);
};
P.toNumber = function() {
  var n = +stringify(this, true, true);
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + "Imprecise conversion");
  }
  return n;
};
P.toPrecision = function(sd, rm) {
  var x = this, Big3 = x.constructor, n = x.c[0];
  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + "precision");
    }
    x = round(new Big3(x), sd, rm);
    for (; x.c.length < sd; ) x.c.push(0);
  }
  return stringify(x, sd <= x.e || x.e <= Big3.NE || x.e >= Big3.PE, !!n);
};
P.valueOf = function() {
  var x = this, Big3 = x.constructor;
  if (Big3.strict === true) {
    throw Error(NAME + "valueOf disallowed");
  }
  return stringify(x, x.e <= Big3.NE || x.e >= Big3.PE, true);
};
var Big = _Big_();
var big_default = Big;

// node_modules/@raydium-io/raydium-sdk/dist/index.mjs
var import_bn = __toESM(require_bn(), 1);
var import_bn2 = __toESM(require_bn(), 1);
var import_bn3 = __toESM(require_bn(), 1);
var import_bn4 = __toESM(require_bn(), 1);
var import_bn5 = __toESM(require_bn(), 1);
var import_toformat = __toESM(require_toFormat(), 1);
var import_bn6 = __toESM(require_bn(), 1);
var import_buffer_layout51 = __toESM(require_Layout(), 1);
var import_bn7 = __toESM(require_bn(), 1);
var import_bn8 = __toESM(require_bn(), 1);
var import_bn9 = __toESM(require_bn(), 1);
var import_bn10 = __toESM(require_bn(), 1);
var import_bn11 = __toESM(require_bn(), 1);

// node_modules/decimal.js/decimal.mjs
var import_dist322 = __toESM(require_dist(), 1);
var import_dist323 = __toESM(require_dist2(), 1);
var import_dist324 = __toESM(require_dist3(), 1);
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P2 = { toStringTag: tag };
P2.absoluteValue = P2.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0) x.s = 1;
  return finalise(x);
};
P2.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P2.clampedTo = P2.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s) return new Ctor(NaN);
  if (min2.gt(max2)) throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P2.comparedTo = P2.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys) return xs;
  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P2.cosine = P2.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d) return new Ctor(NaN);
  if (!x.d[0]) return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P2.cubeRoot = P2.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P2.decimalPlaces = P2.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n--;
    if (n < 0) n = 0;
  }
  return n;
};
P2.dividedBy = P2.div = function(y) {
  return divide(this, new this.constructor(y));
};
P2.dividedToIntegerBy = P2.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P2.equals = P2.eq = function(y) {
  return this.cmp(y) === 0;
};
P2.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P2.greaterThan = P2.gt = function(y) {
  return this.cmp(y) > 0;
};
P2.greaterThanOrEqualTo = P2.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P2.hyperbolicCosine = P2.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P2.hyperbolicSine = P2.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P2.hyperbolicTangent = P2.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P2.inverseCosine = P2.acos = function() {
  var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P2.inverseHyperbolicCosine = P2.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P2.inverseHyperbolicSine = P2.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P2.inverseHyperbolicTangent = P2.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P2.inverseSine = P2.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero()) return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P2.inverseTangent = P2.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
  }
  if (k) r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P2.isFinite = function() {
  return !!this.d;
};
P2.isInteger = P2.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P2.isNaN = function() {
  return !this.s;
};
P2.isNegative = P2.isNeg = function() {
  return this.s < 0;
};
P2.isPositive = P2.isPos = function() {
  return this.s > 0;
};
P2.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P2.lessThan = P2.lt = function(y) {
  return this.cmp(y) < 0;
};
P2.lessThanOrEqualTo = P2.lte = function(y) {
  return this.cmp(y) < 1;
};
P2.logarithm = P2.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; ) k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P2.minus = P2.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s) y = new Ctor(NaN);
    else if (x.d) y.s = -y.s;
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0]) y.s = -y.s;
    else if (xd[0]) y = new Ctor(x);
    else return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; ) d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e;
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P2.modulo = P2.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P2.naturalExponential = P2.exp = function() {
  return naturalExponential(this);
};
P2.naturalLogarithm = P2.ln = function() {
  return naturalLogarithm(this);
};
P2.negated = P2.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P2.plus = P2.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s) y = new Ctor(NaN);
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0]) y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P2.precision = P2.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k) k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P2.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P2.sine = P2.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P2.squareRoot = P2.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0) n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P2.tangent = P2.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P2.times = P2.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; ) r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; ) r.pop();
  if (carry) ++e;
  else r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P2.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P2.toDecimalPlaces = P2.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0) return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P2.toExponential = function(dp, rm) {
  var str2, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str2 = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str2 = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
};
P2.toFixed = function(dp, rm) {
  var str2, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str2 = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str2 = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
};
P2.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd) return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P2.toHexadecimal = P2.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P2.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d) return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d) return y.s ? x : y;
    if (!y.d) {
      if (y.s) y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P2.toNumber = function() {
  return +this;
};
P2.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P2.toPower = P2.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1)) return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1)) return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1) return new Ctor(NaN);
    if ((y.d[e] & 1) == 0) s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P2.toPrecision = function(sd, rm) {
  var str2, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str2 = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str2 = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
};
P2.toSignificantDigits = P2.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P2.toString = function() {
  var x = this, Ctor = x.constructor, str2 = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str2 : str2;
};
P2.truncated = P2.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P2.valueOf = P2.toJSON = function() {
  var x = this, Ctor = x.constructor, str2 = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str2 : str2;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str2 = "", w = d[0];
  if (indexOfLastWord > 0) {
    str2 += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k) str2 += getZeroString(k);
      str2 += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k) str2 += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; ) w /= 10;
  return str2 + w;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10) --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = rd / 100 | 0;
      else if (i == 1) rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = rd / 1e3 | 0;
      else if (i == 1) rd = rd / 100 | 0;
      else if (i == 2) rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str2, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str2.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str2.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0) arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero()) return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = /* @__PURE__ */ (function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry) x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; ) a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++) ;
    if (yd[i] > (xd[i] || 0)) e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; ) rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2) ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base) k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0) cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0]) qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
})();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out: if (sd != null) {
    xd = x.d;
    if (!xd) return x;
    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
    i = sd - digits;
    if (i < 0) {
      i += LOG_BASE;
      j = sd;
      w = xd[xdi = 0];
      rd = w / mathpow(10, digits - j - 1) % 10 | 0;
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd.length;
      if (xdi >= k) {
        if (isTruncated) {
          for (; k++ <= xdi; ) xd.push(0);
          w = rd = 0;
          digits = 1;
          i %= LOG_BASE;
          j = i - LOG_BASE + 1;
        } else {
          break out;
        }
      } else {
        w = k = xd[xdi];
        for (digits = 1; k >= 10; k /= 10) digits++;
        i %= LOG_BASE;
        j = i - LOG_BASE + digits;
        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
      }
    }
    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
    roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
    if (sd < 1 || !xd[0]) {
      xd.length = 0;
      if (roundUp) {
        sd -= x.e + 1;
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x.e = -sd || 0;
      } else {
        xd[0] = x.e = 0;
      }
      return x;
    }
    if (i == 0) {
      xd.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);
      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
    }
    if (roundUp) {
      for (; ; ) {
        if (xdi == 0) {
          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
          j = xd[0] += k;
          for (k = 1; j >= 10; j /= 10) k++;
          if (i != k) {
            x.e++;
            if (xd[0] == BASE) xd[0] = 1;
          }
          break;
        } else {
          xd[xdi] += k;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k = 1;
        }
      }
    }
    for (i = xd.length; xd[--i] === 0; ) xd.pop();
  }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite()) return nonFiniteToString(x);
  var k, e = x.e, str2 = digitsToString(x.d), len = str2.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str2 = str2.charAt(0) + "." + str2.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str2 = str2.charAt(0) + "." + str2.slice(1);
    }
    str2 = str2 + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str2 = "0." + getZeroString(-e - 1) + str2;
    if (sd && (k = sd - len) > 0) str2 += getZeroString(k);
  } else if (e >= len) {
    str2 += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0) str2 = str2 + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len) str2 = str2.slice(0, k) + "." + str2.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str2 += ".";
      str2 += getZeroString(k);
    }
  }
  return str2;
}
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE; w >= 10; w /= 10) e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE + 1;
  w = digits[w];
  if (w) {
    for (; w % 10 == 0; w /= 10) len--;
    for (w = digits[0]; w >= 10; w /= 10) len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; ) zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k)) isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0) ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, n) {
  var k, y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    }
    k = x.cmp(y);
    if (k === n || k === 0 && x.s === n) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum2.plus(divide(pow2, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str2) {
  var e, i, len;
  if ((e = str2.indexOf(".")) > -1) str2 = str2.replace(".", "");
  if ((i = str2.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str2.slice(i + 1);
    str2 = str2.substring(0, i);
  } else if (e < 0) {
    e = str2.length;
  }
  for (i = 0; str2.charCodeAt(i) === 48; i++) ;
  for (len = str2.length; str2.charCodeAt(len - 1) === 48; --len) ;
  str2 = str2.slice(i, len);
  if (str2) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;
    if (i < len) {
      if (i) x.d.push(+str2.slice(0, i));
      for (len -= LOG_BASE; i < len; ) x.d.push(+str2.slice(i, i += LOG_BASE));
      str2 = str2.slice(i);
      i = LOG_BASE - str2.length;
    } else {
      i -= len;
    }
    for (; i--; ) str2 += "0";
    x.d.push(+str2);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str2) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str2.indexOf("_") > -1) {
    str2 = str2.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str2)) return parseDecimal(x, str2);
  } else if (str2 === "Infinity" || str2 === "NaN") {
    if (!+str2) x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str2)) {
    base = 16;
    str2 = str2.toLowerCase();
  } else if (isBinary.test(str2)) {
    base = 2;
  } else if (isOctal.test(str2)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str2);
  }
  i = str2.search(/p/i);
  if (i > 0) {
    p = +str2.slice(i + 1);
    str2 = str2.substring(2, i);
  } else {
    str2 = str2.slice(2);
  }
  i = str2.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str2 = str2.replace(".", "");
    len = str2.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str2, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i) xd.pop();
  if (i < 0) return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat) x = divide(x, divisor, len * 4);
  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; ) ;
      if (j == -1) break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e) n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str2, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str2 = nonFiniteToString(x);
  } else {
    str2 = finiteToString(x);
    i = str2.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str2 = str2.replace(".", "");
      y = new Ctor(1);
      y.e = str2.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str2, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; ) xd.pop();
    if (!xd[0]) {
      str2 = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len) ;
      for (i = 0, str2 = ""; i < len; i++) str2 += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++) str2 += "0";
            xd = convertBase(str2, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 1, str2 = "1."; i < len; i++) str2 += NUMERALS.charAt(xd[i]);
          } else {
            str2 = str2.charAt(0) + "." + str2.slice(1);
          }
        }
        str2 = str2 + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; ) str2 = "0" + str2;
        str2 = "0." + str2;
      } else {
        if (++e > len) for (e -= len; e--; ) str2 += "0";
        else if (e < len) str2 = str2.slice(0, e) + "." + str2.slice(e);
      }
    }
    str2 = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str2;
  }
  return x.s < 0 ? "-" + str2 : str2;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
function config(obj) {
  if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh(x) {
  return new this(x).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal3(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal3)) return new Decimal3(v);
    x.constructor = Decimal3;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal3.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal3.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
        if (external) {
          if (e > Decimal3.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal3.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      }
      if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    }
    if (t === "string") {
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43) v = v.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    if (t === "bigint") {
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      return parseDecimal(x, v.toString());
    }
    throw Error(invalidArgument + v);
  }
  Decimal3.prototype = P2;
  Decimal3.ROUND_UP = 0;
  Decimal3.ROUND_DOWN = 1;
  Decimal3.ROUND_CEIL = 2;
  Decimal3.ROUND_FLOOR = 3;
  Decimal3.ROUND_HALF_UP = 4;
  Decimal3.ROUND_HALF_DOWN = 5;
  Decimal3.ROUND_HALF_EVEN = 6;
  Decimal3.ROUND_HALF_CEIL = 7;
  Decimal3.ROUND_HALF_FLOOR = 8;
  Decimal3.EUCLID = 9;
  Decimal3.config = Decimal3.set = config;
  Decimal3.clone = clone;
  Decimal3.isDecimal = isDecimalInstance;
  Decimal3.abs = abs;
  Decimal3.acos = acos;
  Decimal3.acosh = acosh;
  Decimal3.add = add;
  Decimal3.asin = asin;
  Decimal3.asinh = asinh;
  Decimal3.atan = atan;
  Decimal3.atanh = atanh;
  Decimal3.atan2 = atan2;
  Decimal3.cbrt = cbrt;
  Decimal3.ceil = ceil;
  Decimal3.clamp = clamp;
  Decimal3.cos = cos;
  Decimal3.cosh = cosh;
  Decimal3.div = div;
  Decimal3.exp = exp;
  Decimal3.floor = floor;
  Decimal3.hypot = hypot;
  Decimal3.ln = ln;
  Decimal3.log = log;
  Decimal3.log10 = log10;
  Decimal3.log2 = log2;
  Decimal3.max = max;
  Decimal3.min = min;
  Decimal3.mod = mod;
  Decimal3.mul = mul;
  Decimal3.pow = pow;
  Decimal3.random = random;
  Decimal3.round = round2;
  Decimal3.sign = sign;
  Decimal3.sin = sin;
  Decimal3.sinh = sinh;
  Decimal3.sqrt = sqrt;
  Decimal3.sub = sub;
  Decimal3.sum = sum;
  Decimal3.tan = tan;
  Decimal3.tanh = tanh;
  Decimal3.trunc = trunc;
  if (obj === void 0) obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
  }
  Decimal3.config(obj);
  return Decimal3;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, -1);
}
function min() {
  return maxOrMin(this, arguments, 1);
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--) rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
    if (k < LOG_BASE) e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round2(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P2[Symbol.for("nodejs.util.inspect.custom")] = P2.toString;
P2[Symbol.toStringTag] = "Decimal";
var Decimal = P2.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default2 = Decimal;

// node_modules/@raydium-io/raydium-sdk/dist/index.mjs
var import_bn12 = __toESM(require_bn(), 1);
var import_bn13 = __toESM(require_bn(), 1);
var import_bn14 = __toESM(require_bn(), 1);
var import_bn15 = __toESM(require_bn(), 1);
var import_bn16 = __toESM(require_bn(), 1);
var import_bn17 = __toESM(require_bn(), 1);
var import_bn18 = __toESM(require_bn(), 1);
var import_bn19 = __toESM(require_bn(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool2(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
var assert = {
  number,
  bool: bool2,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert;
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str2) {
  if (typeof str2 !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str2}`);
  }
  return new TextEncoder().encode(str2);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());
var version = "1.1.0-beta.6";
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
var _moduleLogLevel = {};
var _globalLogger;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    if (error instanceof Error) {
      return error.message;
    }
  }
  return "";
}
var _normalizeError = _checkNormalize();
var LogLevel = ((LogLevel2) => {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
  return LogLevel2;
})(LogLevel || {});
var ErrorCode = ((ErrorCode2) => {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["RPC_ERROR"] = "RPC_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  return ErrorCode2;
})(ErrorCode || {});
var HEX = "0123456789abcdef";
function perfectDisplay(value, deeping = false) {
  let _value = value;
  try {
    if (value instanceof Uint8Array) {
      let hex = "";
      for (let i = 0; i < value.length; i++) {
        hex += HEX[value[i] >> 4];
        hex += HEX[value[i] & 15];
      }
      _value = `Uint8Array(0x${hex})`;
    } else if (value instanceof PublicKey) {
      _value = `PublicKey(${value.toBase58()})`;
    } else if (value instanceof Object && !deeping) {
      const obj = {};
      Object.entries(value).forEach(([k, v]) => {
        obj[k] = perfectDisplay(v, true);
      });
      _value = JSON.stringify(obj);
    } else if (!deeping) {
      _value = JSON.stringify(value);
    }
  } catch (error) {
    _value = JSON.stringify(value.toString());
  }
  return _value;
}
var _Logger = class _Logger2 {
  constructor(moduleName) {
    this.version = version;
    this.moduleName = moduleName;
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    const _logLevel = _moduleLogLevel[this.moduleName] || LogLevels["default"];
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log(...args);
  }
  debug(...args) {
    this._log(_Logger2.levels.DEBUG, ["[DEBUG]", ...args]);
  }
  info(...args) {
    this._log(_Logger2.levels.INFO, ["[INFO]", ...args]);
  }
  warn(...args) {
    this._log(_Logger2.levels.WARNING, ["[WARN]", ...args]);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = _Logger2.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.entries(params).forEach(([key, value]) => {
      messageDetails.push(`${key}=${perfectDisplay(value)})`);
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`module=${this.moduleName}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.entries(params).forEach(([key, value]) => {
      error[key] = value;
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, _Logger2.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", _Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, _Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, _Logger2.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, _Logger2.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, _Logger2.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", _Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError(
        "cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class",
        _Logger2.errors.UNSUPPORTED_OPERATION,
        { name: target.name, operation: "new" }
      );
    } else if (target === Object || target == null) {
      this.throwError("missing new", _Logger2.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new _Logger2(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", _Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", _Logger2.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(moduleName, logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      _Logger2.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _moduleLogLevel[moduleName] = level;
  }
  static from(version2) {
    return new _Logger2(version2);
  }
};
_Logger.errors = ErrorCode;
_Logger.levels = LogLevel;
var Logger = _Logger;
var logger = Logger.from("common/pubkey");
var SYSTEM_PROGRAM_ID = SystemProgram.programId;
var MEMO_PROGRAM_ID = new PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
var RENT_PROGRAM_ID = new PublicKey("SysvarRent111111111111111111111111111111111");
var METADATA_PROGRAM_ID = new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
var INSTRUCTION_PROGRAM_ID = new PublicKey("Sysvar1nstructions1111111111111111111111111");
function validateAndParsePublicKey(publicKey22) {
  if (publicKey22 instanceof PublicKey) {
    return publicKey22;
  }
  if (typeof publicKey22 === "string") {
    try {
      const key = new PublicKey(publicKey22);
      return key;
    } catch (e) {
      return logger.throwArgumentError("invalid public key", "publicKey", publicKey22);
    }
  }
  return logger.throwArgumentError("invalid public key", "publicKey", publicKey22);
}
function findProgramAddress(seeds, programId) {
  const [publicKey22, nonce] = PublicKey.findProgramAddressSync(seeds, programId);
  return { publicKey: publicKey22, nonce };
}
function AccountMeta(publicKey22, isSigner) {
  return {
    pubkey: publicKey22,
    isWritable: true,
    isSigner
  };
}
function AccountMetaReadonly(publicKey22, isSigner) {
  return {
    pubkey: publicKey22,
    isWritable: false,
    isSigner
  };
}
function notInnerObject(v) {
  return typeof v === "object" && v !== null && ![TokenAmount, PublicKey, Fraction, import_bn2.BN, Currency, CurrencyAmount, Price, Percent].some(
    (o) => typeof o === "object" && v instanceof o
  );
}
function jsonInfo2PoolKeys(jsonInfo) {
  return typeof jsonInfo === "string" ? validateAndParsePublicKey(jsonInfo) : Array.isArray(jsonInfo) ? jsonInfo.map((k) => jsonInfo2PoolKeys(k)) : notInnerObject(jsonInfo) ? Object.fromEntries(Object.entries(jsonInfo).map(([k, v]) => [k, jsonInfo2PoolKeys(v)])) : jsonInfo;
}
function poolKeys2JsonInfo(jsonInfo) {
  return jsonInfo instanceof PublicKey ? jsonInfo.toBase58() : Array.isArray(jsonInfo) ? jsonInfo.map((k) => poolKeys2JsonInfo(k)) : notInnerObject(jsonInfo) ? Object.fromEntries(Object.entries(jsonInfo).map(([k, v]) => [k, poolKeys2JsonInfo(v)])) : jsonInfo;
}
function inspectPublicKey() {
  PublicKey.prototype.inspect = function() {
    return `<PublicKey: ${this.toString()}>`;
  };
}
function inspectBN() {
  import_bn3.default.prototype.inspect = function() {
    return `<${this.red ? "BN-R" : "BN"}: ${this.toString()}>`;
  };
}
function inspectAll() {
  inspectPublicKey();
  inspectBN();
}
function chunkArray(arr, chunkSize = 1, cache = []) {
  const tmp = [...arr];
  if (chunkSize <= 0) return cache;
  while (tmp.length) cache.push(tmp.splice(0, chunkSize));
  return cache;
}
function intersection(arr, ...args) {
  return arr.filter((item) => args.every((arr2) => arr2.includes(item)));
}
function xor(arr, ...args) {
  return arr.filter((item) => args.every((arr2) => !arr2.includes(item)));
}
function uniq(arr) {
  return [...new Set(arr)];
}
function addComputeBudget(config2) {
  const ins = [];
  const insTypes = [];
  if (config2.microLamports) {
    ins.push(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: config2.microLamports }));
    insTypes.push(
      9
      /* setComputeUnitPrice */
    );
  }
  if (config2.units) {
    ins.push(ComputeBudgetProgram.setComputeUnitLimit({ units: config2.units }));
    insTypes.push(
      10
      /* setComputeUnitLimit */
    );
  }
  return {
    address: {},
    innerTransaction: {
      instructions: ins,
      signers: [],
      instructionTypes: insTypes
    }
  };
}
var logger2 = Logger.from("common/web3");
function getMultipleAccountsInfo(connection, publicKeys, config2) {
  return __async(this, null, function* () {
    const { batchRequest, commitment } = __spreadValues(__spreadValues({}, {
      batchRequest: false
    }), config2);
    const chunkedKeys = chunkArray(publicKeys, 100);
    let results = new Array(chunkedKeys.length).fill([]);
    if (batchRequest) {
      const batch = chunkedKeys.map((keys) => {
        const args = connection._buildArgs([keys.map((key) => key.toBase58())], commitment, "base64");
        return {
          methodName: "getMultipleAccounts",
          args
        };
      });
      const _batch = chunkArray(batch, 10);
      const unsafeResponse = yield (yield Promise.all(
        _batch.map(
          (i) => __async(this, null, function* () {
            return (
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore
              yield connection._rpcBatchRequest(i)
            );
          })
        )
      )).flat();
      results = unsafeResponse.map((unsafeRes) => {
        if (unsafeRes.error) {
          return logger2.throwError("failed to get info for multiple accounts", Logger.errors.RPC_ERROR, {
            message: unsafeRes.error.message
          });
        }
        return unsafeRes.result.value.map((accountInfo) => {
          if (accountInfo) {
            const { data, executable, lamports, owner, rentEpoch } = accountInfo;
            if (data.length !== 2 && data[1] !== "base64") {
              return logger2.throwError("info must be base64 encoded", Logger.errors.RPC_ERROR);
            }
            return {
              data: Buffer.from(data[0], "base64"),
              executable,
              lamports,
              owner: new PublicKey(owner),
              rentEpoch
            };
          } else {
            return null;
          }
        });
      });
    } else {
      try {
        results = yield Promise.all(
          chunkedKeys.map((keys) => connection.getMultipleAccountsInfo(keys, commitment))
        );
      } catch (error) {
        if (error instanceof Error) {
          return logger2.throwError("failed to get info for multiple accounts", Logger.errors.RPC_ERROR, {
            message: error.message
          });
        }
      }
    }
    return results.flat();
  });
}
function getMultipleAccountsInfoWithCustomFlags(connection, publicKeysWithCustomFlag, config2) {
  return __async(this, null, function* () {
    const multipleAccountsInfo = yield getMultipleAccountsInfo(
      connection,
      publicKeysWithCustomFlag.map((o) => o.pubkey),
      config2
    );
    return publicKeysWithCustomFlag.map((o, idx) => __spreadProps(__spreadValues({}, o), { accountInfo: multipleAccountsInfo[idx] }));
  });
}
function forecastTransactionSize(instructions, signers) {
  if (instructions.length < 1) {
    return logger2.throwArgumentError("no instructions provided", "instructions", instructions);
  }
  if (signers.length < 1) {
    return logger2.throwArgumentError("no signers provided", "signers", signers);
  }
  const transaction = new Transaction({
    recentBlockhash: "11111111111111111111111111111111",
    feePayer: signers[0]
  });
  transaction.add(...instructions);
  try {
    return Buffer.from(transaction.serialize({ verifySignatures: false })).toString("base64").length < MAX_BASE64_SIZE;
  } catch (error) {
    return false;
  }
}
function simulateMultipleInstruction(connection, instructions, keyword, batchRequest = true) {
  return __async(this, null, function* () {
    const feePayer = new PublicKey("RaydiumSimuLateTransaction11111111111111111");
    const transactions = [];
    let transaction = new Transaction();
    transaction.feePayer = feePayer;
    for (const instruction of instructions) {
      if (!forecastTransactionSize([...transaction.instructions, instruction], [feePayer])) {
        transactions.push(transaction);
        transaction = new Transaction();
        transaction.feePayer = feePayer;
      }
      transaction.add(instruction);
    }
    if (transaction.instructions.length > 0) {
      transactions.push(transaction);
    }
    let results = [];
    try {
      results = yield simulateTransaction(connection, transactions, batchRequest);
      if (results.find((i) => i.err !== null)) throw Error("rpc simulateTransaction error");
    } catch (error) {
      if (error instanceof Error) {
        return logger2.throwError("failed to simulate for instructions", Logger.errors.RPC_ERROR, {
          message: error.message
        });
      }
    }
    const logs = [];
    for (const result of results) {
      logger2.debug("simulate result:", result);
      if (result.logs) {
        const filteredLog = result.logs.filter((log3) => log3 && log3.includes(keyword));
        logger2.debug("filteredLog:", logs);
        logger2.assertArgument(filteredLog.length !== 0, "simulate log not match keyword", "keyword", keyword);
        logs.push(...filteredLog);
      }
    }
    return logs;
  });
}
function parseSimulateLogToJson(log3, keyword) {
  const results = log3.match(/{["\w:,]+}/g);
  if (!results || results.length !== 1) {
    return logger2.throwArgumentError("simulate log fail to match json", "keyword", keyword);
  }
  return results[0];
}
function parseSimulateValue(log3, key) {
  const reg = new RegExp(`"${key}":(\\d+)`, "g");
  const results = reg.exec(log3);
  if (!results || results.length !== 2) {
    return logger2.throwArgumentError("simulate log fail to match key", "key", key);
  }
  return results[1];
}
function simulateTransaction(connection, transactions, batchRequest) {
  return __async(this, null, function* () {
    let results = [];
    if (batchRequest) {
      const getLatestBlockhash = yield connection.getLatestBlockhash();
      const encodedTransactions = [];
      for (const transaction of transactions) {
        transaction.recentBlockhash = getLatestBlockhash.blockhash;
        transaction.lastValidBlockHeight = getLatestBlockhash.lastValidBlockHeight;
        const message = transaction._compile();
        const signData = message.serialize();
        const wireTransaction = transaction._serialize(signData);
        const encodedTransaction = wireTransaction.toString("base64");
        encodedTransactions.push(encodedTransaction);
      }
      const batch = encodedTransactions.map((keys) => {
        const args = connection._buildArgs([keys], void 0, "base64");
        return {
          methodName: "simulateTransaction",
          args
        };
      });
      const reqData = [];
      const itemReqIndex = 20;
      for (let i = 0; i < Math.ceil(batch.length / itemReqIndex); i++) {
        reqData.push(batch.slice(i * itemReqIndex, (i + 1) * itemReqIndex));
      }
      results = yield (yield Promise.all(
        reqData.map((i) => __async(this, null, function* () {
          const d = yield connection._rpcBatchRequest(i);
          return d.map((ii) => ii.result.value);
        }))
      )).flat();
    } else {
      try {
        results = yield Promise.all(
          transactions.map((transaction) => __async(this, null, function* () {
            return yield (yield connection.simulateTransaction(transaction)).value;
          }))
        );
      } catch (error) {
        if (error instanceof Error) {
          return logger2.throwError("failed to get info for multiple accounts", Logger.errors.RPC_ERROR, {
            message: error.message
          });
        }
      }
    }
    return results;
  });
}
function splitTxAndSigners(_0) {
  return __async(this, arguments, function* ({
    connection,
    makeTxVersion,
    innerTransaction,
    lookupTableCache,
    computeBudgetConfig,
    payer
  }) {
    const lookupTableAddressAccount = lookupTableCache != null ? lookupTableCache : {};
    const allLTA = [
      ...new Set(innerTransaction.map((i) => {
        var _a;
        return ((_a = i.lookupTableAddress) != null ? _a : []).map((ii) => ii.toString());
      }).flat())
    ];
    const needCacheLTA = [];
    for (const item of allLTA) {
      if (lookupTableAddressAccount[item] === void 0) needCacheLTA.push(new PublicKey(item));
    }
    const newCacheLTA = yield getMultipleLookupTableInfo({ connection, address: needCacheLTA });
    for (const [key, value] of Object.entries(newCacheLTA)) lookupTableAddressAccount[key] = value;
    const addComputeBudgetInnerTx = computeBudgetConfig ? addComputeBudget(computeBudgetConfig).innerTransaction : void 0;
    const transactions = [];
    let itemIns = [];
    for (const itemInnerTx of innerTransaction) {
      if (itemInnerTx.instructions.length === 0) continue;
      const _itemIns = [...itemIns, itemInnerTx];
      const _addComputeBudgetInnerTx = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ..._itemIns] : _itemIns;
      if (itemIns.length < 12 && (checkTx({ makeTxVersion, innerIns: _addComputeBudgetInnerTx, payer, lookupTableAddressAccount }) || checkTx({ makeTxVersion, innerIns: _itemIns, payer, lookupTableAddressAccount }))) {
        itemIns.push(itemInnerTx);
      } else {
        if (itemIns.length === 0) throw Error(" item ins too big ");
        let lookupTableAddress = void 0;
        if (makeTxVersion === 0) {
          lookupTableAddress = {};
          for (const item of [
            ...new Set(
              itemIns.map((i) => {
                var _a;
                return (_a = i.lookupTableAddress) != null ? _a : [];
              }).flat().map((i) => i.toString())
            )
          ]) {
            if (lookupTableAddressAccount[item] !== void 0) lookupTableAddress[item] = lookupTableAddressAccount[item];
          }
        }
        if (checkTx({
          makeTxVersion,
          innerIns: addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns,
          payer,
          lookupTableAddressAccount
        })) {
          const _i = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns;
          transactions.push({
            instructionTypes: _i.map((i) => i.instructionTypes).flat(),
            instructions: _i.map((i) => i.instructions).flat(),
            signers: itemIns.map((i) => i.signers).flat(),
            lookupTableAddress
          });
        } else {
          transactions.push({
            instructionTypes: itemIns.map((i) => i.instructionTypes).flat(),
            instructions: itemIns.map((i) => i.instructions).flat(),
            signers: itemIns.map((i) => i.signers).flat(),
            lookupTableAddress
          });
        }
        itemIns = [itemInnerTx];
      }
    }
    if (itemIns.length > 0) {
      let lookupTableAddress = void 0;
      if (makeTxVersion === 0) {
        lookupTableAddress = {};
        for (const item of [
          ...new Set(
            itemIns.map((i) => {
              var _a;
              return (_a = i.lookupTableAddress) != null ? _a : [];
            }).flat().map((i) => i.toString())
          )
        ]) {
          if (lookupTableAddressAccount[item] !== void 0) lookupTableAddress[item] = lookupTableAddressAccount[item];
        }
      }
      if (checkTx({
        makeTxVersion,
        innerIns: addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns,
        payer,
        lookupTableAddressAccount
      })) {
        const _i = addComputeBudgetInnerTx ? [addComputeBudgetInnerTx, ...itemIns] : itemIns;
        transactions.push({
          instructionTypes: _i.map((i) => i.instructionTypes).flat(),
          instructions: _i.map((i) => i.instructions).flat(),
          signers: itemIns.map((i) => i.signers).flat(),
          lookupTableAddress
        });
      } else {
        transactions.push({
          instructionTypes: itemIns.map((i) => i.instructionTypes).flat(),
          instructions: itemIns.map((i) => i.instructions).flat(),
          signers: itemIns.map((i) => i.signers).flat(),
          lookupTableAddress
        });
      }
    }
    return transactions;
  });
}
function checkTx({
  makeTxVersion,
  innerIns,
  payer,
  lookupTableAddressAccount
}) {
  const instructions = innerIns.map((i) => i.instructions).flat();
  const signers = [
    ...new Set(
      innerIns.map((i) => i.signers).flat().map((i) => i.publicKey.toString())
    )
  ].map((i) => new PublicKey(i));
  const needLTA = innerIns.map((i) => {
    var _a;
    return (_a = i.lookupTableAddress) != null ? _a : [];
  }).flat().map((i) => i.toString());
  const lTaCache = {};
  const _lookupTableAddressAccount = lookupTableAddressAccount != null ? lookupTableAddressAccount : {};
  for (const item of needLTA) {
    if (_lookupTableAddressAccount[item] !== void 0) {
      lTaCache[item] = _lookupTableAddressAccount[item];
    }
  }
  return makeTxVersion === 0 ? _checkV0Tx({ instructions, payer, lookupTableAddressAccount: lTaCache }) : _checkLegacyTx({ instructions, payer, signers });
}
var MAX_BASE64_SIZE = 1644;
function _checkLegacyTx({
  instructions,
  payer,
  signers
}) {
  return forecastTransactionSize(instructions, [payer, ...signers]);
}
function _checkV0Tx({
  instructions,
  payer,
  lookupTableAddressAccount
}) {
  const transactionMessage = new TransactionMessage({
    payerKey: payer,
    recentBlockhash: Keypair.generate().publicKey.toString(),
    instructions
  });
  const messageV0 = transactionMessage.compileToV0Message(Object.values(lookupTableAddressAccount != null ? lookupTableAddressAccount : {}));
  try {
    return Buffer.from(messageV0.serialize()).toString("base64").length < MAX_BASE64_SIZE;
  } catch (error) {
    return false;
  }
}
function getMultipleLookupTableInfo(_0) {
  return __async(this, arguments, function* ({
    connection,
    address
  }) {
    const dataInfos = yield getMultipleAccountsInfo(
      connection,
      [...new Set(address.map((i) => i.toString()))].map((i) => new PublicKey(i))
    );
    const outDict = {};
    for (let i = 0; i < address.length; i++) {
      const info = dataInfos[i];
      const key = address[i];
      if (!info) continue;
      outDict[key.toString()] = new AddressLookupTableAccount({
        key,
        state: AddressLookupTableAccount.deserialize(info.data)
      });
    }
    return outDict;
  });
}
var Rounding = ((Rounding3) => {
  Rounding3[Rounding3["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding3[Rounding3["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding3[Rounding3["ROUND_UP"] = 2] = "ROUND_UP";
  return Rounding3;
})(Rounding || {});
var ZERO = new import_bn5.default(0);
var ONE = new import_bn5.default(1);
var TWO = new import_bn5.default(2);
var THREE = new import_bn5.default(3);
var FIVE = new import_bn5.default(5);
var TEN = new import_bn5.default(10);
var _100 = new import_bn5.default(100);
var _1000 = new import_bn5.default(1e3);
var _10000 = new import_bn5.default(1e4);
var logger3 = Logger.from("entity/bignumber");
var MAX_SAFE = 9007199254740991;
function parseBigNumberish(value) {
  if (value instanceof import_bn4.default) {
    return value;
  }
  if (typeof value === "string") {
    if (value.match(/^-?[0-9]+$/)) {
      return new import_bn4.default(value);
    }
    return logger3.throwArgumentError("invalid BigNumberish string", "value", value);
  }
  if (typeof value === "number") {
    if (value % 1) {
      return logger3.throwArgumentError("BigNumberish number underflow", "value", value);
    }
    if (value >= MAX_SAFE || value <= -MAX_SAFE) {
      return logger3.throwArgumentError("BigNumberish number overflow", "value", value);
    }
    return new import_bn4.default(String(value));
  }
  if (typeof value === "bigint") {
    return new import_bn4.default(value.toString());
  }
  return logger3.throwArgumentError("invalid BigNumberish value", "value", value);
}
function tenExponentiate(shift) {
  return TEN.pow(parseBigNumberish(shift));
}
function divCeil(a, b) {
  const dm = a.divmod(b);
  if (dm.mod.isZero()) return dm.div;
  return dm.div.isNeg() ? dm.div.isubn(1) : dm.div.iaddn(1);
}
var SOL = {
  symbol: "SOL",
  name: "Solana",
  decimals: 9
};
var WSOL = {
  symbol: "WSOL",
  name: "Wrapped SOL",
  mint: "So11111111111111111111111111111111111111112",
  decimals: 9,
  extensions: {
    coingeckoId: "solana"
  }
};
var DEVNET_SPL_TOKENS = {
  WSOL: __spreadValues({}, WSOL)
};
var DEVNET_LP_TOKENS = {};
var MAINNET_SPL_TOKENS = {
  WSOL: __spreadValues({}, WSOL),
  BTC: {
    symbol: "BTC",
    name: "Bitcoin",
    mint: "9n4nbM75f5Ui33ZbPYXn59EwSgE8CGsHtAeTH5YFeJ9E",
    decimals: 6,
    extensions: {
      coingeckoId: "bitcoin"
    }
  },
  ETH: {
    symbol: "ETH",
    name: "Ethereum",
    mint: "2FPyTwcZLUg1MDrwsyoP4D6s1tM7hAkHYRjkNb5w6Pxk",
    decimals: 6,
    extensions: {
      coingeckoId: "ethereum"
    }
  },
  USDT: {
    symbol: "USDT",
    name: "Tether",
    mint: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
    decimals: 6,
    extensions: {
      coingeckoId: "tether"
    }
  },
  WUSDT: {
    symbol: "WUSDT",
    name: "Wrapped USDT",
    mint: "BQcdHdAQW1hczDbBi9hiegXAR7A98Q9jx3X3iBBBDiq4",
    decimals: 6,
    extensions: {
      coingeckoId: "tether"
    }
  },
  USDC: {
    symbol: "USDC",
    name: "USD Coin",
    mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    decimals: 6,
    extensions: {
      coingeckoId: "usd-coin"
    }
  },
  WUSDC: {
    symbol: "WUSDC",
    name: "Wrapped USDC",
    mint: "BXXkv6z8ykpG1yuvUDPgh732wzVHB69RnB9YgSYh3itW",
    decimals: 6,
    extensions: {
      coingeckoId: "usd-coin"
    }
  },
  YFI: {
    symbol: "YFI",
    name: "YFI",
    mint: "3JSf5tPeuscJGtaCp5giEiDhv51gQ4v3zWg8DGgyLfAB",
    decimals: 6,
    extensions: {
      coingeckoId: "yearn-finance"
    }
  },
  LINK: {
    symbol: "LINK",
    name: "Chainlink",
    mint: "CWE8jPTUYhdCTZYWPTe1o5DFqfdjzWKc9WKz6rSjQUdG",
    decimals: 6,
    extensions: {
      coingeckoId: "chainlink"
    }
  },
  XRP: {
    symbol: "XRP",
    name: "XRP",
    mint: "Ga2AXHpfAF6mv2ekZwcsJFqu7wB4NV331qNH7fW9Nst8",
    decimals: 6,
    extensions: {
      coingeckoId: "ripple"
    }
  },
  SUSHI: {
    symbol: "SUSHI",
    name: "SUSHI",
    mint: "AR1Mtgh7zAtxuxGd2XPovXPVjcSdY3i4rQYisNadjfKy",
    decimals: 6,
    extensions: {
      coingeckoId: "sushi"
    }
  },
  ALEPH: {
    symbol: "ALEPH",
    name: "ALEPH",
    mint: "CsZ5LZkDS7h9TDKjrbL7VAwQZ9nsRu8vJLhRYfmGaN8K",
    decimals: 6,
    extensions: {
      coingeckoId: "aleph"
    }
  },
  SXP: {
    symbol: "SXP",
    name: "SXP",
    mint: "SF3oTvfWzEP3DTwGSvUXRrGTvr75pdZNnBLAH9bzMuX",
    decimals: 6,
    extensions: {
      coingeckoId: "swipe"
    }
  },
  HGET: {
    symbol: "HGET",
    name: "HGET",
    mint: "BtZQfWqDGbk9Wf2rXEiWyQBdBY1etnUUn6zEphvVS7yN",
    decimals: 6,
    extensions: {
      coingeckoId: "hedget"
    }
  },
  CREAM: {
    symbol: "CREAM",
    name: "CREAM",
    mint: "5Fu5UUgbjpUvdBveb3a1JTNirL8rXtiYeSMWvKjtUNQv",
    decimals: 6,
    extensions: {
      coingeckoId: "cream-2"
    }
  },
  UNI: {
    symbol: "UNI",
    name: "UNI",
    mint: "DEhAasscXF4kEGxFgJ3bq4PpVGp5wyUxMRvn6TzGVHaw",
    decimals: 6,
    extensions: {
      coingeckoId: "uniswap"
    }
  },
  SRM: {
    symbol: "SRM",
    name: "Serum",
    mint: "SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt",
    decimals: 6,
    extensions: {
      coingeckoId: "serum"
    }
  },
  FTT: {
    symbol: "FTT",
    name: "FTX Token",
    mint: "AGFEad2et2ZJif9jaGpdMixQqvW5i81aBdvKe7PHNfz3",
    decimals: 6,
    extensions: {
      coingeckoId: "ftx-token"
    }
  },
  MSRM: {
    symbol: "MSRM",
    name: "MegaSerum",
    mint: "MSRMcoVyrFxnSgo5uXwone5SKcGhT1KEJMFEkMEWf9L",
    decimals: 0,
    extensions: {
      coingeckoId: "megaserum"
    }
  },
  TOMO: {
    symbol: "TOMO",
    name: "TOMO",
    mint: "GXMvfY2jpQctDqZ9RoU3oWPhufKiCcFEfchvYumtX7jd",
    decimals: 6,
    extensions: {
      coingeckoId: "tomochain"
    }
  },
  KARMA: {
    symbol: "KARMA",
    name: "KARMA",
    mint: "EcqExpGNFBve2i1cMJUTR4bPXj4ZoqmDD2rTkeCcaTFX",
    decimals: 4,
    extensions: {
      coingeckoId: "karma-dao"
    }
  },
  LUA: {
    symbol: "LUA",
    name: "LUA",
    mint: "EqWCKXfs3x47uVosDpTRgFniThL9Y8iCztJaapxbEaVX",
    decimals: 6,
    extensions: {
      coingeckoId: "lua-token"
    }
  },
  MATH: {
    symbol: "MATH",
    name: "MATH",
    mint: "GeDS162t9yGJuLEHPWXXGrb1zwkzinCgRwnT8vHYjKza",
    decimals: 6,
    extensions: {
      coingeckoId: "math"
    }
  },
  KEEP: {
    symbol: "KEEP",
    name: "KEEP",
    mint: "GUohe4DJUA5FKPWo3joiPgsB7yzer7LpDmt1Vhzy3Zht",
    decimals: 6,
    extensions: {
      coingeckoId: "keep-network"
    }
  },
  SWAG: {
    symbol: "SWAG",
    name: "SWAG",
    mint: "9F9fNTT6qwjsu4X4yWYKZpsbw5qT7o6yR2i57JF2jagy",
    decimals: 6,
    extensions: {
      coingeckoId: "swag-finance"
    }
  },
  FIDA: {
    symbol: "FIDA",
    name: "Bonfida",
    mint: "EchesyfXePKdLtoiZSL8pBe8Myagyy8ZRqsACNCFGnvp",
    decimals: 6,
    extensions: {
      coingeckoId: "bonfida"
    }
  },
  KIN: {
    symbol: "KIN",
    name: "Kin",
    mint: "kinXdEcpDQeHPEuQnqmUgtYykqKGVFq6CeVX5iAHJq6",
    decimals: 5,
    extensions: {
      coingeckoId: "kin"
    }
  },
  MAPS: {
    symbol: "MAPS",
    name: "MAPS",
    mint: "MAPS41MDahZ9QdKXhVa4dWB9RuyfV4XqhyAZ8XcYepb",
    decimals: 6,
    extensions: {
      coingeckoId: "maps"
    }
  },
  OXY: {
    symbol: "OXY",
    name: "Oxygen",
    mint: "z3dn17yLaGMKffVogeFHQ9zWVcXgqgf3PQnDsNs2g6M",
    decimals: 6,
    extensions: {
      coingeckoId: "oxygen"
    }
  },
  RAY: {
    symbol: "RAY",
    name: "Raydium",
    mint: "4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R",
    decimals: 6,
    extensions: {
      coingeckoId: "raydium"
    }
  },
  xCOPE: {
    symbol: "xCOPE",
    name: "xCOPE",
    mint: "3K6rftdAaQYMPunrtNRHgnK2UAtjm2JwyT2oCiTDouYE",
    decimals: 0,
    extensions: {
      coingeckoId: "cope"
    }
  },
  COPE: {
    symbol: "COPE",
    name: "Cope",
    mint: "8HGyAAB1yoM1ttS7pXjHMa3dukTFGQggnFFH3hJZgzQh",
    decimals: 6,
    extensions: {
      coingeckoId: "cope"
    }
  },
  STEP: {
    symbol: "STEP",
    name: "Step Finance",
    mint: "StepAscQoEioFxxWGnh2sLBDFp9d8rvKz2Yp39iDpyT",
    decimals: 9,
    extensions: {
      coingeckoId: "step-finance"
    }
  },
  MEDIA: {
    symbol: "MEDIA",
    name: "Media Network",
    mint: "ETAtLmCmsoiEEKfNrHKJ2kYy3MoABhU6NQvpSfij5tDs",
    decimals: 6,
    extensions: {
      coingeckoId: "media-network"
    }
  },
  ROPE: {
    symbol: "ROPE",
    name: "Rope Token",
    mint: "8PMHT4swUMtBzgHnh5U564N5sjPSiUz2cjEQzFnnP1Fo",
    decimals: 9,
    extensions: {
      coingeckoId: "rope-token"
    }
  },
  MER: {
    symbol: "MER",
    name: "Mercurial",
    mint: "MERt85fc5boKw3BW1eYdxonEuJNvXbiMbs6hvheau5K",
    decimals: 6,
    extensions: {
      coingeckoId: "mercurial"
    }
  },
  TULIP: {
    symbol: "TULIP",
    name: "Tulip Protocol",
    mint: "TuLipcqtGVXP9XR62wM8WWCm6a9vhLs7T1uoWBk6FDs",
    decimals: 6,
    extensions: {
      coingeckoId: "solfarm"
    }
  },
  SNY: {
    symbol: "SNY",
    name: "SNY",
    mint: "4dmKkXNHdgYsXqBHCuMikNQWwVomZURhYvkkX5c4pQ7y",
    decimals: 6,
    extensions: {
      coingeckoId: "synthetify-token"
    }
  },
  SLRS: {
    symbol: "SLRS",
    name: "SLRS",
    mint: "SLRSSpSLUTP7okbCUBYStWCo1vUgyt775faPqz8HUMr",
    decimals: 6,
    extensions: {
      coingeckoId: "solrise-finance"
    }
  },
  WOO: {
    symbol: "WOO",
    name: "WOO Network",
    mint: "E5rk3nmgLUuKUiS94gg4bpWwWwyjCMtddsAXkTFLtHEy",
    decimals: 6,
    extensions: {
      coingeckoId: "woo-network"
    }
  },
  BOP: {
    symbol: "BOP",
    name: "Boring Protocol",
    mint: "BLwTnYKqf7u4qjgZrrsKeNs2EzWkMLqVCu6j8iHyrNA3",
    decimals: 8,
    extensions: {
      coingeckoId: "boring-protocol"
    }
  },
  SAMO: {
    symbol: "SAMO",
    name: "Samoyedcoin",
    mint: "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU",
    decimals: 9,
    extensions: {
      coingeckoId: "samoyedcoin"
    }
  },
  renBTC: {
    symbol: "renBTC",
    name: "renBTC",
    mint: "CDJWUqTcYTVAKXAVXoQZFes5JUFc7owSeq7eMQcDSbo5",
    decimals: 8,
    extensions: {
      coingeckoId: "renbtc"
    }
  },
  renDOGE: {
    symbol: "renDOGE",
    name: "renDOGE",
    mint: "ArUkYE2XDKzqy77PRRGjo4wREWwqk6RXTfM9NeqzPvjU",
    decimals: 8,
    extensions: {
      coingeckoId: "rendoge"
    }
  },
  LIKE: {
    symbol: "LIKE",
    name: "Only1",
    mint: "3bRTivrVsitbmCTGtqwp7hxXPsybkjn4XLNtPsHqa3zR",
    decimals: 9,
    extensions: {
      coingeckoId: "only1"
    }
  },
  DXL: {
    symbol: "DXL",
    name: "Dexlab",
    mint: "GsNzxJfFn6zQdJGeYsupJWzUAm57Ba7335mfhWvFiE9Z",
    decimals: 6,
    extensions: {
      coingeckoId: "dexlab"
    }
  },
  mSOL: {
    symbol: "mSOL",
    name: "Marinade staked SOL",
    mint: "mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So",
    decimals: 9,
    extensions: {
      coingeckoId: "msol"
    }
  },
  PAI: {
    symbol: "PAI",
    name: "Parrot USD",
    mint: "Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS",
    decimals: 6,
    extensions: {
      coingeckoId: "parrot-usd"
    }
  },
  PORT: {
    symbol: "PORT",
    name: "Port Finance",
    mint: "PoRTjZMPXb9T7dyU7tpLEZRQj7e6ssfAE62j2oQuc6y",
    decimals: 6,
    extensions: {
      coingeckoId: "port-finance"
    }
  },
  MNGO: {
    symbol: "MNGO",
    name: "Mango",
    mint: "MangoCzJ36AjZyKwVj3VnYU4GTonjfVEnJmvvWaxLac",
    decimals: 6,
    extensions: {
      coingeckoId: "mango-markets"
    }
  },
  CRP: {
    symbol: "CRP",
    name: "CropperFinance",
    mint: "DubwWZNWiNGMMeeQHPnMATNj77YZPZSAz2WVR5WjLJqz",
    decimals: 9,
    extensions: {
      coingeckoId: "cropperfinance"
    }
  },
  ATLAS: {
    symbol: "ATLAS",
    name: "Star Atlas",
    mint: "ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx",
    decimals: 8,
    extensions: {
      coingeckoId: "star-atlas"
    }
  },
  POLIS: {
    symbol: "POLIS",
    name: "Star Atlas DAO",
    mint: "poLisWXnNRwC6oBu1vHiuKQzFjGL4XDSu4g9qjz9qVk",
    decimals: 8,
    extensions: {
      coingeckoId: "star-atlas-dao"
    }
  },
  GRAPE: {
    symbol: "GRAPE",
    name: "Grape Protocol",
    mint: "8upjSpvjcdpuzhfR1zriwg5NXkwDruejqNE9WNbPRtyA",
    decimals: 6,
    extensions: {
      coingeckoId: "grape-2"
    }
  },
  GENE: {
    symbol: "GENE",
    name: "Genopets",
    mint: "GENEtH5amGSi8kHAtQoezp1XEXwZJ8vcuePYnXdKrMYz",
    decimals: 9,
    extensions: {
      coingeckoId: "genopets"
    }
  },
  DFL: {
    symbol: "DFL",
    name: "DeFi Land",
    mint: "DFL1zNkaGPWm1BqAVqRjCZvHmwTFrEaJtbzJWgseoNJh",
    decimals: 9,
    extensions: {
      coingeckoId: "defi-land"
    }
  },
  CHEEMS: {
    symbol: "CHEEMS",
    name: "Cheems",
    mint: "3FoUAsGDbvTD6YZ4wVKJgTB76onJUKz7GPEBNiR5b8wc",
    decimals: 4,
    extensions: {
      coingeckoId: "cheems"
    }
  },
  stSOL: {
    symbol: "stSOL",
    name: "Lido Staked SOL",
    mint: "7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj",
    decimals: 9,
    extensions: {
      coingeckoId: "lido-staked-sol"
    }
  },
  LARIX: {
    symbol: "LARIX",
    name: "Larix",
    mint: "Lrxqnh6ZHKbGy3dcrCED43nsoLkM1LTzU2jRfWe8qUC",
    decimals: 6,
    extensions: {
      coingeckoId: "larix"
    }
  },
  RIN: {
    symbol: "RIN",
    name: "Aldrin",
    mint: "E5ndSkaB17Dm7CsD22dvcjfrYSDLCxFcMd6z8ddCk5wp",
    decimals: 9,
    extensions: {
      coingeckoId: "aldrin"
    }
  },
  APEX: {
    symbol: "APEX",
    name: "ApeXit Finance",
    mint: "51tMb3zBKDiQhNwGqpgwbavaGH54mk8fXFzxTc1xnasg",
    decimals: 9,
    extensions: {
      coingeckoId: "apexit-finance"
    }
  },
  MNDE: {
    symbol: "MNDE",
    name: "Marinade",
    mint: "MNDEFzGvMt87ueuHvVU9VcTqsAP5b3fTGPsHuuPA5ey",
    decimals: 9,
    extensions: {
      coingeckoId: "marinade"
    }
  },
  LIQ: {
    symbol: "LIQ",
    name: "LIQ Protocol",
    mint: "4wjPQJ6PrkC4dHhYghwJzGBVP78DkBzA2U3kHoFNBuhj",
    decimals: 6,
    extensions: {
      coingeckoId: "liq-protocol"
    }
  },
  WAG: {
    symbol: "WAG",
    name: "Waggle Network",
    mint: "5tN42n9vMi6ubp67Uy4NnmM5DMZYN8aS8GeB3bEDHr6E",
    decimals: 9,
    extensions: {
      coingeckoId: "waggle-network"
    }
  },
  wLDO: {
    symbol: "wLDO",
    name: "wLDO",
    mint: "HZRCwxP2Vq9PCpPXooayhJ2bxTpo5xfpQrwB1svh332p",
    decimals: 8,
    extensions: {}
  },
  SLIM: {
    symbol: "SLIM",
    name: "Solanium",
    mint: "xxxxa1sKNGwFtw2kFn8XauW9xq8hBZ5kVtcSesTT9fW",
    decimals: 6,
    extensions: {
      coingeckoId: "solanium"
    }
  },
  PRT: {
    symbol: "PRT",
    name: "Parrot Protocol",
    mint: "PRT88RkA4Kg5z7pKnezeNH4mafTvtQdfFgpQTGRjz44",
    decimals: 6,
    extensions: {
      coingeckoId: "parrot-protocol"
    }
  },
  SBR: {
    symbol: "SBR",
    name: "SBR",
    mint: "Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1",
    decimals: 6,
    extensions: {}
  },
  FAB: {
    symbol: "FAB",
    name: "Fabric",
    mint: "EdAhkbj5nF9sRM7XN7ewuW8C9XEUMs8P7cnoQ57SYE96",
    decimals: 9,
    extensions: {
      coingeckoId: "fabric"
    }
  },
  ABR: {
    symbol: "ABR",
    name: "Allbridge",
    mint: "a11bdAAuV8iB2fu7X6AxAvDTo1QZ8FXB3kk5eecdasp",
    decimals: 9,
    extensions: {
      coingeckoId: "allbridge"
    }
  },
  IVN: {
    symbol: "IVN",
    name: "Investin",
    mint: "iVNcrNE9BRZBC9Aqf753iZiZfbszeAVUoikgT9yvr2a",
    decimals: 6,
    extensions: {
      coingeckoId: "investin"
    }
  },
  CYS: {
    symbol: "CYS",
    name: "Cyclos",
    mint: "BRLsMczKuaR5w9vSubF4j8HwEGGprVAyyVgS4EX7DKEg",
    decimals: 6,
    extensions: {
      coingeckoId: "cyclos"
    }
  },
  FRKT: {
    symbol: "FRKT",
    name: "FRAKT Token",
    mint: "ErGB9xa24Szxbk1M28u2Tx8rKPqzL6BroNkkzk5rG4zj",
    decimals: 8,
    extensions: {
      coingeckoId: "frakt-token"
    }
  },
  AURY: {
    symbol: "AURY",
    name: "Aurory",
    mint: "AURYydfxJib1ZkTir1Jn1J9ECYUtjb6rKQVmtYaixWPP",
    decimals: 9,
    extensions: {
      coingeckoId: "aurory"
    }
  },
  SYP: {
    symbol: "SYP",
    name: "Sypool",
    mint: "FnKE9n6aGjQoNWRBZXy4RW6LZVao7qwBonUbiD7edUmZ",
    decimals: 9,
    extensions: {
      coingeckoId: "sypool"
    }
  },
  WOOF: {
    symbol: "WOOF",
    name: "WOOF",
    mint: "9nEqaUcb16sQ3Tn1psbkWqyhPdLmfHWjKGymREjsAgTE",
    decimals: 6,
    extensions: {
      coingeckoId: "woof-token"
    }
  },
  ORCA: {
    symbol: "ORCA",
    name: "Orca",
    mint: "orcaEKTdK7LKz57vaAYr9QeNsVEPfiu6QeMU1kektZE",
    decimals: 6,
    extensions: {
      coingeckoId: "orca"
    }
  },
  SLND: {
    symbol: "SLND",
    name: "Solend",
    mint: "SLNDpmoWTVADgEdndyvWzroNL7zSi1dF9PC3xHGtPwp",
    decimals: 6,
    extensions: {
      coingeckoId: "solend"
    }
  },
  weWETH: {
    symbol: "weWETH",
    name: "weWETH",
    mint: "7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs",
    decimals: 8,
    extensions: {}
  },
  weUNI: {
    symbol: "weUNI",
    name: "weUNI",
    mint: "8FU95xFJhUUkyyCLU13HSzDLs7oC4QZdXQHL6SCeab36",
    decimals: 8,
    extensions: {}
  },
  weSUSHI: {
    symbol: "weSUSHI",
    name: "weSUSHI",
    mint: "ChVzxWRmrTeSgwd3Ui3UumcN8KX7VK3WaD4KGeSKpypj",
    decimals: 8,
    extensions: {}
  },
  GOFX: {
    symbol: "GOFX",
    name: "GooseFX",
    mint: "GFX1ZjR2P15tmrSwow6FjyDYcEkoFb4p4gJCpLBjaxHD",
    decimals: 9,
    extensions: {
      coingeckoId: "goosefx"
    }
  },
  IN: {
    symbol: "IN",
    name: "Invictus",
    mint: "inL8PMVd6iiW3RCBJnr5AsrRN6nqr4BTrcNuQWQSkvY",
    decimals: 9,
    extensions: {
      coingeckoId: "invictus"
    }
  },
  weDYDX: {
    symbol: "weDYDX",
    name: "weDYDX",
    mint: "4Hx6Bj56eGyw8EJrrheM6LBQAvVYRikYCWsALeTrwyRU",
    decimals: 8,
    extensions: {}
  },
  STARS: {
    symbol: "STARS",
    name: "StarLaunch",
    mint: "HCgybxq5Upy8Mccihrp7EsmwwFqYZtrHrsmsKwtGXLgW",
    decimals: 6,
    extensions: {
      coingeckoId: "starlaunch"
    }
  },
  weAXS: {
    symbol: "weAXS",
    name: "weAXS",
    mint: "HysWcbHiYY9888pHbaqhwLYZQeZrcQMXKQWRqS7zcPK5",
    decimals: 8,
    extensions: {}
  },
  weSHIB: {
    symbol: "weSHIB",
    name: "weSHIB",
    mint: "CiKu4eHsVrc1eueVQeHn7qhXTcVu95gSQmBpX4utjL9z",
    decimals: 8,
    extensions: {}
  },
  OXS: {
    symbol: "OXS",
    name: "Oxbull Solana",
    mint: "4TGxgCSJQx2GQk9oHZ8dC5m3JNXTYZHjXumKAW3vLnNx",
    decimals: 9,
    extensions: {
      coingeckoId: "oxbull-solana"
    }
  },
  CWAR: {
    symbol: "CWAR",
    name: "Cryowar",
    mint: "HfYFjMKNZygfMC8LsQ8LtpPsPxEJoXJx4M6tqi75Hajo",
    decimals: 9,
    extensions: {
      coingeckoId: "cryowar-token"
    }
  },
  UPS: {
    symbol: "UPS",
    name: "UPFI Network",
    mint: "EwJN2GqUGXXzYmoAciwuABtorHczTA5LqbukKXV1viH7",
    decimals: 6,
    extensions: {
      coingeckoId: "upfi-network"
    }
  },
  weSAND: {
    symbol: "weSAND",
    name: "weSAND",
    mint: "49c7WuCZkQgc3M4qH8WuEUNXfgwupZf1xqWkDQ7gjRGt",
    decimals: 8,
    extensions: {}
  },
  weMANA: {
    symbol: "weMANA",
    name: "weMANA",
    mint: "7dgHoN8wBZCc5wbnQ2C47TDnBMAxG4Q5L3KjP67z8kNi",
    decimals: 8,
    extensions: {}
  },
  CAVE: {
    symbol: "CAVE",
    name: "Crypto Cavemen",
    mint: "4SZjjNABoqhbd4hnapbvoEPEqT8mnNkfbEoAwALf1V8t",
    decimals: 6,
    extensions: {
      coingeckoId: "cave"
    }
  },
  JSOL: {
    symbol: "JSOL",
    name: "JPool",
    mint: "7Q2afV64in6N6SeZsAAB81TJzwDoD6zpqmHkzi9Dcavn",
    decimals: 9,
    extensions: {
      coingeckoId: "jpool"
    }
  },
  APT: {
    symbol: "APT",
    name: "Apricot",
    mint: "APTtJyaRX5yGTsJU522N4VYWg3vCvSb65eam5GrPT5Rt",
    decimals: 6,
    extensions: {
      coingeckoId: "apricot"
    }
  },
  SONAR: {
    symbol: "SONAR",
    name: "SonarWatch",
    mint: "sonarX4VtVkQemriJeLm6CKeW3GDMyiBnnAEMw1MRAE",
    decimals: 9,
    extensions: {
      coingeckoId: "sonarwatch"
    }
  },
  SHILL: {
    symbol: "SHILL",
    name: "SHILL Token",
    mint: "6cVgJUqo4nmvQpbgrDZwyfd6RwWw5bfnCamS3M9N1fd",
    decimals: 6,
    extensions: {
      coingeckoId: "shill-token"
    }
  },
  TTT: {
    symbol: "TTT",
    name: "TabTrader",
    mint: "FNFKRV3V8DtA3gVJN6UshMiLGYA8izxFwkNWmJbFjmRj",
    decimals: 6,
    extensions: {
      coingeckoId: "tabtrader"
    }
  },
  BOKU: {
    symbol: "BOKU",
    name: "Boryoku Dragonz",
    mint: "CN7qFa5iYkHz99PTctvT4xXUHnxwjQ5MHxCuTJtPN5uS",
    decimals: 9,
    extensions: {
      coingeckoId: "boku"
    }
  },
  MIMO: {
    symbol: "MIMO",
    name: "Million Monke",
    mint: "9TE7ebz1dsFo1uQ2T4oYAKSm39Y6fWuHrd6Uk6XaiD16",
    decimals: 9,
    extensions: {
      coingeckoId: "million-monke"
    }
  },
  wbWBNB: {
    symbol: "wbWBNB",
    name: "wbWBNB",
    mint: "9gP2kCy3wA1ctvYWQk75guqXuHfrEomqydHLtcTCqiLa",
    decimals: 8,
    extensions: {}
  },
  wePEOPLE: {
    symbol: "wePEOPLE",
    name: "wePEOPLE",
    mint: "CobcsUrt3p91FwvULYKorQejgsm5HoQdv5T8RUZ6PnLA",
    decimals: 8,
    extensions: {}
  },
  XTAG: {
    symbol: "XTAG",
    name: "xHashtag",
    mint: "5gs8nf4wojB5EXgDUWNLwXpknzgV2YWDhveAeBZpVLbp",
    decimals: 6,
    extensions: {
      coingeckoId: "xhashtag"
    }
  },
  KKO: {
    symbol: "KKO",
    name: "Kineko",
    mint: "kiNeKo77w1WBEzFFCXrTDRWGRWGP8yHvKC9rX6dqjQh",
    decimals: 9,
    extensions: {
      coingeckoId: "kineko"
    }
  },
  VI: {
    symbol: "VI",
    name: "Vybit",
    mint: "7zBWymxbZt7PVHQzfi3i85frc1YRiQc23K7bh3gos8ZC",
    decimals: 9,
    extensions: {
      coingeckoId: "vybit"
    }
  },
  SOLC: {
    symbol: "SOLC",
    name: "Solcubator",
    mint: "Bx1fDtvTN6NvE4kjdPHQXtmGSg582bZx9fGy4DQNMmAT",
    decimals: 9,
    extensions: {
      coingeckoId: "solcubator"
    }
  },
  STR: {
    symbol: "STR",
    name: "Solster",
    mint: "9zoqdwEBKWEi9G5Ze8BSkdmppxGgVv1Kw4LuigDiNr9m",
    decimals: 9,
    extensions: {
      coingeckoId: "solster"
    }
  },
  SPWN: {
    symbol: "SPWN",
    name: "Bitspawn",
    mint: "5U9QqCPhqXAJcEv9uyzFJd5zhN93vuPk1aNNkXnUfPnt",
    decimals: 9,
    extensions: {
      coingeckoId: "bitspawn"
    }
  },
  ISOLA: {
    symbol: "ISOLA",
    name: "Intersola",
    mint: "333iHoRM2Awhf9uVZtSyTfU8AekdGrgQePZsKMFPgKmS",
    decimals: 6,
    extensions: {
      coingeckoId: "intersola"
    }
  },
  RUN: {
    symbol: "RUN",
    name: "Run",
    mint: "6F9XriABHfWhit6zmMUYAQBSy6XK5VF1cHXuW5LDpRtC",
    decimals: 9,
    extensions: {
      coingeckoId: "run"
    }
  },
  REAL: {
    symbol: "REAL",
    name: "Realy Metaverse",
    mint: "AD27ov5fVU2XzwsbvnFvb1JpCBaCB5dRXrczV9CqSVGb",
    decimals: 9,
    extensions: {
      coingeckoId: "realy-metaverse"
    }
  },
  CRWNY: {
    symbol: "CRWNY",
    name: "CRWNY",
    mint: "CRWNYkqdgvhGGae9CKfNka58j6QQkaD5bLhKXvUYqnc1",
    decimals: 6,
    extensions: {}
  },
  BLOCK: {
    symbol: "BLOCK",
    name: "Blockasset",
    mint: "NFTUkR4u7wKxy9QLaX2TGvd9oZSWoMo4jqSJqdMb7Nk",
    decimals: 6,
    extensions: {
      coingeckoId: "blockasset"
    }
  },
  SOLAR: {
    symbol: "SOLAR",
    name: "Solar",
    mint: "2wmKXX1xsxLfrvjEPrt2UHiqj8Gbzwxvffr9qmNjsw8g",
    decimals: 9,
    extensions: {
      coingeckoId: "solar"
    }
  },
  BASIS: {
    symbol: "BASIS",
    name: "basis.markets",
    mint: "Basis9oJw9j8cw53oMV7iqsgo6ihi9ALw4QR31rcjUJa",
    decimals: 6,
    extensions: {
      coingeckoId: "basis-markets"
    }
  },
  SOLX: {
    symbol: "SOLX",
    name: "Soldex",
    mint: "CH74tuRLTYcxG7qNJCsV9rghfLXJCQJbsu7i52a8F1Gn",
    decimals: 9,
    extensions: {
      coingeckoId: "soldex"
    }
  },
  CHICKS: {
    symbol: "CHICKS",
    name: "SolChicks Token",
    mint: "cxxShYRVcepDudXhe7U62QHvw8uBJoKFifmzggGKVC2",
    decimals: 9,
    extensions: {
      coingeckoId: "solchicks-token"
    }
  },
  GST: {
    symbol: "GST",
    name: "GST",
    mint: "AFbX8oGjGpmVFywbVouvhQSRmiW2aR1mohfahi4Y2AdB",
    decimals: 9,
    extensions: {
      coingeckoId: "gst"
    }
  },
  MBS: {
    symbol: "MBS",
    name: "MonkeyBall",
    mint: "Fm9rHUTF5v3hwMLbStjZXqNBBoZyGriQaFM6sTFz3K8A",
    decimals: 6,
    extensions: {
      coingeckoId: "monkeyball"
    }
  },
  PRISM: {
    symbol: "PRISM",
    name: "Prism",
    mint: "PRSMNsEPqhGVCH1TtWiJqPjJyh2cKrLostPZTNy1o5x",
    decimals: 6,
    extensions: {
      coingeckoId: "prism"
    }
  },
  MEAN: {
    symbol: "MEAN",
    name: "Meanfi",
    mint: "MEANeD3XDdUmNMsRGjASkSWdC8prLYsoRJ61pPeHctD",
    decimals: 6,
    extensions: {
      coingeckoId: "meanfi"
    }
  },
  TINY: {
    symbol: "TINY",
    name: "Tiny Colony",
    mint: "HKfs24UEDQpHS5hUyKYkHd9q7GY5UQ679q2bokeL2whu",
    decimals: 6,
    extensions: {
      coingeckoId: "tiny-colony"
    }
  },
  SHDW: {
    symbol: "SHDW",
    name: "GenesysGo Shadow",
    mint: "SHDWyBxihqiCj6YekG2GUr7wqKLeLAMK1gHZck9pL6y",
    decimals: 9,
    extensions: {
      coingeckoId: "genesysgo-shadow"
    }
  },
  SCY: {
    symbol: "SCY",
    name: "Synchrony",
    mint: "SCYfrGCw8aDiqdgcpdGjV6jp4UVVQLuphxTDLNWu36f",
    decimals: 9,
    extensions: {
      coingeckoId: "synchrony"
    }
  },
  SLC: {
    symbol: "SLC",
    name: "Solice",
    mint: "METAmTMXwdb8gYzyCPfXXFmZZw4rUsXX58PNsDg7zjL",
    decimals: 6,
    extensions: {
      coingeckoId: "solice"
    }
  }
};
var MAINNET_LP_TOKENS = {
  FIDA_RAY_V4: {
    symbol: "FIDA-RAY",
    name: "FIDA-RAY V4 LP",
    mint: "DsBuznXRTmzvEdb36Dx3aVLVo1XmH7r1PRZUFugLPTFv",
    base: MAINNET_SPL_TOKENS.FIDA,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.FIDA.decimals,
    version: 4
  },
  OXY_RAY_V4: {
    symbol: "OXY-RAY",
    name: "OXY-RAY V4 LP",
    mint: "FwaX9W7iThTZH5MFeasxdLpxTVxRcM7ZHieTCnYog8Yb",
    base: MAINNET_SPL_TOKENS.OXY,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.OXY.decimals,
    version: 4
  },
  MAPS_RAY_V4: {
    symbol: "MAPS-RAY",
    name: "MAPS-RAY V4 LP",
    mint: "CcKK8srfVdTSsFGV3VLBb2YDbzF4T4NM2C3UEjC39RLP",
    base: MAINNET_SPL_TOKENS.MAPS,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.MAPS.decimals,
    version: 4
  },
  KIN_RAY_V4: {
    symbol: "KIN-RAY",
    name: "KIN-RAY V4 LP",
    mint: "CHT8sft3h3gpLYbCcZ9o27mT5s3Z6VifBVbUiDvprHPW",
    base: MAINNET_SPL_TOKENS.KIN,
    quote: MAINNET_SPL_TOKENS.RAY,
    // mistake, a special one
    decimals: 6,
    version: 4
  },
  RAY_USDT_V4: {
    symbol: "RAY-USDT",
    name: "RAY-USDT V4 LP",
    mint: "C3sT1R3nsw4AVdepvLTLKr5Gvszr7jufyBWUCvy4TUvT",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  SOL_USDC_V4: {
    symbol: "SOL-USDC",
    name: "SOL-USDC V4 LP",
    mint: "8HoQnePLqPj4M7PUDzfw8e3Ymdwgc7NLGnaTUapubyvu",
    base: MAINNET_SPL_TOKENS.WSOL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.WSOL.decimals,
    version: 4
  },
  YFI_USDC_V4: {
    symbol: "YFI-USDC",
    name: "YFI-USDC V4 LP",
    mint: "865j7iMmRRycSYUXzJ33ZcvLiX9JHvaLidasCyUyKaRE",
    base: MAINNET_SPL_TOKENS.YFI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.YFI.decimals,
    version: 4
  },
  SRM_USDC_V4: {
    symbol: "SRM-USDC",
    name: "SRM-USDC V4 LP",
    mint: "9XnZd82j34KxNLgQfz29jGbYdxsYznTWRpvZE3SRE7JG",
    base: MAINNET_SPL_TOKENS.SRM,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SRM.decimals,
    version: 4
  },
  FTT_USDC_V4: {
    symbol: "FTT-USDC",
    name: "FTT-USDC V4 LP",
    mint: "75dCoKfUHLUuZ4qEh46ovsxfgWhB4icc3SintzWRedT9",
    base: MAINNET_SPL_TOKENS.FTT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.FTT.decimals,
    version: 4
  },
  BTC_USDC_V4: {
    symbol: "BTC-USDC",
    name: "BTC-USDC V4 LP",
    mint: "2hMdRdVWZqetQsaHG8kQjdZinEMBz75vsoWTCob1ijXu",
    base: MAINNET_SPL_TOKENS.BTC,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.BTC.decimals,
    version: 4
  },
  SUSHI_USDC_V4: {
    symbol: "SUSHI-USDC",
    name: "SUSHI-USDC V4 LP",
    mint: "2QVjeR9d2PbSf8em8NE8zWd8RYHjFtucDUdDgdbDD2h2",
    base: MAINNET_SPL_TOKENS.SUSHI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
    version: 4
  },
  TOMO_USDC_V4: {
    symbol: "TOMO-USDC",
    name: "TOMO-USDC V4 LP",
    mint: "CHyUpQFeW456zcr5XEh4RZiibH8Dzocs6Wbgz9aWpXnQ",
    base: MAINNET_SPL_TOKENS.TOMO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
    version: 4
  },
  LINK_USDC_V4: {
    symbol: "LINK-USDC",
    name: "LINK-USDC V4 LP",
    mint: "BqjoYjqKrXtfBKXeaWeAT5sYCy7wsAYf3XjgDWsHSBRs",
    base: MAINNET_SPL_TOKENS.LINK,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.LINK.decimals,
    version: 4
  },
  ETH_USDC_V4: {
    symbol: "ETH-USDC",
    name: "ETH-USDC V4 LP",
    mint: "13PoKid6cZop4sj2GfoBeujnGfthUbTERdE5tpLCDLEY",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  xCOPE_USDC_V4: {
    symbol: "xCOPE-USDC",
    name: "xCOPE-USDC V4 LP",
    mint: "2Vyyeuyd15Gp8aH6uKE72c4hxc8TVSLibxDP9vzspQWG",
    base: MAINNET_SPL_TOKENS.xCOPE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.xCOPE.decimals,
    version: 4
  },
  SOL_USDT_V4: {
    symbol: "SOL-USDT",
    name: "SOL-USDT V4 LP",
    mint: "Epm4KfTj4DMrvqn6Bwg2Tr2N8vhQuNbuK8bESFp4k33K",
    base: MAINNET_SPL_TOKENS.WSOL,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.WSOL.decimals,
    version: 4
  },
  YFI_USDT_V4: {
    symbol: "YFI-USDT",
    name: "YFI-USDT V4 LP",
    mint: "FA1i7fej1pAbQbnY8NbyYUsTrWcasTyipKreDgy1Mgku",
    base: MAINNET_SPL_TOKENS.YFI,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.YFI.decimals,
    version: 4
  },
  SRM_USDT_V4: {
    symbol: "SRM-USDT",
    name: "SRM-USDT V4 LP",
    mint: "HYSAu42BFejBS77jZAZdNAWa3iVcbSRJSzp3wtqCbWwv",
    base: MAINNET_SPL_TOKENS.SRM,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.SRM.decimals,
    version: 4
  },
  FTT_USDT_V4: {
    symbol: "FTT-USDT",
    name: "FTT-USDT V4 LP",
    mint: "2cTCiUnect5Lap2sk19xLby7aajNDYseFhC9Pigou11z",
    base: MAINNET_SPL_TOKENS.FTT,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.FTT.decimals,
    version: 4
  },
  BTC_USDT_V4: {
    symbol: "BTC-USDT",
    name: "BTC-USDT V4 LP",
    mint: "DgGuvR9GSHimopo3Gc7gfkbKamLKrdyzWkq5yqA6LqYS",
    base: MAINNET_SPL_TOKENS.BTC,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.BTC.decimals,
    version: 4
  },
  SUSHI_USDT_V4: {
    symbol: "SUSHI-USDT",
    name: "SUSHI-USDT V4 LP",
    mint: "Ba26poEYDy6P2o95AJUsewXgZ8DM9BCsmnU9hmC9i4Ki",
    base: MAINNET_SPL_TOKENS.SUSHI,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
    version: 4
  },
  TOMO_USDT_V4: {
    symbol: "TOMO-USDT",
    name: "TOMO-USDT V4 LP",
    mint: "D3iGro1vn6PWJXo9QAPj3dfta6dKkHHnmiiym2EfsAmi",
    base: MAINNET_SPL_TOKENS.TOMO,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
    version: 4
  },
  LINK_USDT_V4: {
    symbol: "LINK-USDT",
    name: "LINK-USDT V4 LP",
    mint: "Dr12Sgt9gkY8WU5tRkgZf1TkVWJbvjYuPAhR3aDCwiiX",
    base: MAINNET_SPL_TOKENS.LINK,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.LINK.decimals,
    version: 4
  },
  ETH_USDT_V4: {
    symbol: "ETH-USDT",
    name: "ETH-USDT V4 LP",
    mint: "nPrB78ETY8661fUgohpuVusNCZnedYCgghzRJzxWnVb",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  YFI_SRM_V4: {
    symbol: "YFI-SRM",
    name: "YFI-SRM V4 LP",
    mint: "EGJht91R7dKpCj8wzALkjmNdUUUcQgodqWCYweyKcRcV",
    base: MAINNET_SPL_TOKENS.YFI,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.YFI.decimals,
    version: 4
  },
  FTT_SRM_V4: {
    symbol: "FTT-SRM",
    name: "FTT-SRM V4 LP",
    mint: "AsDuPg9MgPtt3jfoyctUCUgsvwqAN6RZPftqoeiPDefM",
    base: MAINNET_SPL_TOKENS.FTT,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.FTT.decimals,
    version: 4
  },
  BTC_SRM_V4: {
    symbol: "BTC-SRM",
    name: "BTC-SRM V4 LP",
    mint: "AGHQxXb3GSzeiLTcLtXMS2D5GGDZxsB2fZYZxSB5weqB",
    base: MAINNET_SPL_TOKENS.BTC,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.BTC.decimals,
    version: 4
  },
  SUSHI_SRM_V4: {
    symbol: "SUSHI-SRM",
    name: "SUSHI-SRM V4 LP",
    mint: "3HYhUnUdV67j1vn8fu7ExuVGy5dJozHEyWvqEstDbWwE",
    base: MAINNET_SPL_TOKENS.SUSHI,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.SUSHI.decimals,
    version: 4
  },
  TOMO_SRM_V4: {
    symbol: "TOMO-SRM",
    name: "TOMO-SRM V4 LP",
    mint: "GgH9RnKrQpaMQeqmdbMvs5oo1A24hERQ9wuY2pSkeG7x",
    base: MAINNET_SPL_TOKENS.TOMO,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.TOMO.decimals,
    version: 4
  },
  LINK_SRM_V4: {
    symbol: "LINK-SRM",
    name: "LINK-SRM V4 LP",
    mint: "GXN6yJv12o18skTmJXaeFXZVY1iqR18CHsmCT8VVCmDD",
    base: MAINNET_SPL_TOKENS.LINK,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.LINK.decimals,
    version: 4
  },
  ETH_SRM_V4: {
    symbol: "ETH-SRM",
    name: "ETH-SRM V4 LP",
    mint: "9VoY3VERETuc2FoadMSYYizF26mJinY514ZpEzkHMtwG",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  SRM_SOL_V4: {
    symbol: "SRM-SOL",
    name: "SRM-SOL V4 LP",
    mint: "AKJHspCwDhABucCxNLXUSfEzb7Ny62RqFtC9uNjJi4fq",
    base: MAINNET_SPL_TOKENS.SRM,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.SRM.decimals,
    version: 4
  },
  STEP_USDC_V4: {
    symbol: "STEP-USDC",
    name: "STEP-USDC V4 LP",
    mint: "3k8BDobgihmk72jVmXYLE168bxxQUhqqyESW4dQVktqC",
    base: MAINNET_SPL_TOKENS.STEP,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.STEP.decimals,
    version: 4
  },
  MEDIA_USDC_V4: {
    symbol: "MEDIA-USDC",
    name: "MEDIA-USDC V4 LP",
    mint: "A5zanvgtioZGiJMdEyaKN4XQmJsp1p7uVxaq2696REvQ",
    base: MAINNET_SPL_TOKENS.MEDIA,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.MEDIA.decimals,
    version: 4
  },
  ROPE_USDC_V4: {
    symbol: "ROPE-USDC",
    name: "ROPE-USDC V4 LP",
    mint: "Cq4HyW5xia37tKejPF2XfZeXQoPYW6KfbPvxvw5eRoUE",
    base: MAINNET_SPL_TOKENS.ROPE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ROPE.decimals,
    version: 4
  },
  MER_USDC_V4: {
    symbol: "MER-USDC",
    name: "MER-USDC V4 LP",
    mint: "3H9NxvaZoxMZZDZcbBDdWMKbrfNj7PCF5sbRwDr7SdDW",
    base: MAINNET_SPL_TOKENS.MER,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.MER.decimals,
    version: 4
  },
  COPE_USDC_V4: {
    symbol: "COPE-USDC",
    name: "COPE-USDC V4 LP",
    mint: "Cz1kUvHw98imKkrqqu95GQB9h1frY8RikxPojMwWKGXf",
    base: MAINNET_SPL_TOKENS.COPE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.COPE.decimals,
    version: 4
  },
  ALEPH_USDC_V4: {
    symbol: "ALEPH-USDC",
    name: "ALEPH-USDC V4 LP",
    mint: "iUDasAP2nXm5wvTukAHEKSdSXn8vQkRtaiShs9ceGB7",
    base: MAINNET_SPL_TOKENS.ALEPH,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ALEPH.decimals,
    version: 4
  },
  TULIP_USDC_V4: {
    symbol: "TULIP-USDC",
    name: "TULIP-USDC V4 LP",
    mint: "2doeZGLJyACtaG9DCUyqMLtswesfje1hjNA11hMdj6YU",
    base: MAINNET_SPL_TOKENS.TULIP,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.TULIP.decimals,
    version: 4
  },
  WOO_USDC_V4: {
    symbol: "WOO-USDC",
    name: "WOO-USDC V4 LP",
    mint: "7cu42ao8Jgrd5A3y3bNQsCxq5poyGZNmTydkGfJYQfzh",
    base: MAINNET_SPL_TOKENS.WOO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.WOO.decimals,
    version: 4
  },
  SNY_USDC_V4: {
    symbol: "SNY-USDC",
    name: "SNY-USDC V4 LP",
    mint: "G8qcfeFqxwbCqpxv5LpLWxUCd1PyMB5nWb5e5YyxLMKg",
    base: MAINNET_SPL_TOKENS.SNY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SNY.decimals,
    version: 4
  },
  BOP_RAY_V4: {
    symbol: "BOP-RAY",
    name: "BOP-RAY V4 LP",
    mint: "9nQPYJvysyfnXhQ6nkK5V7sZG26hmDgusfdNQijRk5LD",
    base: MAINNET_SPL_TOKENS.BOP,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.BOP.decimals,
    version: 4
  },
  SLRS_USDC_V4: {
    symbol: "SLRS-USDC",
    name: "SLRS-USDC V4 LP",
    mint: "2Xxbm1hdv5wPeen5ponDSMT3VqhGMTQ7mH9stNXm9shU",
    base: MAINNET_SPL_TOKENS.SLRS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SLRS.decimals,
    version: 4
  },
  SAMO_RAY_V4: {
    symbol: "SAMO-RAY",
    name: "SAMO-RAY V4 LP",
    mint: "HwzkXyX8B45LsaHXwY8su92NoRBS5GQC32HzjQRDqPnr",
    base: MAINNET_SPL_TOKENS.SAMO,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.SAMO.decimals,
    version: 4
  },
  renBTC_USDC_V4: {
    symbol: "renBTC-USDC",
    name: "renBTC-USDC V4 LP",
    mint: "CTEpsih91ZLo5gunvryLpJ3pzMjmt5jbS6AnSQrzYw7V",
    base: MAINNET_SPL_TOKENS.renBTC,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.renBTC.decimals,
    version: 4
  },
  renDOGE_USDC_V4: {
    symbol: "renDOGE-USDC",
    name: "renDOGE-USDC V4 LP",
    mint: "Hb8KnZNKvRxu7pgMRWJgoMSMcepfvNiBFFDDrdf9o3wA",
    base: MAINNET_SPL_TOKENS.renDOGE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.renDOGE.decimals,
    version: 4
  },
  RAY_USDC_V4: {
    symbol: "RAY-USDC",
    name: "RAY-USDC V4 LP",
    mint: "FbC6K13MzHvN42bXrtGaWsvZY9fxrackRSZcBGfjPc7m",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  RAY_SRM_V4: {
    symbol: "RAY-SRM",
    name: "RAY-SRM V4 LP",
    mint: "7P5Thr9Egi2rvMmEuQkLn8x8e8Qro7u2U7yLD2tU2Hbe",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.SRM,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  RAY_ETH_V4: {
    symbol: "RAY-ETH",
    name: "RAY-ETH V4 LP",
    mint: "mjQH33MqZv5aKAbKHi8dG3g3qXeRQqq1GFcXceZkNSr",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.ETH,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  RAY_SOL_V4: {
    symbol: "RAY-SOL",
    name: "RAY-SOL V4 LP",
    mint: "89ZKE4aoyfLBe2RuV6jM3JGNhaV18Nxh8eNtjRcndBip",
    base: MAINNET_SPL_TOKENS.RAY,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.RAY.decimals,
    version: 4
  },
  DXL_USDC_V4: {
    symbol: "DXL-USDC",
    name: "DXL-USDC V4 LP",
    mint: "4HFaSvfgskipvrzT1exoVKsUZ174JyExEsA8bDfsAdY5",
    base: MAINNET_SPL_TOKENS.DXL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.DXL.decimals,
    version: 4
  },
  LIKE_USDC_V4: {
    symbol: "LIKE-USDC",
    name: "LIKE-USDC V4 LP",
    mint: "cjZmbt8sJgaoyWYUttomAu5LJYU44ZrcKTbzTSEPDVw",
    base: MAINNET_SPL_TOKENS.LIKE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.LIKE.decimals,
    version: 4
  },
  mSOL_USDC_V4: {
    symbol: "mSOL-USDC",
    name: "mSOL-USDC V4 LP",
    mint: "4xTpJ4p76bAeggXoYywpCCNKfJspbuRzZ79R7pRhbqSf",
    base: MAINNET_SPL_TOKENS.mSOL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
    version: 4
  },
  mSOL_SOL_V4: {
    symbol: "mSOL-SOL",
    name: "mSOL-SOL V4 LP",
    mint: "5ijRoAHVgd5T5CNtK5KDRUBZ7Bffb69nktMj5n6ks6m4",
    base: MAINNET_SPL_TOKENS.mSOL,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
    version: 4
  },
  MER_PAI_V4: {
    symbol: "MER-PAI",
    name: "MER-PAI V4 LP",
    mint: "DU5RT2D9EviaSmX6Ta8MZwMm85HwSEqGMRdqUiuCGfmD",
    base: MAINNET_SPL_TOKENS.MER,
    quote: MAINNET_SPL_TOKENS.PAI,
    decimals: MAINNET_SPL_TOKENS.MER.decimals,
    version: 4
  },
  PORT_USDC_V4: {
    symbol: "PORT-USDC",
    name: "PORT-USDC V4 LP",
    mint: "9tmNtbUCrLS15qC4tEfr5NNeqcqpZ4uiGgi2vS5CLQBS",
    base: MAINNET_SPL_TOKENS.PORT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.PORT.decimals,
    version: 4
  },
  MNGO_USDC_V4: {
    symbol: "MNGO-USDC",
    name: "MNGO-USDC V4 LP",
    mint: "DkiqCQ792n743xjWQVCbBUaVtkdiuvQeYndM53ReWnCC",
    base: MAINNET_SPL_TOKENS.MNGO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.MNGO.decimals,
    version: 4
  },
  ATLAS_USDC_V4: {
    symbol: "ATLAS-USDC",
    name: "ATLAS-USDC V4 LP",
    mint: "9shGU9f1EsxAbiR567MYZ78WUiS6ZNCYbHe53WUULQ7n",
    base: MAINNET_SPL_TOKENS.ATLAS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ATLAS.decimals,
    version: 4
  },
  POLIS_USDC_V4: {
    symbol: "POLIS-USDC",
    name: "POLIS-USDC V4 LP",
    mint: "8MbKSBpyXs8fVneKgt71jfHrn5SWtX8n4wMLpiVfF9So",
    base: MAINNET_SPL_TOKENS.POLIS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.POLIS.decimals,
    version: 4
  },
  ATLAS_RAY_V4: {
    symbol: "ATLAS-RAY",
    name: "ATLAS-RAY V4 LP",
    mint: "418MFhkaYQtbn529wmjLLqL6uKxDz7j4eZBaV1cobkyd",
    base: MAINNET_SPL_TOKENS.ATLAS,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.ATLAS.decimals,
    version: 4
  },
  POLIS_RAY_V4: {
    symbol: "POLIS-RAY",
    name: "POLIS-RAY V4 LP",
    mint: "9ysGKUH6WqzjQEUT4dxqYCUaFNVK9QFEa24pGzjFq8xg",
    base: MAINNET_SPL_TOKENS.POLIS,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.POLIS.decimals,
    version: 4
  },
  ALEPH_RAY_V4: {
    symbol: "ALEPH-RAY",
    name: "ALEPH-RAY V4 LP",
    mint: "n76skjqv4LirhdLok2zJELXNLdRpYDgVJQuQFbamscy",
    base: MAINNET_SPL_TOKENS.ALEPH,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.ALEPH.decimals,
    version: 4
  },
  TULIP_RAY_V4: {
    symbol: "TULIP-RAY",
    name: "TULIP-RAY V4 LP",
    mint: "3AZTviji5qduMG2s4FfWGR3SSQmNUCyx8ao6UKCPg3oJ",
    base: MAINNET_SPL_TOKENS.TULIP,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.TULIP.decimals,
    version: 4
  },
  SLRS_RAY_V4: {
    symbol: "SLRS-RAY",
    name: "SLRS-RAY V4 LP",
    mint: "2pk78vsKT3jfJAcN2zbpMUnrR57SZrxHqaZYyFgp92mM",
    base: MAINNET_SPL_TOKENS.SLRS,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.SLRS.decimals,
    version: 4
  },
  MER_RAY_V4: {
    symbol: "MER-RAY",
    name: "MER-RAY V4 LP",
    mint: "214hxy3AbKoaEKgqcg2aC1cP5R67cGGAyDEg5GDwC7Ub",
    base: MAINNET_SPL_TOKENS.MER,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.MER.decimals,
    version: 4
  },
  MEDIA_RAY_V4: {
    symbol: "MEDIA-RAY",
    name: "MEDIA-RAY V4 LP",
    mint: "9Aseg5A1JD1yCiFFdDaNNxCiJ7XzrpZFmcEmLjXFdPaH",
    base: MAINNET_SPL_TOKENS.MEDIA,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.MEDIA.decimals,
    version: 4
  },
  SNY_RAY_V4: {
    symbol: "SNY-RAY",
    name: "SNY-RAY V4 LP",
    mint: "2k4quTuuLUxrSEhFH99qcoZzvgvVEc3b5sz3xz3qstfS",
    base: MAINNET_SPL_TOKENS.SNY,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.SNY.decimals,
    version: 4
  },
  LIKE_RAY_V4: {
    symbol: "LIKE-RAY",
    name: "LIKE-RAY V4 LP",
    mint: "7xqDycbFSCpUpzkYapFeyPJWPwEpV7zdWbYf2MVHTNjv",
    base: MAINNET_SPL_TOKENS.LIKE,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.LIKE.decimals,
    version: 4
  },
  COPE_RAY_V4: {
    symbol: "COPE-RAY",
    name: "COPE-RAY V4 LP",
    mint: "A7GCVHA8NSsbdFscHdoNU41tL1TRKNmCH4K94CgcLK9F",
    base: MAINNET_SPL_TOKENS.COPE,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.COPE.decimals,
    version: 4
  },
  ETH_SOL_V4: {
    symbol: "ETH-SOL",
    name: "ETH-SOL V4 LP",
    mint: "GKfgC86iJoMjwAtcyiLu6nWnjggqUXsDQihXkP14fDez",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  stSOL_USDC_V4: {
    symbol: "stSOL-USDC",
    name: "stSOL-USDC V4 LP",
    mint: "HDUJMwYZkjUZre63xUeDhdCi8c6LgUDiBqxmP3QC3VPX",
    base: MAINNET_SPL_TOKENS.stSOL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.stSOL.decimals,
    version: 4
  },
  GRAPE_USDC_V4: {
    symbol: "GRAPE-USDC",
    name: "GRAPE-USDC V4 LP",
    mint: "A8ZYmnZ1vwxUa4wpJVUaJgegsuTEz5TKy5CiJXffvmpt",
    base: MAINNET_SPL_TOKENS.GRAPE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.GRAPE.decimals,
    version: 4
  },
  LARIX_USDC_V4: {
    symbol: "LARIX-USDC",
    name: "LARIX-USDC V4 LP",
    mint: "7yieit4YsNsZ9CAK8H5ZEMvvk35kPEHHeXwp6naoWU9V",
    base: MAINNET_SPL_TOKENS.LARIX,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.LARIX.decimals,
    version: 4
  },
  RIN_USDC_V4: {
    symbol: "RIN-USDC",
    name: "RIN-USDC V4 LP",
    mint: "GfCWfrZez7BDmCSEeMERVDVUaaM2TEreyYUgb2cpuS3w",
    base: MAINNET_SPL_TOKENS.RIN,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.RIN.decimals,
    version: 4
  },
  APEX_USDC_V4: {
    symbol: "APEX-USDC",
    name: "APEX-USDC V4 LP",
    mint: "444cVqYyDxJNo6FqiMb9qQWFUd7tYzFRdDuJRFrSAGnU",
    base: MAINNET_SPL_TOKENS.APEX,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.APEX.decimals,
    version: 4
  },
  mSOL_RAY_V4: {
    symbol: "mSOL-RAY",
    name: "mSOL-RAY V4 LP",
    mint: "De2EHBAdkgfc72DpShqDGG42cV3iDWh8wvvZdPsiEcqP",
    base: MAINNET_SPL_TOKENS.mSOL,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
    version: 4
  },
  MNDE_mSOL_V4: {
    symbol: "MNDE-mSOL",
    name: "MNDE-mSOL V4 LP",
    mint: "4bh8XCzTHSbqbWN8o1Jn4ueBdz1LvJFoEasN6K6CQ8Ny",
    base: MAINNET_SPL_TOKENS.MNDE,
    quote: MAINNET_SPL_TOKENS.mSOL,
    decimals: MAINNET_SPL_TOKENS.MNDE.decimals,
    version: 4
  },
  LARIX_RAY_V4: {
    symbol: "LARIX-RAY",
    name: "LARIX-RAY V4 LP",
    mint: "ZRDfSLgWGeaYSmhdPvFNKQQhDcYdZQaue2N8YDmHX4q",
    base: MAINNET_SPL_TOKENS.LARIX,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.LARIX.decimals,
    version: 4
  },
  LIQ_USDC_V4: {
    symbol: "LIQ-USDC",
    name: "LIQ-USDC V4 LP",
    mint: "GWpD3eTfhJB5KDCcnE85dBQrjAk2CsrgDF9b52R9CrjV",
    base: MAINNET_SPL_TOKENS.LIQ,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.LIQ.decimals,
    version: 4
  },
  WAG_USDC_V4: {
    symbol: "WAG-USDC",
    name: "WAG-USDC V4 LP",
    mint: "4yykyPugitUVRewNPXXCviRvxGfsfsRMoP32z3b6FmUC",
    base: MAINNET_SPL_TOKENS.WAG,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.WAG.decimals,
    version: 4
  },
  ETH_mSOL_V4: {
    symbol: "ETH-mSOL",
    name: "ETH-mSOL V4 LP",
    mint: "HYv3grQfi8QbV7nG7EFgNK1aJSrsJ7HynXJKJVPLL2Uh",
    base: MAINNET_SPL_TOKENS.ETH,
    quote: MAINNET_SPL_TOKENS.mSOL,
    decimals: MAINNET_SPL_TOKENS.ETH.decimals,
    version: 4
  },
  mSOL_USDT_V4: {
    symbol: "mSOL-USDT",
    name: "mSOL-USDT V4 LP",
    mint: "69NCmEW9mGpiWLjAcAWHq51k4ionJZmzgRfRT3wQaCCf",
    base: MAINNET_SPL_TOKENS.mSOL,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.mSOL.decimals,
    version: 4
  },
  BTC_mSOL_V4: {
    symbol: "BTC-mSOL",
    name: "BTC-mSOL V4 LP",
    mint: "92bcERNtUmuaJ6mwLSxYHZYSph37jdKxRdoYNxpcYNPp",
    base: MAINNET_SPL_TOKENS.BTC,
    quote: MAINNET_SPL_TOKENS.mSOL,
    decimals: MAINNET_SPL_TOKENS.BTC.decimals,
    version: 4
  },
  SLIM_SOL_V4: {
    symbol: "SLIM-SOL",
    name: "SLIM-SOL V4 LP",
    mint: "9X4EK8E59VAVi6ChnNvvd39m6Yg9RtkBbAPq1mDVJT57",
    base: MAINNET_SPL_TOKENS.SLIM,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.SLIM.decimals,
    version: 4
  },
  AURY_USDC_V4: {
    symbol: "AURY-USDC",
    name: "AURY-USDC V4 LP",
    mint: "Gub5dvTy4nzP82qpmpNkBxmRqjtqRddBTBqHSdNcf2oS",
    base: MAINNET_SPL_TOKENS.AURY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.AURY.decimals,
    version: 4
  },
  PRT_SOL_V4: {
    symbol: "PRT-SOL",
    name: "PRT-SOL V4 LP",
    mint: "EcJ8Wgwt1AzSPiDpVr6aaSur8TKAsNTPmmzRACeqT68Z",
    base: MAINNET_SPL_TOKENS.PRT,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.PRT.decimals,
    version: 4
  },
  LIQ_RAY_V4: {
    symbol: "LIQ-RAY",
    name: "LIQ-RAY V4 LP",
    mint: "49YUsDrThJosHSagCn1F59Uc9NRxbr9thVrZikUnQDXy",
    base: MAINNET_SPL_TOKENS.LIQ,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.LIQ.decimals,
    version: 4
  },
  SYP_SOL_V4: {
    symbol: "SYP-SOL",
    name: "SYP-SOL V4 LP",
    mint: "KHV6dfj2bDntzJ9z1S26cDfqWfUZdJRFmteLR6LxHwW",
    base: MAINNET_SPL_TOKENS.SYP,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.SYP.decimals,
    version: 4
  },
  SYP_RAY_V4: {
    symbol: "SYP-RAY",
    name: "SYP-RAY V4 LP",
    mint: "FT2KZqxxM8F2h9pZtTF4PyjK88bM4YbuBzd7ZPwQ5wMB",
    base: MAINNET_SPL_TOKENS.SYP,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.SYP.decimals,
    version: 4
  },
  SYP_USDC_V4: {
    symbol: "SYP-USDC",
    name: "SYP-USDC V4 LP",
    mint: "2xJGuLAivAR1WkARRA6zP1v4jaA9jV2Qis8JfMNvrVyZ",
    base: MAINNET_SPL_TOKENS.SYP,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SYP.decimals,
    version: 4
  },
  FAB_USDC_V4: {
    symbol: "FAB-USDC",
    name: "FAB-USDC V4 LP",
    mint: "5rTCvZq6BcApsC3VV1EEUuTJfaVd8uYhcGjwTy1By6P8",
    base: MAINNET_SPL_TOKENS.FAB,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.FAB.decimals,
    version: 4
  },
  WOOF_RAY_V4: {
    symbol: "WOOF-RAY",
    name: "WOOF-RAY V4 LP",
    mint: "H2FAnazDaGFutcmnrwDxhmdncR1Bd7GG4mhPCSUiamDX",
    base: MAINNET_SPL_TOKENS.WOOF,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.WOOF.decimals,
    version: 4
  },
  WOOF_USDC_V4: {
    symbol: "WOOF-USDC",
    name: "WOOF-USDC V4 LP",
    mint: "EFSu5TMc1ijRevaYCxUkS7uGvbhsymDHEaTK3UVdNE3q",
    base: MAINNET_SPL_TOKENS.WOOF,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.WOOF.decimals,
    version: 4
  },
  SLND_USDC_V4: {
    symbol: "SLND-USDC",
    name: "SLND-USDC V4 LP",
    mint: "EunE9uDh2cGsyJcsGuGKc6wte7kBn8iye2gzC4w2ePHn",
    base: MAINNET_SPL_TOKENS.SLND,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SLND.decimals,
    version: 4
  },
  FRKT_SOL_V4: {
    symbol: "FRKT-SOL",
    name: "FRKT-SOL V4 LP",
    mint: "HYUKXgpjaxMXHttyrFYtv3z2rdhZ1U9QDH8zEc8BooQC",
    base: MAINNET_SPL_TOKENS.FRKT,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.FRKT.decimals,
    version: 4
  },
  weWETH_SOL_V4: {
    symbol: "weWETH-SOL",
    name: "weWETH-SOL V4 LP",
    mint: "3hbozt2Por7bcrGod8N7kEeJNMocFFjCJrQR16TQGBrE",
    base: MAINNET_SPL_TOKENS.weWETH,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.weWETH.decimals,
    version: 4
  },
  weWETH_USDC_V4: {
    symbol: "weWETH-USDC",
    name: "weWETH-USDC V4 LP",
    mint: "3529SBnMCDW3S3xQ52aABbRHo7PcHvpQA4no8J12L5eK",
    base: MAINNET_SPL_TOKENS.weWETH,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weWETH.decimals,
    version: 4
  },
  weUNI_USDC_V4: {
    symbol: "weUNI-USDC",
    name: "weUNI-USDC V4 LP",
    mint: "EEC4QnT41py39QaYnzQnoYQEtDUDNa6Se8SBDgfPSN2a",
    base: MAINNET_SPL_TOKENS.weUNI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weUNI.decimals,
    version: 4
  },
  weSUSHI_USDC_V4: {
    symbol: "weSUSHI-USDC",
    name: "weSUSHI-USDC V4 LP",
    mint: "3wVrtQZsiDNp5yTPyfEzQHPU6iuJoMmpnWg6CTt4V8sR",
    base: MAINNET_SPL_TOKENS.weSUSHI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weSUSHI.decimals,
    version: 4
  },
  CYS_USDC_V4: {
    symbol: "CYS-USDC",
    name: "CYS-USDC V4 LP",
    mint: "GfV3QDzzdVUwCNSdfn6PjhmyJvjw18tn51RingWZYwk3",
    base: MAINNET_SPL_TOKENS.CYS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CYS.decimals,
    version: 4
  },
  SAMO_USDC_V4: {
    symbol: "SAMO-USDC",
    name: "SAMO-USDC V4 LP",
    mint: "B2PjGEP3vPf1999fUD14pYdxvSDRVBk43hxB2rgthwEY",
    base: MAINNET_SPL_TOKENS.SAMO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SAMO.decimals,
    version: 4
  },
  ABR_USDC_V4: {
    symbol: "ABR-USDC",
    name: "ABR-USDC V4 LP",
    mint: "ECHfxkf5zjjZFTX95QfFahNyzG7feyEKcfTdjsdrMSGU",
    base: MAINNET_SPL_TOKENS.ABR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.ABR.decimals,
    version: 4
  },
  IN_USDC_V4: {
    symbol: "IN-USDC",
    name: "IN-USDC V4 LP",
    mint: "GbmJtVgg9fRmmmjKUYGMZeSt8wZ47cDDXasg5Y3iF4kz",
    base: MAINNET_SPL_TOKENS.IN,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.IN.decimals,
    version: 4
  },
  weDYDX_USDC_V4: {
    symbol: "weDYDX-USDC",
    name: "weDYDX-USDC V4 LP",
    mint: "BjkkMZnnzmgLqzGErzDbkk15ozv48iVKQuunpeM2Hqnk",
    base: MAINNET_SPL_TOKENS.weDYDX,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weDYDX.decimals,
    version: 4
  },
  STARS_USDC_V4: {
    symbol: "STARS-USDC",
    name: "STARS-USDC V4 LP",
    mint: "FJ68q7NChhETcGVdinMbM2FF1Cy79dpmUi6HC83K55Hv",
    base: MAINNET_SPL_TOKENS.STARS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.STARS.decimals,
    version: 4
  },
  weAXS_USDC_V4: {
    symbol: "weAXS-USDC",
    name: "weAXS-USDC V4 LP",
    mint: "6PSoJQ7myQ1BJtbQC6oiWR8HSecQGyoWsPYTZRJo2ci3",
    base: MAINNET_SPL_TOKENS.weAXS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weAXS.decimals,
    version: 4
  },
  weSHIB_USDC_V4: {
    symbol: "weSHIB-USDC",
    name: "weSHIB-USDC V4 LP",
    mint: "AcjX5pmTMGSgxkdxc3r82r6WMKBvS6eQXXFz5ck5KKUa",
    base: MAINNET_SPL_TOKENS.weSHIB,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weSHIB.decimals,
    version: 4
  },
  SBR_USDC_V4: {
    symbol: "SBR-USDC",
    name: "SBR-USDC V4 LP",
    mint: "9FC8xTFRbgTpuZZYAYnZLxgnQ8r7FwfSBM1SWvGwgF7s",
    base: MAINNET_SPL_TOKENS.SBR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SBR.decimals,
    version: 4
  },
  OXS_USDC_V4: {
    symbol: "OXS-USDC",
    name: "OXS-USDC V4 LP",
    mint: "et9pdjWm97rbmsJoN183GkFV5qzTGru79GE1Zhe7NTU",
    base: MAINNET_SPL_TOKENS.OXS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.OXS.decimals,
    version: 4
  },
  CWAR_USDC_V4: {
    symbol: "CWAR-USDC",
    name: "CWAR-USDC V4 LP",
    mint: "HjR23bxn2gtRDB2P1Tm3DLepAPPZgazsWJpLG9wqjnYR",
    base: MAINNET_SPL_TOKENS.CWAR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CWAR.decimals,
    version: 4
  },
  UPS_USDC_V4: {
    symbol: "UPS-USDC",
    name: "UPS-USDC V4 LP",
    mint: "9hSUZdREEsbaYaKY4FouvXr7xyAqtpdHRDoYCb6Mb28a",
    base: MAINNET_SPL_TOKENS.UPS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.UPS.decimals,
    version: 4
  },
  weSAND_USDC_V4: {
    symbol: "weSAND-USDC",
    name: "weSAND-USDC V4 LP",
    mint: "3dADrQa7utyiCsaFeVk9r7oebW1WheowhKo5soBYKBVT",
    base: MAINNET_SPL_TOKENS.weSAND,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weSAND.decimals,
    version: 4
  },
  weMANA_USDC_V4: {
    symbol: "weMANA-USDC",
    name: "weMANA-USDC V4 LP",
    mint: "HpUkVAPRJ5zNRuJ1ZwMXEhbMHL3gSuPb2QuSER9YUd3a",
    base: MAINNET_SPL_TOKENS.weMANA,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.weMANA.decimals,
    version: 4
  },
  CAVE_USDC_V4: {
    symbol: "CAVE-USDC",
    name: "CAVE-USDC V4 LP",
    mint: "5Gba1k3fU7Vh7UtAiBmie9vhQNNq1JfEwgn1DPGZ7NKQ",
    base: MAINNET_SPL_TOKENS.CAVE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CAVE.decimals,
    version: 4
  },
  GENE_USDC_V4: {
    symbol: "GENE-USDC",
    name: "GENE-USDC V4 LP",
    mint: "7GKvfHEXenNiWYbJBKae89mdaMPr5gGMYwZmyC8gBNVG",
    base: MAINNET_SPL_TOKENS.GENE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.GENE.decimals,
    version: 4
  },
  GENE_RAY_V4: {
    symbol: "GENE-RAY",
    name: "GENE-RAY V4 LP",
    mint: "3HzXnc1qZ8mGqun18Ck3KA616XnZNqF1RWbgYE2nGRMA",
    base: MAINNET_SPL_TOKENS.GENE,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.GENE.decimals,
    version: 4
  },
  APT_USDC_V4: {
    symbol: "APT-USDC",
    name: "APT-USDC V4 LP",
    mint: "Hk8mDAJFq4E9kF3DtNgPFwzbo5kbeiusNFJgWmo3LoQ5",
    base: MAINNET_SPL_TOKENS.APT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.APT.decimals,
    version: 4
  },
  GOFX_USDC_V4: {
    symbol: "GOFX-USDC",
    name: "GOFX-USDC V4 LP",
    mint: "4svqAwrLPGRDCQuuieYTmtLXF75wiahjeK2rEN9tY1YL",
    base: MAINNET_SPL_TOKENS.GOFX,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.GOFX.decimals,
    version: 4
  },
  SONAR_USDC_V4: {
    symbol: "SONAR-USDC",
    name: "SONAR-USDC V4 LP",
    mint: "2tAcfqJ1YYjpGLqwh76kyNt9VaNFDd4fJySfH6SmWfKt",
    base: MAINNET_SPL_TOKENS.SONAR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SONAR.decimals,
    version: 4
  },
  JSOL_SOL_V4: {
    symbol: "JSOL-SOL",
    name: "JSOL-SOL V4 LP",
    mint: "61z37rpHsU6d3Fq5sUjJ85K6tXGzkoYKDAG3kPJQNDRo",
    base: MAINNET_SPL_TOKENS.JSOL,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.JSOL.decimals,
    version: 4
  },
  JSOL_USDC_V4: {
    symbol: "JSOL-USDC",
    name: "JSOL-USDC V4 LP",
    mint: "3JZqf2VPNxj1kDZQsfzC7myM6spsGQbGuFv1gVfdYosN",
    base: MAINNET_SPL_TOKENS.JSOL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.JSOL.decimals,
    version: 4
  },
  SHILL_USDC_V4: {
    symbol: "SHILL-USDC",
    name: "SHILL-USDC V4 LP",
    mint: "CnUhYBtQEbSBZ76bgxAouVCTCb8rofZzwerVF5z5LREJ",
    base: MAINNET_SPL_TOKENS.SHILL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SHILL.decimals,
    version: 4
  },
  DFL_USDC_V4: {
    symbol: "DFL-USDC",
    name: "DFL-USDC V4 LP",
    mint: "Fffijd6UVJdQeLVXhenS8YcsnMUdWJqpbBeH42LFkXgS",
    base: MAINNET_SPL_TOKENS.DFL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.DFL.decimals,
    version: 4
  },
  BOKU_USDC_V4: {
    symbol: "BOKU-USDC",
    name: "BOKU-USDC V4 LP",
    mint: "8jjQn5Yagb6Nm2WGAxPW1bcGqrTWpg5adf6QukXEarcP",
    base: MAINNET_SPL_TOKENS.BOKU,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.BOKU.decimals,
    version: 4
  },
  MIMO_SOL_V4: {
    symbol: "MIMO-SOL",
    name: "MIMO-SOL V4 LP",
    mint: "HUJ1opSk8AiPfDT47r7n4hTiK2EXgrR3Msy7T8q1BywS",
    base: MAINNET_SPL_TOKENS.MIMO,
    quote: MAINNET_SPL_TOKENS.WSOL,
    decimals: MAINNET_SPL_TOKENS.MIMO.decimals,
    version: 4
  },
  wbWBNB_USDC_V4: {
    symbol: "wbWBNB-USDC",
    name: "wbWBNB-USDC V4 LP",
    mint: "FEsEfEJJSfiMQcshUgZ5UigfytfGRQ3z5puyF6DXDp9C",
    base: MAINNET_SPL_TOKENS.wbWBNB,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.wbWBNB.decimals,
    version: 4
  },
  wePEOPLE_USDC_V4: {
    symbol: "wePEOPLE-USDC",
    name: "wePEOPLE-USDC V4 LP",
    mint: "3e5ZCKi4etorpV4pv1fSckP5iJD67xcUkx3RtFCZhbzD",
    base: MAINNET_SPL_TOKENS.wePEOPLE,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.wePEOPLE.decimals,
    version: 4
  },
  ISOLA_USDT_V4: {
    symbol: "ISOLA-USDT",
    name: "ISOLA-USDT V4 LP",
    mint: "H8s1wQsZpRK61pyLF3XwyQc6E8vNUnwRDhy3TBDCDENQ",
    base: MAINNET_SPL_TOKENS.ISOLA,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.ISOLA.decimals,
    version: 4
  },
  SPWN_USDC_V4: {
    symbol: "SPWN-USDC",
    name: "SPWN-USDC V4 LP",
    mint: "B5uyCAQcX6nAjZypLgiivbEKabSptgUb8JK9tkaSnqdW",
    base: MAINNET_SPL_TOKENS.SPWN,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SPWN.decimals,
    version: 4
  },
  STR_USDC_V4: {
    symbol: "STR-USDC",
    name: "STR-USDC V4 LP",
    mint: "8uDVKmVwNmbXHDB7rNKqtpcT9VAsFHTJ5pPYxjyoBbNg",
    base: MAINNET_SPL_TOKENS.STR,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.STR.decimals,
    version: 4
  },
  SOLC_USDT_V4: {
    symbol: "SOLC-USDT",
    name: "SOLC-USDT V4 LP",
    mint: "2g9JzTWycLzK4KEBBHsponAtZRee2ii63bRrJ8tefEyt",
    base: MAINNET_SPL_TOKENS.SOLC,
    quote: MAINNET_SPL_TOKENS.USDT,
    decimals: MAINNET_SPL_TOKENS.SOLC.decimals,
    version: 4
  },
  VI_USDC_V4: {
    symbol: "VI-USDC",
    name: "VI-USDC V4 LP",
    mint: "3MwHyHCRfVqtH3ABFtdKXdY9dwemr9GGxQFaBkeq6NjY",
    base: MAINNET_SPL_TOKENS.VI,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.VI.decimals,
    version: 4
  },
  KKO_USDC_V4: {
    symbol: "KKO-USDC",
    name: "KKO-USDC V4 LP",
    mint: "7xr1Doc1NiMWbUg99YVFqQSLfYXNzo6YvacXUsSgBMNW",
    base: MAINNET_SPL_TOKENS.KKO,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.KKO.decimals,
    version: 4
  },
  XTAG_USDC_V4: {
    symbol: "XTAG-USDC",
    name: "XTAG-USDC V4 LP",
    mint: "GCEQbLg4ik5YJ4CMcbtuVqEc4sjLdSGy34rFk1CtGjdg",
    base: MAINNET_SPL_TOKENS.XTAG,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.XTAG.decimals,
    version: 4
  },
  TTT_USDC_V4: {
    symbol: "TTT-USDC",
    name: "TTT-USDC V4 LP",
    mint: "84fmrerHGohoRf4iLPDQ1KG4CjSjCRksYWGzjWfCRM8a",
    base: MAINNET_SPL_TOKENS.TTT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.TTT.decimals,
    version: 4
  },
  RUN_USDC_V4: {
    symbol: "RUN-USDC",
    name: "RUN-USDC V4 LP",
    mint: "CjTLvvKSQdEujcSzeZRYgk4w1DpuXBbMppLHaxZyz11Y",
    base: MAINNET_SPL_TOKENS.RUN,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.RUN.decimals,
    version: 4
  },
  CRWNY_USDC_V4: {
    symbol: "CRWNY-USDC",
    name: "CRWNY-USDC V4 LP",
    mint: "H3D9Gyi4frRLW6bS9vBthDVDJyzyRJ6XhhpP6PJGWaDC",
    base: MAINNET_SPL_TOKENS.CRWNY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CRWNY.decimals,
    version: 4
  },
  CRWNY_RAY_V4: {
    symbol: "CRWNY-RAY",
    name: "CRWNY-RAY V4 LP",
    mint: "5Cz9wGStNjiUg81q8t6sJJeckuT2C14CYSfyQbtYirSX",
    base: MAINNET_SPL_TOKENS.CRWNY,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.CRWNY.decimals,
    version: 4
  },
  BLOCK_USDC_V4: {
    symbol: "BLOCK-USDC",
    name: "BLOCK-USDC V4 LP",
    mint: "8i44Y23GkkwDYZ5iSkVEqmrXUfwNmwo9grguTDWKM8wg",
    base: MAINNET_SPL_TOKENS.BLOCK,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.BLOCK.decimals,
    version: 4
  },
  REAL_USDC_V4: {
    symbol: "REAL-USDC",
    name: "REAL-USDC V4 LP",
    mint: "EN43tp8xdkcM8RYSJ4msFHMPTJRXKhUteVYBDJLwTvr3",
    base: MAINNET_SPL_TOKENS.REAL,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.REAL.decimals,
    version: 4
  },
  FRKT_USDC_V4: {
    symbol: "FRKT-USDC",
    name: "FRKT-USDC V4 LP",
    mint: "7MgzqVTGeA4wENme81QPTrPy45NJMKVL9XGwxmNT87cG",
    base: MAINNET_SPL_TOKENS.FRKT,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.FRKT.decimals,
    version: 4
  },
  MBS_USDC_V4: {
    symbol: "MBS-USDC",
    name: "MBS-USDC V4 LP",
    mint: "BAgSWaPZpsQKyZJdvB5KyvmCNj6hzczzentt5FhDCVHb",
    base: MAINNET_SPL_TOKENS.MBS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.MBS.decimals,
    version: 4
  },
  PRISM_USDC_V4: {
    symbol: "PRISM-USDC",
    name: "PRISM-USDC V4 LP",
    mint: "3baYkTcudvSFMe25UpZcBfdp4FA5kL2E4pfaeJ8AiYJB",
    base: MAINNET_SPL_TOKENS.PRISM,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.PRISM.decimals,
    version: 4
  },
  CHICKS_USDC_V4: {
    symbol: "CHICKS-USDC",
    name: "CHICKS-USDC V4 LP",
    mint: "CPzmcw81a6PDasSXhVLfDRKuTJXZPUqocS9VFf5zCFhs",
    base: MAINNET_SPL_TOKENS.CHICKS,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.CHICKS.decimals,
    version: 4
  },
  MEAN_RAY_V4: {
    symbol: "MEAN-RAY",
    name: "MEAN-RAY V4 LP",
    mint: "H9wUyrxpAErmdNVPitpHSXgwoomoh91ggJKPWtQQoCn1",
    base: MAINNET_SPL_TOKENS.MEAN,
    quote: MAINNET_SPL_TOKENS.RAY,
    decimals: MAINNET_SPL_TOKENS.MEAN.decimals,
    version: 4
  },
  TINY_USDC_V4: {
    symbol: "TINY-USDC",
    name: "TINY-USDC V4 LP",
    mint: "Hho6ZzRDj49L4z6zog8nQZFaxMSz6FX6wNzVpMeAMen",
    base: MAINNET_SPL_TOKENS.TINY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.TINY.decimals,
    version: 4
  },
  SCY_USDC_V4: {
    symbol: "SCY-USDC",
    name: "SCY-USDC V4 LP",
    mint: "EcYk7t6Vw59HDnY2u6H1KDPkk8juMeA1NpGpHiGk1LDf",
    base: MAINNET_SPL_TOKENS.SCY,
    quote: MAINNET_SPL_TOKENS.USDC,
    decimals: MAINNET_SPL_TOKENS.SCY.decimals,
    version: 4
  }
};
var TESTNET_SPL_TOKENS = {
  WSOL: __spreadValues({}, WSOL)
};
var TESTNET_LP_TOKENS = {};
var logger4 = Logger.from("token/util");
var TokenList = class {
  constructor(tokenList) {
    this.tokenList = tokenList;
    this.filterByMint = (mint) => {
      return this.tokenList.filter((token) => token.mint === mint);
    };
    this.filterUniqueByMint = (mint, tokenType = "all") => {
      const result = this.tokenList.filter((token2) => token2.mint === mint);
      if (result.length === 0) {
        return logger4.throwArgumentError(`No token found`, "mint", mint);
      } else if (result.length > 1) {
        return logger4.throwArgumentError(`Multiple tokens found: ${result.length}`, "mint", mint);
      }
      const token = result[0];
      if (tokenType === "spl" && "version" in token) {
        return logger4.throwArgumentError("invalid SPL token mint", "mint", mint);
      } else if (tokenType === "lp" && !("version" in token)) {
        return logger4.throwArgumentError("invalid LP token mint", "mint", mint);
      }
      return token;
    };
    this.getList = () => {
      return this.tokenList;
    };
  }
};
var _Currency = class _Currency2 {
  /**
   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.SOL`.
   * @param decimals - decimals of the currency
   * @param symbol - symbol of the currency
   * @param name - name of the currency
   */
  constructor(decimals, symbol = "UNKNOWN", name = "UNKNOWN") {
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name;
  }
};
_Currency.SOL = new _Currency(SOL.decimals, SOL.symbol, SOL.name);
var Currency = _Currency;
function inspectCurrency() {
  Currency.prototype.inspect = function() {
    return `<Currency: decimals=${this.decimals}, name=${this.name}, symbol=${this.symbol}>`;
  };
}
var _Token = class _Token2 extends Currency {
  constructor(programId, mint, decimals, symbol = "UNKNOWN", name = "UNKNOWN") {
    super(decimals, symbol, name);
    this.programId = validateAndParsePublicKey(programId);
    this.mint = validateAndParsePublicKey(mint);
  }
  /**
   * Returns true if the two tokens are equivalent, i.e. have the same mint address.
   * @param other - other token to compare
   */
  equals(other) {
    if (this === other) {
      return true;
    }
    return this.mint.equals(other.mint);
  }
};
_Token.WSOL = new _Token(TOKEN_PROGRAM_ID, WSOL.mint, WSOL.decimals, SOL.symbol, SOL.name);
var Token = _Token;
function inspectToken() {
  Token.prototype.inspect = function() {
    return `<Token: mint=${this.mint.toBase58()}, decimals=${this.decimals}, name=${this.name}, symbol=${this.symbol}>`;
  };
}
function currencyEquals(currencyA, currencyB) {
  if (currencyA instanceof Token && currencyB instanceof Token) {
    return currencyA.equals(currencyB);
  } else if (currencyA instanceof Token || currencyB instanceof Token) {
    return false;
  } else {
    return currencyA === currencyB;
  }
}
var toFormat = import_toformat.default;
var to_format_default = toFormat;
var logger5 = Logger.from("entity/fraction");
var Big2 = to_format_default(big_default);
var Decimal2 = to_format_default(decimal_default);
var toSignificantRounding = {
  [
    0
    /* ROUND_DOWN */
  ]: Decimal2.ROUND_DOWN,
  [
    1
    /* ROUND_HALF_UP */
  ]: Decimal2.ROUND_HALF_UP,
  [
    2
    /* ROUND_UP */
  ]: Decimal2.ROUND_UP
};
var toFixedRounding = {
  [
    0
    /* ROUND_DOWN */
  ]: Big2.roundDown,
  [
    1
    /* ROUND_HALF_UP */
  ]: Big2.roundHalfUp,
  [
    2
    /* ROUND_UP */
  ]: Big2.roundUp
};
var Fraction = class _Fraction {
  constructor(numerator, denominator = ONE) {
    this.numerator = parseBigNumberish(numerator);
    this.denominator = parseBigNumberish(denominator);
  }
  // performs floor division
  get quotient() {
    return this.numerator.div(this.denominator);
  }
  invert() {
    return new _Fraction(this.denominator, this.numerator);
  }
  // +
  add(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish(other));
    if (this.denominator.eq(otherParsed.denominator)) {
      return new _Fraction(this.numerator.add(otherParsed.numerator), this.denominator);
    }
    return new _Fraction(
      this.numerator.mul(otherParsed.denominator).add(otherParsed.numerator.mul(this.denominator)),
      this.denominator.mul(otherParsed.denominator)
    );
  }
  // -
  sub(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish(other));
    if (this.denominator.eq(otherParsed.denominator)) {
      return new _Fraction(this.numerator.sub(otherParsed.numerator), this.denominator);
    }
    return new _Fraction(
      this.numerator.mul(otherParsed.denominator).sub(otherParsed.numerator.mul(this.denominator)),
      this.denominator.mul(otherParsed.denominator)
    );
  }
  // 
  mul(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish(other));
    return new _Fraction(this.numerator.mul(otherParsed.numerator), this.denominator.mul(otherParsed.denominator));
  }
  // 
  div(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigNumberish(other));
    return new _Fraction(this.numerator.mul(otherParsed.denominator), this.denominator.mul(otherParsed.numerator));
  }
  toSignificant(significantDigits, format = { groupSeparator: "" }, rounding = 1) {
    logger5.assert(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`);
    logger5.assert(significantDigits > 0, `${significantDigits} is not positive.`);
    Decimal2.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] });
    const quotient = new Decimal2(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  }
  toFixed(decimalPlaces, format = { groupSeparator: "" }, rounding = 1) {
    logger5.assert(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`);
    logger5.assert(decimalPlaces >= 0, `${decimalPlaces} is negative.`);
    Big2.DP = decimalPlaces;
    Big2.RM = toFixedRounding[rounding];
    return new Big2(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  }
};
var logger6 = Logger.from("entity/amount");
var Big22 = to_format_default(big_default);
function splitNumber(num, decimals) {
  let integral = "0";
  let fractional = "0";
  if (num.includes(".")) {
    const splited = num.split(".");
    if (splited.length === 2) {
      ;
      [integral, fractional] = splited;
      fractional = fractional.padEnd(decimals, "0");
    } else {
      return logger6.throwArgumentError("invalid number string", "num", num);
    }
  } else {
    integral = num;
  }
  return [integral, fractional.slice(0, decimals) || fractional];
}
var CurrencyAmount = class _CurrencyAmount extends Fraction {
  constructor(currency, amount, isRaw = true) {
    let parsedAmount = new import_bn.default(0);
    const multiplier = TEN.pow(new import_bn.default(currency.decimals));
    if (isRaw) {
      parsedAmount = parseBigNumberish(amount);
    } else {
      let integralAmount = new import_bn.default(0);
      let fractionalAmount = new import_bn.default(0);
      if (typeof amount === "string" || typeof amount === "number" || typeof amount === "bigint") {
        const [integral, fractional] = splitNumber(amount.toString(), currency.decimals);
        integralAmount = parseBigNumberish(integral);
        fractionalAmount = parseBigNumberish(fractional);
      }
      integralAmount = integralAmount.mul(multiplier);
      parsedAmount = integralAmount.add(fractionalAmount);
    }
    super(parsedAmount, multiplier);
    this.currency = currency;
  }
  get raw() {
    return this.numerator;
  }
  isZero() {
    return this.raw.isZero();
  }
  /**
   * a greater than b
   */
  gt(other) {
    logger6.assert(currencyEquals(this.currency, other.currency), "gt currency not equals");
    return this.raw.gt(other.raw);
  }
  /**
   * a less than b
   */
  lt(other) {
    logger6.assert(currencyEquals(this.currency, other.currency), "lt currency not equals");
    return this.raw.lt(other.raw);
  }
  add(other) {
    logger6.assert(currencyEquals(this.currency, other.currency), "add currency not equals");
    return new _CurrencyAmount(this.currency, this.raw.add(other.raw));
  }
  sub(other) {
    logger6.assert(currencyEquals(this.currency, other.currency), "sub currency not equals");
    return new _CurrencyAmount(this.currency, this.raw.sub(other.raw));
  }
  toSignificant(significantDigits = this.currency.decimals, format, rounding = 0) {
    return super.toSignificant(significantDigits, format, rounding);
  }
  /**
   * To fixed
   *
   * @example
   * ```
   * 1 -> 1.000000000
   * 1.234 -> 1.234000000
   * 1.123456789876543 -> 1.123456789
   * ```
   */
  toFixed(decimalPlaces = this.currency.decimals, format, rounding = 0) {
    logger6.assert(decimalPlaces <= this.currency.decimals, "decimals overflow");
    return super.toFixed(decimalPlaces, format, rounding);
  }
  /**
   * To exact
   *
   * @example
   * ```
   * 1 -> 1
   * 1.234 -> 1.234
   * 1.123456789876543 -> 1.123456789
   * ```
   */
  toExact(format = { groupSeparator: "" }) {
    Big22.DP = this.currency.decimals;
    return new Big22(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);
  }
};
var TokenAmount = class _TokenAmount extends CurrencyAmount {
  constructor(token, amount, isRaw = true) {
    super(token, amount, isRaw);
    this.token = token;
  }
  add(other) {
    logger6.assert(currencyEquals(this.token, other.token), "add token not equals");
    return new _TokenAmount(this.token, this.raw.add(other.raw));
  }
  subtract(other) {
    logger6.assert(currencyEquals(this.token, other.token), "sub token not equals");
    return new _TokenAmount(this.token, this.raw.sub(other.raw));
  }
};
var _100_PERCENT = new Fraction(_100);
var Percent = class extends Fraction {
  toSignificant(significantDigits = 5, format, rounding) {
    return this.mul(_100_PERCENT).toSignificant(significantDigits, format, rounding);
  }
  toFixed(decimalPlaces = 2, format, rounding) {
    return this.mul(_100_PERCENT).toFixed(decimalPlaces, format, rounding);
  }
};
var logger7 = Logger.from("entity/price");
var Price = class _Price extends Fraction {
  // denominator and numerator _must_ be raw, i.e. in the native representation
  constructor(baseCurrency, denominator, quoteCurrency, numerator) {
    super(numerator, denominator);
    this.baseCurrency = baseCurrency;
    this.quoteCurrency = quoteCurrency;
    this.scalar = new Fraction(tenExponentiate(baseCurrency.decimals), tenExponentiate(quoteCurrency.decimals));
  }
  get raw() {
    return new Fraction(this.numerator, this.denominator);
  }
  get adjusted() {
    return super.mul(this.scalar);
  }
  invert() {
    return new _Price(this.quoteCurrency, this.numerator, this.baseCurrency, this.denominator);
  }
  mul(other) {
    logger7.assert(currencyEquals(this.quoteCurrency, other.baseCurrency), "mul currency not equals");
    const fraction = super.mul(other);
    return new _Price(this.baseCurrency, fraction.denominator, other.quoteCurrency, fraction.numerator);
  }
  toSignificant(significantDigits = this.quoteCurrency.decimals, format, rounding) {
    return this.adjusted.toSignificant(significantDigits, format, rounding);
  }
  toFixed(decimalPlaces = this.quoteCurrency.decimals, format, rounding) {
    return this.adjusted.toFixed(decimalPlaces, format, rounding);
  }
};
var Layout = import_buffer_layout51.Layout;
var Structure = import_buffer_layout51.Structure;
var Union = import_buffer_layout51.Union;
var BitStructure = import_buffer_layout51.BitStructure;
var UInt = import_buffer_layout51.UInt;
var Blob = import_buffer_layout51.Blob;
var greedy2 = import_buffer_layout51.greedy;
var u842 = import_buffer_layout51.u8;
var u164 = import_buffer_layout51.u16;
var u24 = import_buffer_layout51.u24;
var u324 = import_buffer_layout51.u32;
var u40 = import_buffer_layout51.u40;
var u48 = import_buffer_layout51.u48;
var nu64 = import_buffer_layout51.nu64;
var u16be = import_buffer_layout51.u16be;
var u24be = import_buffer_layout51.u24be;
var u32be = import_buffer_layout51.u32be;
var u40be = import_buffer_layout51.u40be;
var u48be = import_buffer_layout51.u48be;
var nu64be = import_buffer_layout51.nu64be;
var s8 = import_buffer_layout51.s8;
var s163 = import_buffer_layout51.s16;
var s24 = import_buffer_layout51.s24;
var s32 = import_buffer_layout51.s32;
var s40 = import_buffer_layout51.s40;
var s48 = import_buffer_layout51.s48;
var ns642 = import_buffer_layout51.ns64;
var s16be = import_buffer_layout51.s16be;
var s24be = import_buffer_layout51.s24be;
var s32be = import_buffer_layout51.s32be;
var s40be = import_buffer_layout51.s40be;
var s48be = import_buffer_layout51.s48be;
var ns64be = import_buffer_layout51.ns64be;
var f32 = import_buffer_layout51.f32;
var f32be = import_buffer_layout51.f32be;
var f64 = import_buffer_layout51.f64;
var f64be = import_buffer_layout51.f64be;
var seq3 = import_buffer_layout51.seq;
var union = import_buffer_layout51.union;
var unionLayoutDiscriminator = import_buffer_layout51.unionLayoutDiscriminator;
var blob3 = import_buffer_layout51.blob;
var cstr = import_buffer_layout51.cstr;
var utf8 = import_buffer_layout51.utf8;
var bits = import_buffer_layout51.bits;
var offset = import_buffer_layout51.offset;
var BNLayout = class extends Layout {
  constructor(span, signed, property) {
    super(span, property);
    this.blob = blob3(span);
    this.signed = signed;
  }
  /** @override */
  decode(b, offset2 = 0) {
    const num = new import_bn6.default(this.blob.decode(b, offset2), 10, "le");
    if (this.signed) {
      return num.fromTwos(this.span * 8).clone();
    }
    return num;
  }
  /** @override */
  encode(src, b, offset2 = 0) {
    if (typeof src === "number") src = new import_bn6.default(src);
    if (this.signed) {
      src = src.toTwos(this.span * 8);
    }
    return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b, offset2);
  }
};
var WideBits = class extends Layout {
  // TODO: unknown
  constructor(property) {
    super(8, property);
    this._lower = bits(u324(), false);
    this._upper = bits(u324(), false);
  }
  addBoolean(property) {
    if (this._lower.fields.length < 32) {
      this._lower.addBoolean(property);
    } else {
      this._upper.addBoolean(property);
    }
  }
  decode(b, offset2 = 0) {
    const lowerDecoded = this._lower.decode(b, offset2);
    const upperDecoded = this._upper.decode(b, offset2 + this._lower.span);
    return __spreadValues(__spreadValues({}, lowerDecoded), upperDecoded);
  }
  encode(src, b, offset2 = 0) {
    return this._lower.encode(src, b, offset2) + this._upper.encode(src, b, offset2 + this._lower.span);
  }
};
function u8210(property) {
  return new UInt(1, property);
}
function u3222(property) {
  return new UInt(4, property);
}
function u642(property) {
  return new BNLayout(8, false, property);
}
function u128(property) {
  return new BNLayout(16, false, property);
}
function i8(property) {
  return new BNLayout(1, true, property);
}
function i64(property) {
  return new BNLayout(8, true, property);
}
function i128(property) {
  return new BNLayout(16, true, property);
}
var WrappedLayout = class extends Layout {
  constructor(layout, decoder, encoder, property) {
    super(layout.span, property);
    this.layout = layout;
    this.decoder = decoder;
    this.encoder = encoder;
  }
  decode(b, offset2) {
    return this.decoder(this.layout.decode(b, offset2));
  }
  encode(src, b, offset2) {
    return this.layout.encode(this.encoder(src), b, offset2);
  }
  getSpan(b, offset2) {
    return this.layout.getSpan(b, offset2);
  }
};
function publicKey2(property) {
  return new WrappedLayout(
    blob3(32),
    (b) => new PublicKey(b),
    (key) => key.toBuffer(),
    property
  );
}
var OptionLayout = class extends Layout {
  constructor(layout, property) {
    super(-1, property);
    this.layout = layout;
    this.discriminator = u842();
  }
  encode(src, b, offset2 = 0) {
    if (src === null || src === void 0) {
      return this.discriminator.encode(0, b, offset2);
    }
    this.discriminator.encode(1, b, offset2);
    return this.layout.encode(src, b, offset2 + 1) + 1;
  }
  decode(b, offset2 = 0) {
    const discriminator = this.discriminator.decode(b, offset2);
    if (discriminator === 0) {
      return null;
    } else if (discriminator === 1) {
      return this.layout.decode(b, offset2 + 1);
    }
    throw new Error("Invalid option " + this.property);
  }
  getSpan(b, offset2 = 0) {
    const discriminator = this.discriminator.decode(b, offset2);
    if (discriminator === 0) {
      return 1;
    } else if (discriminator === 1) {
      return this.layout.getSpan(b, offset2 + 1) + 1;
    }
    throw new Error("Invalid option " + this.property);
  }
};
function option(layout, property) {
  return new OptionLayout(layout, property);
}
function bool22(property) {
  return new WrappedLayout(u842(), decodeBool, encodeBool, property);
}
function decodeBool(value) {
  if (value === 0) {
    return false;
  } else if (value === 1) {
    return true;
  }
  throw new Error("Invalid bool: " + value);
}
function encodeBool(value) {
  return value ? 1 : 0;
}
function vec(elementLayout, property) {
  const length = u324("length");
  const layout = struct50([
    length,
    seq22(elementLayout, offset(length, -length.span), "values")
  ]);
  return new WrappedLayout(
    layout,
    ({ values }) => values,
    (values) => ({ values }),
    property
  );
}
function tagged(tag2, layout, property) {
  const wrappedLayout = struct50([u642("tag"), layout.replicate("data")]);
  function decodeTag({ tag: receivedTag, data }) {
    if (!receivedTag.eq(tag2)) {
      throw new Error("Invalid tag, expected: " + tag2.toString("hex") + ", got: " + receivedTag.toString("hex"));
    }
    return data;
  }
  return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag: tag2, data }), property);
}
function vecU8(property) {
  const length = u324("length");
  const layout = struct50([length, blob3(offset(length, -length.span), "data")]);
  return new WrappedLayout(
    layout,
    ({ data }) => data,
    (data) => ({ data }),
    property
  );
}
function str(property) {
  return new WrappedLayout(
    vecU8(),
    (data) => data.toString("utf-8"),
    (s) => Buffer.from(s, "utf-8"),
    property
  );
}
function rustEnum(variants, property) {
  const unionLayout = union(u842(), property);
  variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
  return unionLayout;
}
function array(elementLayout, length, property) {
  const layout = struct50([seq22(elementLayout, length, "values")]);
  return new WrappedLayout(
    layout,
    ({ values }) => values,
    (values) => ({ values }),
    property
  );
}
var Structure2 = class extends Structure {
  /** @override */
  decode(b, offset2) {
    return super.decode(b, offset2);
  }
};
function struct50(fields, property, decodePrefixes) {
  return new Structure2(fields, property, decodePrefixes);
}
var Union2 = class extends Union {
  encodeInstruction(instruction) {
    const instructionMaxSpan = Math.max(...Object.values(this.registry).map((r) => r.span));
    const b = Buffer.alloc(instructionMaxSpan);
    return b.slice(0, this.encode(instruction, b));
  }
  decodeInstruction(instruction) {
    return this.decode(instruction);
  }
};
function union2(discr, defaultLayout, property) {
  return new Union2(discr, defaultLayout, property);
}
var Zeros = class extends Blob {
  decode(b, offset2) {
    const slice = super.decode(b, offset2);
    if (!slice.every((v) => v === 0)) {
      throw new Error("nonzero padding bytes");
    }
    return slice;
  }
};
function zeros(length) {
  return new Zeros(length);
}
function seq22(elementLayout, count, property) {
  let parsedCount;
  const superCount = typeof count === "number" ? count : (0, import_bn6.isBN)(count) ? count.toNumber() : new Proxy(count, {
    get(target, property2) {
      if (!parsedCount) {
        const countProperty = Reflect.get(target, "count");
        parsedCount = (0, import_bn6.isBN)(countProperty) ? countProperty.toNumber() : countProperty;
        Reflect.set(target, "count", parsedCount);
      }
      return Reflect.get(target, property2);
    },
    set(target, property2, value) {
      if (property2 === "count") {
        parsedCount = value;
      }
      return Reflect.set(target, property2, value);
    }
  });
  return seq3(elementLayout, superCount, property);
}
var SPL_MINT_LAYOUT = struct50([
  u3222("mintAuthorityOption"),
  publicKey2("mintAuthority"),
  u642("supply"),
  u8210("decimals"),
  u8210("isInitialized"),
  u3222("freezeAuthorityOption"),
  publicKey2("freezeAuthority")
]);
var SPL_ACCOUNT_LAYOUT = struct50([
  publicKey2("mint"),
  publicKey2("owner"),
  u642("amount"),
  u3222("delegateOption"),
  publicKey2("delegate"),
  u8210("state"),
  u3222("isNativeOption"),
  u642("isNative"),
  u642("delegatedAmount"),
  u3222("closeAuthorityOption"),
  publicKey2("closeAuthority")
]);
function getATAAddress(owner, mint, programId) {
  return findProgramAddress(
    [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],
    new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL")
  );
}
var Spl = class {
  static getAssociatedTokenAccount({
    mint,
    owner,
    programId
  }) {
    return getATAAddress(owner, mint, programId).publicKey;
  }
  static makeCreateAssociatedTokenAccountInstruction({
    programId,
    mint,
    associatedAccount,
    owner,
    payer,
    instructionsType
  }) {
    instructionsType.push(
      2
      /* createATA */
    );
    return createAssociatedTokenAccountInstruction(payer, associatedAccount, owner, mint, programId);
  }
  // https://github.com/solana-labs/solana-program-library/blob/master/token/js/client/token.js
  static makeCreateWrappedNativeAccountInstructions(_0) {
    return __async(this, arguments, function* ({
      connection,
      owner,
      payer,
      amount,
      // baseRentExemption,
      commitment
    }) {
      const instructions = [];
      const instructionTypes = [];
      const balanceNeeded = yield connection.getMinimumBalanceForRentExemption(SPL_ACCOUNT_LAYOUT.span, commitment);
      const lamports = parseBigNumberish(amount).add(new import_bn7.default(balanceNeeded));
      const newAccount = generatePubKey({ fromPublicKey: payer, programId: TOKEN_PROGRAM_ID });
      instructions.push(
        SystemProgram.createAccountWithSeed({
          fromPubkey: payer,
          basePubkey: payer,
          seed: newAccount.seed,
          newAccountPubkey: newAccount.publicKey,
          lamports: lamports.toNumber(),
          space: SPL_ACCOUNT_LAYOUT.span,
          programId: TOKEN_PROGRAM_ID
        })
      );
      instructionTypes.push(
        0
        /* createAccount */
      );
      instructions.push(
        this.makeInitAccountInstruction({
          programId: TOKEN_PROGRAM_ID,
          mint: validateAndParsePublicKey(WSOL.mint),
          tokenAccount: newAccount.publicKey,
          owner,
          instructionTypes
        })
      );
      return {
        address: { newAccount: newAccount.publicKey },
        innerTransaction: {
          instructions,
          signers: [],
          lookupTableAddress: [],
          instructionTypes
        }
      };
    });
  }
  static insertCreateWrappedNativeAccount(_0) {
    return __async(this, arguments, function* ({
      connection,
      owner,
      payer,
      amount,
      instructions,
      instructionsType,
      signers,
      commitment
    }) {
      const ins = yield this.makeCreateWrappedNativeAccountInstructions({
        connection,
        owner,
        payer,
        amount,
        commitment
      });
      instructions.push(...ins.innerTransaction.instructions);
      signers.push(...ins.innerTransaction.signers);
      instructionsType.push(...ins.innerTransaction.instructionTypes);
      return ins.address.newAccount;
    });
  }
  static makeInitMintInstruction({
    programId,
    mint,
    decimals,
    mintAuthority,
    freezeAuthority = null,
    instructionTypes
  }) {
    instructionTypes.push(
      5
      /* initMint */
    );
    return createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId);
  }
  static makeMintToInstruction({
    programId,
    mint,
    dest,
    authority,
    amount,
    multiSigners = [],
    instructionTypes
  }) {
    instructionTypes.push(
      6
      /* mintTo */
    );
    return createMintToInstruction(mint, dest, authority, BigInt(String(amount)), multiSigners, programId);
  }
  static makeInitAccountInstruction({
    programId,
    mint,
    tokenAccount,
    owner,
    instructionTypes
  }) {
    instructionTypes.push(
      1
      /* initAccount */
    );
    return createInitializeAccountInstruction(tokenAccount, mint, owner, programId);
  }
  static makeTransferInstruction({
    programId,
    source,
    destination,
    owner,
    amount,
    multiSigners = [],
    instructionsType
  }) {
    instructionsType.push(
      4
      /* transferAmount */
    );
    return createTransferInstruction(source, destination, owner, BigInt(String(amount)), multiSigners, programId);
  }
  static makeCloseAccountInstruction({
    programId,
    tokenAccount,
    owner,
    payer,
    multiSigners = [],
    instructionsType
  }) {
    instructionsType.push(
      3
      /* closeAccount */
    );
    return createCloseAccountInstruction(tokenAccount, payer, owner, multiSigners, programId);
  }
  static createInitAccountInstruction(programId, mint, account, owner) {
    const keys = [
      {
        pubkey: account,
        isSigner: false,
        isWritable: true
      },
      {
        pubkey: mint,
        isSigner: false,
        isWritable: false
      },
      {
        pubkey: owner,
        isSigner: false,
        isWritable: false
      },
      {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }
    ];
    const dataLayout = u8210("instruction");
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode(1, data);
    return new TransactionInstruction({
      keys,
      programId,
      data
    });
  }
};
var TxVersion = ((TxVersion8) => {
  TxVersion8[TxVersion8["V0"] = 0] = "V0";
  TxVersion8[TxVersion8["LEGACY"] = 1] = "LEGACY";
  return TxVersion8;
})(TxVersion || {});
var InstructionType = ((InstructionType2) => {
  InstructionType2[InstructionType2["createAccount"] = 0] = "createAccount";
  InstructionType2[InstructionType2["initAccount"] = 1] = "initAccount";
  InstructionType2[InstructionType2["createATA"] = 2] = "createATA";
  InstructionType2[InstructionType2["closeAccount"] = 3] = "closeAccount";
  InstructionType2[InstructionType2["transferAmount"] = 4] = "transferAmount";
  InstructionType2[InstructionType2["initMint"] = 5] = "initMint";
  InstructionType2[InstructionType2["mintTo"] = 6] = "mintTo";
  InstructionType2[InstructionType2["initMarket"] = 7] = "initMarket";
  InstructionType2[InstructionType2["util1216OwnerClaim"] = 8] = "util1216OwnerClaim";
  InstructionType2[InstructionType2["setComputeUnitPrice"] = 9] = "setComputeUnitPrice";
  InstructionType2[InstructionType2["setComputeUnitLimit"] = 10] = "setComputeUnitLimit";
  InstructionType2[InstructionType2["clmmCreatePool"] = 11] = "clmmCreatePool";
  InstructionType2[InstructionType2["clmmOpenPosition"] = 12] = "clmmOpenPosition";
  InstructionType2[InstructionType2["clmmIncreasePosition"] = 13] = "clmmIncreasePosition";
  InstructionType2[InstructionType2["clmmDecreasePosition"] = 14] = "clmmDecreasePosition";
  InstructionType2[InstructionType2["clmmClosePosition"] = 15] = "clmmClosePosition";
  InstructionType2[InstructionType2["clmmSwapBaseIn"] = 16] = "clmmSwapBaseIn";
  InstructionType2[InstructionType2["clmmSwapBaseOut"] = 17] = "clmmSwapBaseOut";
  InstructionType2[InstructionType2["clmmInitReward"] = 18] = "clmmInitReward";
  InstructionType2[InstructionType2["clmmSetReward"] = 19] = "clmmSetReward";
  InstructionType2[InstructionType2["clmmCollectReward"] = 20] = "clmmCollectReward";
  InstructionType2[InstructionType2["ammV4Swap"] = 21] = "ammV4Swap";
  InstructionType2[InstructionType2["ammV4AddLiquidity"] = 22] = "ammV4AddLiquidity";
  InstructionType2[InstructionType2["ammV4RemoveLiquidity"] = 23] = "ammV4RemoveLiquidity";
  InstructionType2[InstructionType2["ammV4SimulatePoolInfo"] = 24] = "ammV4SimulatePoolInfo";
  InstructionType2[InstructionType2["ammV4SwapBaseIn"] = 25] = "ammV4SwapBaseIn";
  InstructionType2[InstructionType2["ammV4SwapBaseOut"] = 26] = "ammV4SwapBaseOut";
  InstructionType2[InstructionType2["ammV4CreatePool"] = 27] = "ammV4CreatePool";
  InstructionType2[InstructionType2["ammV4InitPool"] = 28] = "ammV4InitPool";
  InstructionType2[InstructionType2["ammV4CreatePoolV2"] = 29] = "ammV4CreatePoolV2";
  InstructionType2[InstructionType2["ammV5AddLiquidity"] = 30] = "ammV5AddLiquidity";
  InstructionType2[InstructionType2["ammV5RemoveLiquidity"] = 31] = "ammV5RemoveLiquidity";
  InstructionType2[InstructionType2["ammV5SimulatePoolInfo"] = 32] = "ammV5SimulatePoolInfo";
  InstructionType2[InstructionType2["ammV5SwapBaseIn"] = 33] = "ammV5SwapBaseIn";
  InstructionType2[InstructionType2["ammV5SwapBaseOut"] = 34] = "ammV5SwapBaseOut";
  InstructionType2[InstructionType2["routeSwap"] = 35] = "routeSwap";
  InstructionType2[InstructionType2["routeSwap1"] = 36] = "routeSwap1";
  InstructionType2[InstructionType2["routeSwap2"] = 37] = "routeSwap2";
  InstructionType2[InstructionType2["farmV3Deposit"] = 38] = "farmV3Deposit";
  InstructionType2[InstructionType2["farmV3Withdraw"] = 39] = "farmV3Withdraw";
  InstructionType2[InstructionType2["farmV3CreateLedger"] = 40] = "farmV3CreateLedger";
  InstructionType2[InstructionType2["farmV5Deposit"] = 41] = "farmV5Deposit";
  InstructionType2[InstructionType2["farmV5Withdraw"] = 42] = "farmV5Withdraw";
  InstructionType2[InstructionType2["farmV5CreateLedger"] = 43] = "farmV5CreateLedger";
  InstructionType2[InstructionType2["farmV6Deposit"] = 44] = "farmV6Deposit";
  InstructionType2[InstructionType2["farmV6Withdraw"] = 45] = "farmV6Withdraw";
  InstructionType2[InstructionType2["farmV6Create"] = 46] = "farmV6Create";
  InstructionType2[InstructionType2["farmV6Restart"] = 47] = "farmV6Restart";
  InstructionType2[InstructionType2["farmV6CreatorAddReward"] = 48] = "farmV6CreatorAddReward";
  InstructionType2[InstructionType2["farmV6CreatorWithdraw"] = 49] = "farmV6CreatorWithdraw";
  InstructionType2[InstructionType2["test"] = 50] = "test";
  return InstructionType2;
})(InstructionType || {});
var Base = class {
  static _selectTokenAccount(params) {
    const { tokenAccounts, programId, mint, owner, config: config2 } = params;
    const { associatedOnly } = __spreadValues(__spreadValues({}, { associatedOnly: true }), config2);
    const _tokenAccounts = tokenAccounts.filter(({ accountInfo }) => accountInfo.mint.equals(mint)).sort((a, b) => a.accountInfo.amount.lt(b.accountInfo.amount) ? 1 : -1);
    const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
    for (const tokenAccount of _tokenAccounts) {
      const { pubkey } = tokenAccount;
      if (associatedOnly) {
        if (ata.equals(pubkey)) return pubkey;
      } else {
        return pubkey;
      }
    }
    return null;
  }
  static _handleTokenAccount(params) {
    return __async(this, null, function* () {
      const {
        connection,
        side,
        amount,
        programId,
        mint,
        tokenAccount,
        owner,
        payer = owner,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        endInstructionsType,
        checkCreateATAOwner
      } = params;
      const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
      if (Token.WSOL.mint.equals(mint)) {
        const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
          connection,
          owner,
          payer,
          instructions: frontInstructions,
          instructionsType: frontInstructionsType,
          signers,
          amount
        });
        if (endInstructions) {
          endInstructions.push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              tokenAccount: newTokenAccount,
              owner,
              payer,
              instructionsType: endInstructionsType != null ? endInstructionsType : []
            })
          );
        }
        return newTokenAccount;
      } else if (!tokenAccount || side === "out" && !ata.equals(tokenAccount) && !bypassAssociatedCheck) {
        const _createATAIns = Spl.makeCreateAssociatedTokenAccountInstruction({
          programId,
          mint,
          associatedAccount: ata,
          owner,
          payer,
          instructionsType: frontInstructionsType
        });
        if (checkCreateATAOwner) {
          const ataInfo = yield connection.getAccountInfo(ata);
          if (ataInfo === null) {
            frontInstructions.push(_createATAIns);
          } else if (ataInfo.owner.equals(TOKEN_PROGRAM_ID) && AccountLayout.decode(ataInfo.data).mint.equals(mint) && AccountLayout.decode(ataInfo.data).owner.equals(owner)) {
          } else {
            throw Error(`create ata check error -> mint: ${mint.toString()}, ata: ${ata.toString()}`);
          }
        } else {
          frontInstructions.push(_createATAIns);
        }
        return ata;
      }
      return tokenAccount;
    });
  }
  static _selectOrCreateTokenAccount(params) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
      const { mint, tokenAccounts, createInfo, associatedOnly, owner, checkCreateATAOwner, programId } = params;
      const ata = Spl.getAssociatedTokenAccount({ mint, owner, programId });
      const accounts = tokenAccounts.filter((i) => i.accountInfo.mint.equals(mint) && (!associatedOnly || i.pubkey.equals(ata))).sort((a, b) => a.accountInfo.amount.lt(b.accountInfo.amount) ? 1 : -1);
      if (createInfo === void 0 || accounts.length > 0) {
        return accounts.length > 0 ? accounts[0].pubkey : void 0;
      }
      if (associatedOnly) {
        const _createATAIns = Spl.makeCreateAssociatedTokenAccountInstruction({
          programId,
          mint,
          associatedAccount: ata,
          owner,
          payer: createInfo.payer,
          instructionsType: createInfo.frontInstructionsType
        });
        if (checkCreateATAOwner) {
          const ataInfo = yield createInfo.connection.getAccountInfo(ata);
          if (ataInfo === null) {
            createInfo.frontInstructions.push(_createATAIns);
          } else if (ataInfo.owner.equals(programId) && AccountLayout.decode(ataInfo.data).mint.equals(mint) && AccountLayout.decode(ataInfo.data).owner.equals(owner)) {
          } else {
            throw Error(`create ata check error -> mint: ${mint.toString()}, ata: ${ata.toString()}`);
          }
        } else {
          createInfo.frontInstructions.push(_createATAIns);
        }
        if (mint.equals(Token.WSOL.mint) && createInfo.amount) {
          const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
            connection: createInfo.connection,
            owner,
            payer: createInfo.payer,
            instructions: createInfo.frontInstructions,
            instructionsType: createInfo.frontInstructionsType,
            signers: createInfo.signers,
            amount: (_a = createInfo.amount) != null ? _a : 0
          });
          ((_b = createInfo.endInstructions) != null ? _b : []).push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              tokenAccount: newTokenAccount,
              owner,
              payer: createInfo.payer,
              instructionsType: (_c = createInfo.endInstructionsType) != null ? _c : []
            })
          );
          if (createInfo.amount) {
            createInfo.frontInstructions.push(
              Spl.makeTransferInstruction({
                programId: TOKEN_PROGRAM_ID,
                source: newTokenAccount,
                destination: ata,
                owner,
                amount: createInfo.amount,
                instructionsType: createInfo.frontInstructionsType
              })
            );
          }
        }
        ;
        ((_d = createInfo.endInstructions) != null ? _d : []).push(
          Spl.makeCloseAccountInstruction({
            programId,
            tokenAccount: ata,
            owner,
            payer: createInfo.payer,
            instructionsType: (_e = createInfo.endInstructionsType) != null ? _e : []
          })
        );
        return ata;
      } else {
        if (mint.equals(Token.WSOL.mint)) {
          const newTokenAccount = yield Spl.insertCreateWrappedNativeAccount({
            connection: createInfo.connection,
            owner,
            payer: createInfo.payer,
            instructions: createInfo.frontInstructions,
            instructionsType: createInfo.frontInstructionsType,
            signers: createInfo.signers,
            amount: (_f = createInfo.amount) != null ? _f : 0
          });
          ((_g = createInfo.endInstructions) != null ? _g : []).push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              tokenAccount: newTokenAccount,
              owner,
              payer: createInfo.payer,
              instructionsType: (_h = createInfo.endInstructionsType) != null ? _h : []
            })
          );
          return newTokenAccount;
        } else {
          const newTokenAccount = generatePubKey({ fromPublicKey: owner, programId });
          const balanceNeeded = yield createInfo.connection.getMinimumBalanceForRentExemption(AccountLayout.span);
          const createAccountIns = SystemProgram.createAccountWithSeed({
            fromPubkey: owner,
            basePubkey: owner,
            seed: newTokenAccount.seed,
            newAccountPubkey: newTokenAccount.publicKey,
            lamports: balanceNeeded,
            space: AccountLayout.span,
            programId
          });
          const initAccountIns = Spl.createInitAccountInstruction(programId, mint, newTokenAccount.publicKey, owner);
          createInfo.frontInstructions.push(createAccountIns, initAccountIns);
          createInfo.frontInstructionsType.push(
            0,
            1
            /* initAccount */
          );
          ((_i = createInfo.endInstructions) != null ? _i : []).push(
            Spl.makeCloseAccountInstruction({
              programId,
              tokenAccount: newTokenAccount.publicKey,
              owner,
              payer: createInfo.payer,
              instructionsType: (_j = createInfo.endInstructionsType) != null ? _j : []
            })
          );
          return newTokenAccount.publicKey;
        }
      }
    });
  }
};
function generatePubKey({
  fromPublicKey,
  programId = TOKEN_PROGRAM_ID
}) {
  const seed = Keypair.generate().publicKey.toBase58().slice(0, 32);
  const publicKey22 = createWithSeed(fromPublicKey, seed, programId);
  return { publicKey: publicKey22, seed };
}
function createWithSeed(fromPublicKey, seed, programId) {
  const buffer = Buffer.concat([fromPublicKey.toBuffer(), Buffer.from(seed), programId.toBuffer()]);
  const publicKeyBytes = sha256(buffer);
  return new PublicKey(publicKeyBytes);
}
var LOOKUP_TABLE_CACHE = {
  "2immgwYNHBbyVQKVGCEkgWpi53bLwWNRMB5G2nbgYV17": new AddressLookupTableAccount({
    key: new PublicKey("2immgwYNHBbyVQKVGCEkgWpi53bLwWNRMB5G2nbgYV17"),
    state: AddressLookupTableAccount.deserialize(
      Buffer.from(
        "AQAAAP//////////d49+DAAAAAAAAQZMWvw7GUNJdaccNBVnb57OKakxL2BHLYvhRwVILRsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGRm/lIRcy/+ytunLDm+e8jOW7xfcSayxDmzpAAAAABt324ddloZPZy+FGzut5rBy0he1fWzeROoz1hX7/AKkG3fbh7nWP3hhCXbzkbM3athr8TYO5DSf+vfko2KGL/AVKU1D4XciC1hSlVnJ4iilt3x6rq9CmBniISTL07vagBqfVFxksXFEhjMlMPUrxf1ja7gibof1E49vZigAAAAAGp9UXGMd0yShWY5hpHV62i164o5tLbVxzVVshAAAAAIyXJY9OJInxuz0QKRSODYMLWhOZ2v8QhASOe9jb6fhZC3BlsePRfEU4nVJ/awTDzVi4bHMaoP21SbbRvAP4KUbIScv+6Yw2LHF/6K0ZjUPibbSWXCirYPGuuVl7zT789IUPLW4CpHr4JNCatp3ELXDLKMv6JJ+37le50lbBJ2LvDQdRqCgtphMF/imcN7mY5YRx2xE1A3MQ+L4QRaYK9u4GRfZP3LsAd00a+IkCpA22UNQMKdq5BFbJuwuOLqc8zxCTDlqxBG8J0HcxtfogQHDK06ukzfaXiNDKAob1MqBHS9lJxDYCwz8gd5DtFqNSTKG5l1zxIaKpDP/sffi2is1H9aKveyXSu5StXElYRl9SD5As0DHE4N0GLnf84/siiKXVyp4Ez121kLcUui/jLLFZEz/BwZK3Ilf9B9OcsEAeDMKAy2vjGSxQODgBz0QwGA+eP4ZjIjrIAQaXENv31QfLlOdXSRCkaybRniDHF4C8YcwhcvsqrOVuTP4B2Na+9wLdtrB31uz2rtlFI5kahdsnp/d1SrASDInYCtTYtdoke4kX+hoKWcEWM4Tle8pTUkUVv4BxS6fje/EzKBE4Qu9N9LMnrw/JNO0hqMVB4rk/2ou4AB1loQ7FZoPwut2o4KZB+0p9xnbrQKw038qjpHar+PyDwvxBRcu5hpHw3dguezeWv+IwvgW5icu8EGkhGa9AkFPPJT7VMSFb8xowveU=",
        "base64"
      )
    )
  })
};
function getWSOLAmount({ tokenAccounts }) {
  const WSOL_MINT = new PublicKey(WSOL.mint);
  const amounts = tokenAccounts.filter((i) => i.accountInfo.mint.equals(WSOL_MINT)).map((i) => i.accountInfo.amount);
  const amount = amounts.reduce((a, b) => a.add(b), new import_bn8.default(0));
  return amount;
}
function unwarpSol(_0) {
  return __async(this, arguments, function* ({
    ownerInfo,
    tokenAccounts,
    makeTxVersion,
    connection
  }) {
    const WSOL_MINT = new PublicKey(WSOL.mint);
    const instructionsInfo = tokenAccounts.filter((i) => i.accountInfo.mint.equals(WSOL_MINT)).map((i) => ({
      amount: i.accountInfo.amount,
      tx: Spl.makeCloseAccountInstruction({
        programId: TOKEN_PROGRAM_ID,
        tokenAccount: i.pubkey,
        owner: ownerInfo.wallet,
        payer: ownerInfo.payer,
        instructionsType: []
      })
    }));
    return {
      address: {},
      innerTransactions: yield splitTxAndSigners({
        connection,
        makeTxVersion,
        payer: ownerInfo.payer,
        innerTransaction: instructionsInfo.map((i) => ({
          instructionTypes: [
            3
            /* closeAccount */
          ],
          instructions: [i.tx],
          signers: []
        }))
      })
    };
  });
}
function buildSimpleTransaction(_0) {
  return __async(this, arguments, function* ({
    connection,
    makeTxVersion,
    payer,
    innerTransactions,
    recentBlockhash,
    addLookupTableInfo
  }) {
    var _a;
    if (makeTxVersion !== 0 && makeTxVersion !== 1) throw Error(" make tx version args error");
    const _recentBlockhash = recentBlockhash != null ? recentBlockhash : (yield connection.getLatestBlockhash()).blockhash;
    const txList = [];
    for (const itemIx of innerTransactions) {
      txList.push(
        _makeTransaction({
          makeTxVersion,
          instructions: itemIx.instructions,
          payer,
          recentBlockhash: _recentBlockhash,
          signers: itemIx.signers,
          lookupTableInfos: Object.values(__spreadValues(__spreadValues({}, addLookupTableInfo != null ? addLookupTableInfo : {}), (_a = itemIx.lookupTableAddress) != null ? _a : {}))
        })
      );
    }
    return txList;
  });
}
function buildTransaction(_0) {
  return __async(this, arguments, function* ({
    connection,
    makeTxVersion,
    payer,
    innerTransactions,
    recentBlockhash,
    lookupTableCache
  }) {
    var _a;
    if (makeTxVersion !== 0 && makeTxVersion !== 1) throw Error(" make tx version args error");
    const _recentBlockhash = recentBlockhash != null ? recentBlockhash : (yield connection.getLatestBlockhash()).blockhash;
    const _lookupTableCache = lookupTableCache != null ? lookupTableCache : {};
    const lta = [
      .../* @__PURE__ */ new Set([
        ...innerTransactions.map((i) => {
          var _a2;
          return (_a2 = i.lookupTableAddress) != null ? _a2 : [];
        }).flat().map((i) => i.toString())
      ])
    ];
    const needCacheLTA = [];
    for (const item of lta) {
      if (_lookupTableCache[item] === void 0) {
        needCacheLTA.push(new PublicKey(item));
      }
    }
    const lookupTableAccountsCache = needCacheLTA.length > 0 ? yield getMultipleLookupTableInfo({ connection, address: needCacheLTA }) : {};
    for (const [key, value] of Object.entries(lookupTableAccountsCache)) {
      _lookupTableCache[key] = value;
    }
    const txList = [];
    for (const itemIx of innerTransactions) {
      const _itemLTA = {};
      if (makeTxVersion === 0) {
        for (const item of (_a = itemIx.lookupTableAddress) != null ? _a : []) {
          _itemLTA[item.toString()] = _lookupTableCache[item.toString()];
        }
      }
      txList.push(
        _makeTransaction({
          makeTxVersion,
          instructions: itemIx.instructions,
          payer,
          recentBlockhash: _recentBlockhash,
          signers: itemIx.signers,
          lookupTableInfos: Object.values(_itemLTA)
        })
      );
    }
    return txList;
  });
}
function _makeTransaction({
  makeTxVersion,
  instructions,
  payer,
  recentBlockhash,
  signers,
  lookupTableInfos
}) {
  if (makeTxVersion === 1) {
    const tx = new Transaction();
    tx.add(...instructions);
    tx.feePayer = payer;
    tx.recentBlockhash = recentBlockhash;
    if (signers.length > 0) tx.sign(...signers);
    return tx;
  } else if (makeTxVersion === 0) {
    const transactionMessage = new TransactionMessage({
      payerKey: payer,
      recentBlockhash,
      instructions
    });
    const itemV = new VersionedTransaction(transactionMessage.compileToV0Message(lookupTableInfos));
    itemV.sign(signers);
    return itemV;
  } else {
    throw Error(" make tx version check error ");
  }
}
var POINT = 1e4;
function getTransferAmountFee(amount, feeConfig, epochInfo, addFee) {
  if (feeConfig === void 0) {
    return {
      amount,
      fee: void 0,
      expirationTime: void 0
    };
  }
  const nowFeeConfig = epochInfo.epoch < feeConfig.newerTransferFee.epoch ? feeConfig.olderTransferFee : feeConfig.newerTransferFee;
  const maxFee = new import_bn8.default(nowFeeConfig.maximumFee.toString());
  const expirationTime = epochInfo.epoch < feeConfig.newerTransferFee.epoch ? (Number(feeConfig.newerTransferFee.epoch) * epochInfo.slotsInEpoch - epochInfo.absoluteSlot) * 400 / 1e3 : void 0;
  if (addFee) {
    if (nowFeeConfig.transferFeeBasisPoints === POINT) {
      const nowMaxFee = new import_bn8.default(nowFeeConfig.maximumFee.toString());
      return {
        amount: amount.add(nowMaxFee),
        fee: nowMaxFee,
        expirationTime
      };
    } else {
      const _TAmount = BNDivCeil(amount.mul(new import_bn8.default(POINT)), new import_bn8.default(POINT - nowFeeConfig.transferFeeBasisPoints));
      const nowMaxFee = new import_bn8.default(nowFeeConfig.maximumFee.toString());
      const TAmount = _TAmount.sub(amount).gt(nowMaxFee) ? amount.add(nowMaxFee) : _TAmount;
      const _fee = BNDivCeil(TAmount.mul(new import_bn8.default(nowFeeConfig.transferFeeBasisPoints)), new import_bn8.default(POINT));
      const fee = _fee.gt(maxFee) ? maxFee : _fee;
      return {
        amount: TAmount,
        fee,
        expirationTime
      };
    }
  } else {
    const _fee = BNDivCeil(amount.mul(new import_bn8.default(nowFeeConfig.transferFeeBasisPoints)), new import_bn8.default(POINT));
    const fee = _fee.gt(maxFee) ? maxFee : _fee;
    return {
      amount,
      fee,
      expirationTime
    };
  }
}
function minExpirationTime(expirationTime1, expirationTime2) {
  if (expirationTime1 === void 0) return expirationTime2;
  if (expirationTime2 === void 0) return expirationTime1;
  return Math.min(expirationTime1, expirationTime2);
}
function fetchMultipleMintInfos(_0) {
  return __async(this, arguments, function* ({ connection, mints }) {
    var _a, _b;
    if (mints.length === 0) return {};
    const mintInfos = yield getMultipleAccountsInfoWithCustomFlags(
      connection,
      mints.map((i) => ({ pubkey: i }))
    );
    const mintK = {};
    for (const i of mintInfos) {
      const t = unpackMint(i.pubkey, i.accountInfo, (_a = i.accountInfo) == null ? void 0 : _a.owner);
      mintK[i.pubkey.toString()] = __spreadProps(__spreadValues({}, t), {
        feeConfig: (_b = getTransferFeeConfig(t)) != null ? _b : void 0
      });
    }
    return mintK;
  });
}
function BNDivCeil(bn1, bn2) {
  const { div: div2, mod: mod2 } = bn1.divmod(bn2);
  if (mod2.gt(ZERO)) {
    return div2.add(ONE);
  } else {
    return div2;
  }
}
var anchorDataBuf = {
  voterStakeRegistryCreateVoter: Buffer.from([6, 24, 245, 52, 243, 255, 148, 25]),
  // CreateVoter
  voterStakeRegistryCreateDepositEntry: Buffer.from([185, 131, 167, 186, 159, 125, 19, 67]),
  // CreateDepositEntry
  voterStakeRegistryDeposit: Buffer.from([242, 35, 198, 137, 82, 225, 242, 182]),
  // Deposit
  voterStakeRegistryWithdraw: Buffer.from([183, 18, 70, 156, 148, 109, 161, 34]),
  // Withdraw
  voterStakeRegistryUpdateVoterWeightRecord: Buffer.from([45, 185, 3, 36, 109, 190, 115, 169])
  // UpdateVoterWeightRecord
};
function governanceCreateTokenOwnerRecord(programId, realm, governingTokenOwner, governingTokenMint, payer, tokenOwnerRecordAddress) {
  const dataLayout = struct50([u8210("ins")]);
  const keys = [
    AccountMetaReadonly(realm, false),
    AccountMetaReadonly(governingTokenOwner, false),
    AccountMeta(tokenOwnerRecordAddress, false),
    AccountMetaReadonly(governingTokenMint, false),
    AccountMeta(payer, true),
    AccountMetaReadonly(SYSTEM_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode({ ins: 23 }, data);
  return new TransactionInstruction({
    keys,
    programId,
    data
  });
}
function voterStakeRegistryCreateVoter(programId, registrar, voter, voterWeightRecord, voterAuthority, payer, voterBump, voterWeightRecordBump) {
  const dataLayout = struct50([u8210("voterBump"), u8210("voterWeightRecordBump")]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMeta(voter, false),
    AccountMetaReadonly(voterAuthority, true),
    AccountMeta(voterWeightRecord, false),
    AccountMeta(payer, true),
    AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
    AccountMetaReadonly(RENT_PROGRAM_ID, false),
    AccountMetaReadonly(INSTRUCTION_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode({ voterBump, voterWeightRecordBump }, data);
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryCreateVoter, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function voterStakeRegistryCreateDepositEntry(programId, registrar, voter, voterVault, voterAuthority, payer, depositMint, depositEntryIndex, kind, startTs, periods, allowClawback) {
  const dataLayout = struct50([
    u8210("depositEntryIndex"),
    u8210("kind"),
    u8210("option"),
    u642("startTs"),
    u3222("periods"),
    bool22("allowClawback")
  ]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMeta(voter, false),
    AccountMeta(voterVault, false),
    AccountMetaReadonly(voterAuthority, true),
    AccountMeta(payer, true),
    AccountMetaReadonly(depositMint, false),
    AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
    AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
    AccountMetaReadonly(ASSOCIATED_TOKEN_PROGRAM_ID, false),
    AccountMetaReadonly(RENT_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      depositEntryIndex,
      kind,
      option: startTs === void 0 ? 0 : 1,
      startTs: startTs != null ? startTs : ZERO,
      periods,
      allowClawback
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryCreateDepositEntry, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function voterStakeRegistryDeposit(programId, registrar, voter, voterVault, depositToken, depositAuthority, userStakerInfoV2, pool, votingMint, votingMintAuthority, stakeProgramId, depositEntryIndex, amount) {
  const dataLayout = struct50([u8210("depositEntryIndex"), u642("amount")]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMeta(voter, false),
    AccountMeta(voterVault, false),
    AccountMeta(depositToken, false),
    AccountMetaReadonly(depositAuthority, true),
    AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
    AccountMeta(userStakerInfoV2, false),
    AccountMetaReadonly(pool, false),
    AccountMeta(votingMint, false),
    AccountMetaReadonly(votingMintAuthority, false),
    AccountMetaReadonly(stakeProgramId, false),
    AccountMetaReadonly(INSTRUCTION_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      depositEntryIndex,
      amount
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryDeposit, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function voterStakeRegistryUpdateVoterWeightRecord(programId, registrar, voter, voterWeightRecord) {
  const dataLayout = struct50([]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMetaReadonly(voter, false),
    AccountMeta(voterWeightRecord, false),
    AccountMetaReadonly(SYSTEM_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode({}, data);
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryUpdateVoterWeightRecord, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function voterStakeRegistryWithdraw(programId, registrar, voter, voterAuthority, tokenOwnerRecord, voterWeightRecord, vault, destination, userStakerInfoV2, pool, votingMint, votingMintAuthority, stakeProgramId, depositEntryIndex, amount) {
  const dataLayout = struct50([u8210("depositEntryIndex"), u642("amount")]);
  const keys = [
    AccountMetaReadonly(registrar, false),
    AccountMeta(voter, false),
    AccountMetaReadonly(voterAuthority, true),
    AccountMetaReadonly(tokenOwnerRecord, false),
    AccountMeta(voterWeightRecord, false),
    AccountMeta(vault, false),
    AccountMeta(destination, false),
    AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
    AccountMeta(userStakerInfoV2, false),
    AccountMetaReadonly(pool, false),
    AccountMeta(votingMint, false),
    AccountMetaReadonly(votingMintAuthority, false),
    AccountMetaReadonly(stakeProgramId, false),
    AccountMetaReadonly(INSTRUCTION_PROGRAM_ID, false)
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      depositEntryIndex,
      amount
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf.voterStakeRegistryWithdraw, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
var REAL_FARM_STATE_LAYOUT_V3 = struct50([
  u642("state"),
  u642("nonce"),
  publicKey2("lpVault"),
  publicKey2("rewardVault"),
  publicKey2(),
  publicKey2(),
  u642(),
  u642(),
  u642("totalReward"),
  u128("perShareReward"),
  u642("lastSlot"),
  u642("perSlotReward")
]);
var REAL_FARM_STATE_LAYOUT_V5 = struct50([
  u642("state"),
  u642("nonce"),
  publicKey2("lpVault"),
  publicKey2("rewardVaultA"),
  u642("totalRewardA"),
  u128("perShareRewardA"),
  u642("perSlotRewardA"),
  u8210("option"),
  publicKey2("rewardVaultB"),
  blob3(7),
  u642("totalRewardB"),
  u128("perShareRewardB"),
  u642("perSlotRewardB"),
  u642("lastSlot"),
  publicKey2()
]);
var FARM_STATE_LAYOUT_V6_REWARD_INFO = struct50([
  u642("rewardState"),
  u642("rewardOpenTime"),
  u642("rewardEndTime"),
  u642("rewardLastUpdateTime"),
  u642("totalReward"),
  u642("totalRewardEmissioned"),
  u642("rewardClaimed"),
  u642("rewardPerSecond"),
  u128("accRewardPerShare"),
  publicKey2("rewardVault"),
  publicKey2("rewardMint"),
  publicKey2("rewardSender"),
  u642("rewardType"),
  seq22(u642(), 15, "padding")
]);
var REAL_FARM_STATE_LAYOUT_V6 = struct50([
  u642(),
  u642("state"),
  u642("nonce"),
  u642("validRewardTokenNum"),
  u128("rewardMultiplier"),
  u642("rewardPeriodMax"),
  u642("rewardPeriodMin"),
  u642("rewardPeriodExtend"),
  publicKey2("lpMint"),
  publicKey2("lpVault"),
  seq22(FARM_STATE_LAYOUT_V6_REWARD_INFO, 5, "rewardInfos"),
  publicKey2("creator"),
  publicKey2(),
  seq22(u642(), 32, "padding")
]);
var FARM_STATE_LAYOUT_V3 = new Proxy(
  REAL_FARM_STATE_LAYOUT_V3,
  {
    get(target, p, receiver) {
      if (p === "decode")
        return (...decodeParams) => {
          const originalResult = target.decode(...decodeParams);
          return __spreadProps(__spreadValues({}, originalResult), {
            version: 3,
            rewardInfos: [
              {
                rewardVault: originalResult.rewardVault,
                totalReward: originalResult.totalReward,
                perSlotReward: originalResult.perSlotReward,
                perShareReward: originalResult.perShareReward
              }
            ]
          });
        };
      else return Reflect.get(target, p, receiver);
    }
  }
);
var FARM_STATE_LAYOUT_V5 = new Proxy(
  REAL_FARM_STATE_LAYOUT_V5,
  {
    get(target, p, receiver) {
      if (p === "decode")
        return (...decodeParams) => {
          const originalResult = target.decode(...decodeParams);
          return __spreadProps(__spreadValues({}, originalResult), {
            version: 5,
            rewardInfos: [
              {
                rewardVault: originalResult.rewardVaultA,
                totalReward: originalResult.totalRewardA,
                perSlotReward: originalResult.perSlotRewardA,
                perShareReward: originalResult.perShareRewardA
              },
              {
                rewardVault: originalResult.rewardVaultB,
                totalReward: originalResult.totalRewardB,
                perSlotReward: originalResult.perSlotRewardB,
                perShareReward: originalResult.perShareRewardB
              }
            ]
          });
        };
      else return Reflect.get(target, p, receiver);
    }
  }
);
var FARM_STATE_LAYOUT_V6 = new Proxy(
  REAL_FARM_STATE_LAYOUT_V6,
  {
    get(target, p, receiver) {
      if (p === "decode")
        return (...decodeParams) => {
          const originalResult = target.decode(...decodeParams);
          return __spreadProps(__spreadValues({}, originalResult), {
            version: 6,
            rewardInfos: originalResult.rewardInfos.map((item) => {
              var _a;
              return __spreadProps(__spreadValues({}, item), {
                rewardType: ((_a = Object.entries(poolTypeV6).find((i) => String(i[1]) === item.rewardType.toString())) != null ? _a : [
                  "Standard SPL"
                ])[0]
              });
            })
          });
        };
      else return Reflect.get(target, p, receiver);
    }
  }
);
var FARM_LEDGER_LAYOUT_V3_1 = struct50([
  u642("state"),
  publicKey2("id"),
  publicKey2("owner"),
  u642("deposited"),
  seq22(u642(), 1, "rewardDebts")
]);
var FARM_LEDGER_LAYOUT_V3_2 = struct50([
  u642("state"),
  publicKey2("id"),
  publicKey2("owner"),
  u642("deposited"),
  seq22(u128(), 1, "rewardDebts"),
  u642(""),
  u642("voteLockedBalance"),
  seq22(u642(), 15)
]);
var FARM_LEDGER_LAYOUT_V5_1 = struct50([
  u642("state"),
  publicKey2("id"),
  publicKey2("owner"),
  u642("deposited"),
  seq22(u642(), 2, "rewardDebts")
]);
var FARM_LEDGER_LAYOUT_V5_2 = struct50([
  u642("state"),
  publicKey2("id"),
  publicKey2("owner"),
  u642("deposited"),
  seq22(u128(), 2, "rewardDebts"),
  seq22(u642(), 17)
]);
var FARM_LEDGER_LAYOUT_V6_1 = struct50([
  u642(),
  u642("state"),
  publicKey2("id"),
  publicKey2("owner"),
  u642("deposited"),
  seq22(u128(), 5, "rewardDebts"),
  seq22(u642(), 16)
]);
var FARM_VERSION_TO_STATE_LAYOUT = {
  3: FARM_STATE_LAYOUT_V3,
  5: FARM_STATE_LAYOUT_V5,
  6: FARM_STATE_LAYOUT_V6
};
var FARM_VERSION_TO_LEDGER_LAYOUT = {
  3: FARM_LEDGER_LAYOUT_V3_2,
  5: FARM_LEDGER_LAYOUT_V5_2,
  6: FARM_LEDGER_LAYOUT_V6_1
};
var VoterVotingMintConfig = struct50([
  publicKey2("mint"),
  publicKey2("grantAuthority"),
  u642("baselineVoteWeightScaledFactor"),
  u642("maxExtraLockupVoteWeightScaledFactor"),
  u642("lockupSaturationSecs"),
  i8("digitShift"),
  // TODO
  seq22(u8210(), 7, "reserved1"),
  seq22(u642(), 7, "reserved2")
]);
var VoterRegistrar = struct50([
  blob3(8),
  publicKey2("governanceProgramId"),
  publicKey2("realm"),
  publicKey2("realmGoverningTokenMint"),
  publicKey2("realmAuthority"),
  seq22(u8210(), 32, "reserved1"),
  seq22(VoterVotingMintConfig, 4, "votingMints"),
  i64("timeOffset"),
  u8210("bump"),
  seq22(u8210(), 7, "reserved2"),
  seq22(u642(), 11, "reserved3")
]);
var VoterLockup = struct50([i64("startTime"), i64("endTime"), u8210("kind"), seq22(u8210(), 15, "reserved")]);
var VoterDepositEntry = struct50([
  seq22(VoterLockup, 1, "lockup"),
  u642("amountDeposited_native"),
  u642("amountInitiallyLockedNative"),
  bool22("isUsed"),
  bool22("allowClawback"),
  u8210("votingMintConfigIdx"),
  seq22(u8210(), 29, "reserved")
]);
var Voter = struct50([
  blob3(8),
  publicKey2("voterAuthority"),
  publicKey2("registrar"),
  seq22(VoterDepositEntry, 32, "deposits"),
  u8210("voterBump"),
  u8210("voterWweightRecordBump"),
  seq22(u8210(), 94, "reserved")
]);
function getRegistrarAddress(programId, realm, communityTokenMint) {
  return findProgramAddress(
    [realm.toBuffer(), Buffer.from("registrar", "utf8"), communityTokenMint.toBuffer()],
    programId
  );
}
function getVotingTokenMint(programId, poolId) {
  return findProgramAddress([poolId.toBuffer(), Buffer.from("voting_mint_seed", "utf8")], programId);
}
function getVotingMintAuthority(programId, poolId) {
  return findProgramAddress([poolId.toBuffer()], programId);
}
function getVoterAddress(programId, registrar, authority) {
  return findProgramAddress([registrar.toBuffer(), Buffer.from("voter", "utf8"), authority.toBuffer()], programId);
}
function getVoterWeightRecordAddress(programId, registrar, authority) {
  return findProgramAddress(
    [registrar.toBuffer(), Buffer.from("voter-weight-record", "utf8"), authority.toBuffer()],
    programId
  );
}
function getTokenOwnerRecordAddress(programId, realm, governingTokenMint, governingTokenOwner) {
  return findProgramAddress(
    [
      Buffer.from("governance", "utf8"),
      realm.toBuffer(),
      governingTokenMint.toBuffer(),
      governingTokenOwner.toBuffer()
    ],
    programId
  );
}
var logger8 = Logger.from("Farm");
var poolTypeV6 = { "Standard SPL": 0, "Option tokens": 1 };
var Farm = class _Farm extends Base {
  /* ================= get layout ================= */
  static getStateLayout(version2) {
    const STATE_LAYOUT = FARM_VERSION_TO_STATE_LAYOUT[version2];
    logger8.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
    return STATE_LAYOUT;
  }
  static getLedgerLayout(version2) {
    const LEDGER_LAYOUT = FARM_VERSION_TO_LEDGER_LAYOUT[version2];
    logger8.assertArgument(!!LEDGER_LAYOUT, "invalid version", "version", version2);
    return LEDGER_LAYOUT;
  }
  static getLayouts(version2) {
    return { state: this.getStateLayout(version2), ledger: this.getLedgerLayout(version2) };
  }
  /* ================= get key ================= */
  static getAssociatedAuthority({ programId, poolId }) {
    return findProgramAddress([poolId.toBuffer()], programId);
  }
  static getAssociatedLedgerAccount({
    programId,
    poolId,
    owner,
    version: version2
  }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [
        poolId.toBuffer(),
        owner.toBuffer(),
        Buffer.from(version2 === 6 ? "farmer_info_associated_seed" : "staker_info_v2_associated_seed", "utf-8")
      ],
      programId
    );
    return publicKey22;
  }
  static getAssociatedLedgerPoolAccount({
    programId,
    poolId,
    mint,
    type
  }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [
        poolId.toBuffer(),
        mint.toBuffer(),
        Buffer.from(
          type === "lpVault" ? "lp_vault_associated_seed" : type === "rewardVault" ? "reward_vault_associated_seed" : "",
          "utf-8"
        )
      ],
      programId
    );
    return publicKey22;
  }
  /* ================= make instruction and transaction ================= */
  static makeDepositInstruction(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 3) {
      return this.makeDepositInstructionV3(params);
    } else if (version2 === 5) {
      return this.makeDepositInstructionV5(params);
    } else if (version2 === 6) {
      return this.makeDepositInstructionV6(params);
    }
    return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeDepositInstructionV3({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      poolKeys.rewardInfos.length === 1,
      "lengths not equal 1",
      "poolKeys.rewardInfos",
      poolKeys.rewardInfos
    );
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === 1,
      "lengths not equal 1",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct50([u8210("instruction"), u642("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 10,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.rewardTokenAccounts[0], false),
      AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
      // system
      AccountMetaReadonly(SYSVAR_CLOCK_PUBKEY, false),
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false)
    ];
    if (userKeys.auxiliaryLedgers) {
      for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
        keys.push(AccountMeta(auxiliaryLedger, false));
      }
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          38
          /* farmV3Deposit */
        ]
      }
    };
  }
  static makeDepositInstructionV5({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
      "lengths not equal with poolKeys.rewardInfos",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct50([u8210("instruction"), u642("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 11,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.rewardTokenAccounts[0], false),
      AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
      // system
      AccountMetaReadonly(SYSVAR_CLOCK_PUBKEY, false),
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false)
    ];
    for (let index = 1; index < poolKeys.rewardInfos.length; index++) {
      keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
      keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
    }
    if (userKeys.auxiliaryLedgers) {
      for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
        keys.push(AccountMeta(auxiliaryLedger, false));
      }
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          41
          /* farmV5Deposit */
        ]
      }
    };
  }
  static makeDepositInstructionV6({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length !== 0,
      "lengths equal zero",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
      "lengths not equal with poolKeys.rewardInfos",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct50([u8210("instruction"), u642("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 1,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false)
    ];
    for (let index = 0; index < poolKeys.rewardInfos.length; index++) {
      keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
      keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          44
          /* farmV6Deposit */
        ]
      }
    };
  }
  static makeWithdrawInstruction(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 3) {
      return this.makeWithdrawInstructionV3(params);
    } else if (version2 === 5) {
      return this.makeWithdrawInstructionV5(params);
    } else if (version2 === 6) {
      return this.makeWithdrawInstructionV6(params);
    }
    return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeWithdrawInstructionV3({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      poolKeys.rewardInfos.length === 1,
      "lengths not equal 1",
      "poolKeys.rewardInfos",
      poolKeys.rewardInfos
    );
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === 1,
      "lengths not equal 1",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct50([u8210("instruction"), u642("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 11,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.rewardTokenAccounts[0], false),
      AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
      // system
      AccountMetaReadonly(SYSVAR_CLOCK_PUBKEY, false),
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false)
    ];
    if (userKeys.auxiliaryLedgers) {
      for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
        keys.push(AccountMeta(auxiliaryLedger, false));
      }
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          41
          /* farmV5Deposit */
        ]
      }
    };
  }
  static makeWithdrawInstructionV5({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
      "lengths not equal with params.poolKeys.rewardInfos",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct50([u8210("instruction"), u642("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 12,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.rewardTokenAccounts[0], false),
      AccountMeta(poolKeys.rewardInfos[0].rewardVault, false),
      // system
      AccountMetaReadonly(SYSVAR_CLOCK_PUBKEY, false),
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false)
    ];
    for (let index = 1; index < poolKeys.rewardInfos.length; index++) {
      keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
      keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
    }
    if (userKeys.auxiliaryLedgers) {
      for (const auxiliaryLedger of userKeys.auxiliaryLedgers) {
        keys.push(AccountMeta(auxiliaryLedger, false));
      }
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          42
          /* farmV5Withdraw */
        ]
      }
    };
  }
  static makeWithdrawInstructionV6({ poolKeys, userKeys, amount }) {
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length !== 0,
      "lengths equal zero",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    logger8.assertArgument(
      userKeys.rewardTokenAccounts.length === poolKeys.rewardInfos.length,
      "lengths not equal with params.poolKeys.rewardInfos",
      "userKeys.rewardTokenAccounts",
      userKeys.rewardTokenAccounts
    );
    const LAYOUT = struct50([u8210("instruction"), u642("amount")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 2,
        amount: parseBigNumberish(amount)
      },
      data
    );
    const keys = [
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(poolKeys.lpVault, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      AccountMeta(userKeys.lpTokenAccount, false)
    ];
    for (let index = 0; index < poolKeys.rewardInfos.length; index++) {
      keys.push(AccountMeta(poolKeys.rewardInfos[index].rewardVault, false));
      keys.push(AccountMeta(userKeys.rewardTokenAccounts[index], false));
    }
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          45
          /* farmV6Withdraw */
        ]
      }
    };
  }
  static makeCreateAssociatedLedgerAccountInstruction(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 3) {
      return this.makeCreateAssociatedLedgerAccountInstructionV3(params);
    } else if (version2 === 5) {
      return this.makeCreateAssociatedLedgerAccountInstructionV5(params);
    }
    return logger8.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeCreateAssociatedLedgerAccountInstructionV3({
    poolKeys,
    userKeys
  }) {
    const LAYOUT = struct50([u8210("instruction")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 9
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      // system
      AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
      AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false)
    ];
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          40
          /* farmV3CreateLedger */
        ]
      }
    };
  }
  static makeCreateAssociatedLedgerAccountInstructionV5({
    poolKeys,
    userKeys
  }) {
    const LAYOUT = struct50([u8210("instruction")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 10
      },
      data
    );
    const keys = [
      AccountMeta(poolKeys.id, false),
      AccountMeta(userKeys.ledger, false),
      AccountMetaReadonly(userKeys.owner, true),
      // system
      AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
      AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false)
    ];
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          43
          /* farmV5CreateLedger */
        ]
      }
    };
  }
  static makeCreateFarmInstruction({ connection, userKeys, poolInfo }) {
    const { version: version2 } = poolInfo;
    if (version2 === 6) {
      return this.makeCreateFarmInstructionV6({
        connection,
        userKeys,
        poolInfo
      });
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeCreateFarmInstructionV6(_0) {
    return __async(this, arguments, function* ({ connection, userKeys, poolInfo }) {
      var _a, _b, _c;
      const payer = (_a = userKeys.payer) != null ? _a : userKeys.owner;
      const farmId = generatePubKey({ fromPublicKey: payer, programId: poolInfo.programId });
      const lamports = yield connection.getMinimumBalanceForRentExemption(FARM_STATE_LAYOUT_V6.span);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      frontInstructions.push(
        SystemProgram.createAccountWithSeed({
          fromPubkey: payer,
          basePubkey: payer,
          seed: farmId.seed,
          newAccountPubkey: farmId.publicKey,
          lamports,
          space: FARM_STATE_LAYOUT_V6.span,
          programId: poolInfo.programId
        })
      );
      const { publicKey: authority, nonce } = _Farm.getAssociatedAuthority({
        programId: poolInfo.programId,
        poolId: farmId.publicKey
      });
      const lpVault = _Farm.getAssociatedLedgerPoolAccount({
        programId: poolInfo.programId,
        poolId: farmId.publicKey,
        mint: poolInfo.lpMint,
        type: "lpVault"
      });
      const rewardInfoConfig = [];
      const rewardInfoKey = [];
      for (const rewardInfo of poolInfo.rewardInfos) {
        logger8.assertArgument(
          rewardInfo.rewardOpenTime < rewardInfo.rewardEndTime,
          "start time error",
          "rewardInfo.rewardOpenTime",
          rewardInfo.rewardOpenTime
        );
        logger8.assertArgument(
          poolTypeV6[rewardInfo.rewardType] !== void 0,
          "reward type error",
          "rewardInfo.rewardType",
          rewardInfo.rewardType
        );
        logger8.assertArgument(
          parseBigNumberish(rewardInfo.rewardPerSecond).gt(ZERO),
          "rewardPerSecond error",
          "rewardInfo.rewardPerSecond",
          rewardInfo.rewardPerSecond
        );
        rewardInfoConfig.push({
          isSet: new import_bn9.default(1),
          rewardPerSecond: parseBigNumberish(rewardInfo.rewardPerSecond),
          rewardOpenTime: parseBigNumberish(rewardInfo.rewardOpenTime),
          rewardEndTime: parseBigNumberish(rewardInfo.rewardEndTime),
          rewardType: parseBigNumberish(poolTypeV6[rewardInfo.rewardType])
        });
        let userRewardToken;
        if (rewardInfo.rewardMint.equals(PublicKey.default)) {
          userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
            connection,
            owner: userKeys.owner,
            payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
            instructions: frontInstructions,
            signers,
            amount: parseBigNumberish(rewardInfo.rewardEndTime).sub(parseBigNumberish(rewardInfo.rewardOpenTime)).mul(parseBigNumberish(rewardInfo.rewardPerSecond)),
            instructionsType: frontInstructionsType
          });
          endInstructions.push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              tokenAccount: userRewardToken,
              owner: userKeys.owner,
              payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
              instructionsType: endInstructionsType
            })
          );
        } else {
          userRewardToken = this._selectTokenAccount({
            programId: TOKEN_PROGRAM_ID,
            tokenAccounts: userKeys.tokenAccounts,
            mint: rewardInfo.rewardMint,
            owner: userKeys.owner,
            config: { associatedOnly: false }
          });
        }
        logger8.assertArgument(
          userRewardToken !== null,
          "cannot found target token accounts",
          "tokenAccounts",
          userKeys.tokenAccounts
        );
        const rewardMint = rewardInfo.rewardMint.equals(PublicKey.default) ? Token.WSOL.mint : rewardInfo.rewardMint;
        rewardInfoKey.push({
          rewardMint,
          rewardVault: _Farm.getAssociatedLedgerPoolAccount({
            programId: poolInfo.programId,
            poolId: farmId.publicKey,
            mint: rewardMint,
            type: "rewardVault"
          }),
          userRewardToken
        });
      }
      const lockUserAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts: userKeys.tokenAccounts,
        mint: poolInfo.lockInfo.lockMint,
        owner: userKeys.owner,
        config: { associatedOnly: false }
      });
      logger8.assertArgument(lockUserAccount !== null, "cannot found lock vault", "tokenAccounts", userKeys.tokenAccounts);
      const rewardTimeInfo = struct50([
        u642("isSet"),
        u642("rewardPerSecond"),
        u642("rewardOpenTime"),
        u642("rewardEndTime"),
        u642("rewardType")
      ]);
      const LAYOUT = struct50([u8210("instruction"), u642("nonce"), seq22(rewardTimeInfo, 5, "rewardTimeInfo")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 0,
          nonce: new import_bn9.default(nonce),
          rewardTimeInfo: rewardInfoConfig
        },
        data
      );
      const keys = [
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
        AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false),
        AccountMeta(farmId.publicKey, false),
        AccountMetaReadonly(authority, false),
        AccountMeta(lpVault, false),
        AccountMetaReadonly(poolInfo.lpMint, false),
        AccountMeta(poolInfo.lockInfo.lockVault, false),
        AccountMetaReadonly(poolInfo.lockInfo.lockMint, false),
        AccountMeta(lockUserAccount != null ? lockUserAccount : PublicKey.default, false),
        AccountMetaReadonly(userKeys.owner, true)
      ];
      for (const item of rewardInfoKey) {
        keys.push(
          ...[
            { pubkey: item.rewardMint, isSigner: false, isWritable: false },
            { pubkey: item.rewardVault, isSigner: false, isWritable: true },
            { pubkey: item.userRewardToken, isSigner: false, isWritable: true }
          ]
        );
      }
      const ins = new TransactionInstruction({
        programId: poolInfo.programId,
        keys,
        data
      });
      return {
        address: { farmId: farmId.publicKey },
        innerTransaction: {
          instructions: [...frontInstructions, ins, ...endInstructions],
          signers,
          lookupTableAddress: [],
          instructionTypes: [...frontInstructionsType, 46, ...endInstructionsType]
        }
      };
    });
  }
  static makeCreatorWithdrawFarmRewardInstruction(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 6) {
      return this.makeCreatorWithdrawFarmRewardInstructionV6(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeCreatorWithdrawFarmRewardInstructionV6({
    poolKeys,
    userKeys,
    withdrawMint
  }) {
    var _a;
    const rewardInfo = poolKeys.rewardInfos.find(
      (item) => item.rewardMint.equals(withdrawMint.equals(PublicKey.default) ? Token.WSOL.mint : withdrawMint)
    );
    logger8.assertArgument(rewardInfo !== void 0, "withdraw mint error", "poolKeys.rewardInfos", poolKeys.rewardInfos);
    const rewardVault = (_a = rewardInfo == null ? void 0 : rewardInfo.rewardVault) != null ? _a : PublicKey.default;
    const LAYOUT = struct50([u8210("instruction")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode({ instruction: 5 }, data);
    const keys = [
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMetaReadonly(poolKeys.lpVault, false),
      AccountMeta(rewardVault, false),
      AccountMeta(userKeys.userRewardToken, false),
      AccountMetaReadonly(userKeys.owner, true)
    ];
    const ins = new TransactionInstruction({
      programId: poolKeys.programId,
      keys,
      data
    });
    return {
      address: {},
      innerTransaction: {
        instructions: [ins],
        signers: [],
        lookupTableAddress: [],
        instructionTypes: [
          49
          /* farmV6CreatorWithdraw */
        ]
      }
    };
  }
  /* ================= fetch data ================= */
  static fetchMultipleInfoAndUpdate(_0) {
    return __async(this, arguments, function* ({
      connection,
      pools,
      owner,
      config: config2,
      chainTime
    }) {
      let hasNotV6Pool = false;
      let hasV6Pool = false;
      const publicKeys = [];
      const apiPoolInfo = {};
      for (const pool of pools) {
        apiPoolInfo[pool.id.toString()] = pool;
        if (pool.version === 6) hasV6Pool = true;
        else hasNotV6Pool = true;
        publicKeys.push({
          pubkey: pool.id,
          version: pool.version,
          key: "state",
          poolId: pool.id
        });
        publicKeys.push({
          pubkey: pool.lpVault,
          version: pool.version,
          key: "lpVault",
          poolId: pool.id
        });
        if (owner) {
          publicKeys.push({
            pubkey: this.getAssociatedLedgerAccount({
              programId: pool.programId,
              poolId: pool.id,
              owner,
              version: pool.version
            }),
            version: pool.version,
            key: "ledger",
            poolId: pool.id
          });
        }
      }
      const poolsInfo = {};
      const accountsInfo = yield getMultipleAccountsInfoWithCustomFlags(connection, publicKeys, config2);
      for (const { pubkey, version: version2, key, poolId, accountInfo } of accountsInfo) {
        const _poolId = poolId.toBase58();
        if (key === "state") {
          const STATE_LAYOUT = this.getStateLayout(version2);
          if (!accountInfo || !accountInfo.data || accountInfo.data.length !== STATE_LAYOUT.span) {
            return logger8.throwArgumentError("invalid farm state account info", "pools.id", pubkey);
          }
          poolsInfo[_poolId] = __spreadValues(__spreadValues(__spreadValues({}, poolsInfo[_poolId]), { apiPoolInfo: apiPoolInfo[_poolId] }), { state: STATE_LAYOUT.decode(accountInfo.data) });
        } else if (key === "lpVault") {
          if (!accountInfo || !accountInfo.data || accountInfo.data.length !== SPL_ACCOUNT_LAYOUT.span) {
            return logger8.throwArgumentError("invalid farm lp vault account info", "pools.lpVault", pubkey);
          }
          poolsInfo[_poolId] = __spreadValues(__spreadValues({}, poolsInfo[_poolId]), { lpVault: SPL_ACCOUNT_LAYOUT.decode(accountInfo.data) });
        } else if (key === "ledger") {
          const LEDGER_LAYOUT = this.getLedgerLayout(version2);
          if (accountInfo && accountInfo.data) {
            logger8.assertArgument(
              accountInfo.data.length === LEDGER_LAYOUT.span,
              "invalid farm ledger account info",
              "ledger",
              pubkey
            );
            poolsInfo[_poolId] = __spreadValues(__spreadValues({}, poolsInfo[_poolId]), { ledger: LEDGER_LAYOUT.decode(accountInfo.data) });
          }
        }
      }
      const slot = hasV6Pool || hasNotV6Pool ? yield connection.getSlot() : 0;
      for (const poolId of Object.keys(poolsInfo)) {
        if (poolsInfo[poolId] === void 0) continue;
        poolsInfo[poolId].state = _Farm.updatePoolInfo(poolsInfo[poolId].state, poolsInfo[poolId].lpVault, slot, chainTime);
      }
      for (const [poolId, { state, ledger }] of Object.entries(poolsInfo)) {
        if (ledger) {
          let multiplier;
          if (state.version === 6) {
            multiplier = state.rewardMultiplier;
          } else {
            multiplier = state.rewardInfos.length === 1 ? TEN.pow(new import_bn9.default(9)) : TEN.pow(new import_bn9.default(15));
          }
          const pendingRewards = state.rewardInfos.map((rewardInfo, index) => {
            const rewardDebt = ledger.rewardDebts[index];
            const pendingReward = ledger.deposited.mul(state.version === 6 ? rewardInfo.accRewardPerShare : rewardInfo.perShareReward).div(multiplier).sub(rewardDebt);
            return pendingReward;
          });
          poolsInfo[poolId].wrapped = __spreadProps(__spreadValues({}, poolsInfo[poolId].wrapped), {
            pendingRewards
          });
        }
      }
      return poolsInfo;
    });
  }
  static updatePoolInfo(poolInfo, lpVault, slot, chainTime) {
    if (poolInfo.version === 3 || poolInfo.version === 5) {
      if (poolInfo.lastSlot.gte(new import_bn9.default(slot))) return poolInfo;
      const spread = new import_bn9.default(slot).sub(poolInfo.lastSlot);
      poolInfo.lastSlot = new import_bn9.default(slot);
      for (const itemRewardInfo of poolInfo.rewardInfos) {
        if (lpVault.amount.eq(new import_bn9.default(0))) continue;
        const reward = itemRewardInfo.perSlotReward.mul(spread);
        itemRewardInfo.perShareReward = itemRewardInfo.perShareReward.add(
          reward.mul(new import_bn9.default(10).pow(new import_bn9.default(poolInfo.version === 3 ? 9 : 15))).div(lpVault.amount)
        );
        itemRewardInfo.totalReward = itemRewardInfo.totalReward.add(reward);
      }
    } else if (poolInfo.version === 6) {
      for (const itemRewardInfo of poolInfo.rewardInfos) {
        if (itemRewardInfo.rewardState.eq(new import_bn9.default(0))) continue;
        const updateTime = import_bn9.default.min(new import_bn9.default(chainTime), itemRewardInfo.rewardEndTime);
        if (itemRewardInfo.rewardOpenTime.gte(updateTime)) continue;
        const spread = updateTime.sub(itemRewardInfo.rewardLastUpdateTime);
        let reward = spread.mul(itemRewardInfo.rewardPerSecond);
        const leftReward = itemRewardInfo.totalReward.sub(itemRewardInfo.totalRewardEmissioned);
        if (leftReward.lt(reward)) {
          reward = leftReward;
          itemRewardInfo.rewardLastUpdateTime = itemRewardInfo.rewardLastUpdateTime.add(
            leftReward.div(itemRewardInfo.rewardPerSecond)
          );
        } else {
          itemRewardInfo.rewardLastUpdateTime = updateTime;
        }
        if (lpVault.amount.eq(new import_bn9.default(0))) continue;
        itemRewardInfo.accRewardPerShare = itemRewardInfo.accRewardPerShare.add(
          reward.mul(poolInfo.rewardMultiplier).div(lpVault.amount)
        );
        itemRewardInfo.totalRewardEmissioned = itemRewardInfo.totalRewardEmissioned.add(reward);
      }
    }
    return poolInfo;
  }
  /* ================= make instruction simple ================= */
  static makeCreatorWithdrawFarmRewardInstructionSimple(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 6) {
      return this.makeCreatorWithdrawFarmRewardInstructionV6Simple(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeCreatorWithdrawFarmRewardInstructionV6Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      userKeys,
      withdrawMint,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b, _c, _d;
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let userRewardToken;
      if (withdrawMint.equals(PublicKey.default)) {
        userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
          connection,
          owner: userKeys.owner,
          payer: (_a = userKeys.payer) != null ? _a : userKeys.owner,
          instructions: frontInstructions,
          signers,
          amount: 0,
          instructionsType: frontInstructionsType
        });
        endInstructions.push(
          Spl.makeCloseAccountInstruction({
            programId: TOKEN_PROGRAM_ID,
            tokenAccount: userRewardToken,
            owner: userKeys.owner,
            payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
            instructionsType: endInstructionsType
          })
        );
      } else {
        const selectUserRewardToken = this._selectTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          tokenAccounts: userKeys.tokenAccounts,
          mint: withdrawMint,
          owner: userKeys.owner
        });
        if (selectUserRewardToken === null) {
          userRewardToken = getATAAddress(userKeys.owner, withdrawMint, TOKEN_PROGRAM_ID).publicKey;
          frontInstructions.push(
            Spl.makeCreateAssociatedTokenAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              mint: withdrawMint,
              associatedAccount: userRewardToken,
              owner: userKeys.owner,
              payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
              instructionsType: frontInstructionsType
            })
          );
        } else {
          userRewardToken = selectUserRewardToken;
        }
      }
      const ins = this.makeCreatorWithdrawFarmRewardInstructionV6({
        poolKeys,
        userKeys: { userRewardToken, owner: userKeys.owner, payer: userKeys.payer },
        withdrawMint
      });
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCreateFarmInstructionSimple(params) {
    const { version: version2 } = params.poolInfo;
    if (version2 === 6) {
      return this.makeCreateFarmInstructionV6Simple(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeCreateFarmInstructionV6Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      userKeys,
      poolInfo,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b, _c, _d;
      const payer = (_a = userKeys.payer) != null ? _a : userKeys.owner;
      const farmId = generatePubKey({ fromPublicKey: payer, programId: poolInfo.programId });
      const lamports = yield connection.getMinimumBalanceForRentExemption(FARM_STATE_LAYOUT_V6.span);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      frontInstructions.push(
        SystemProgram.createAccountWithSeed({
          fromPubkey: payer,
          basePubkey: payer,
          seed: farmId.seed,
          newAccountPubkey: farmId.publicKey,
          lamports,
          space: FARM_STATE_LAYOUT_V6.span,
          programId: poolInfo.programId
        })
      );
      const { publicKey: authority, nonce } = _Farm.getAssociatedAuthority({
        programId: poolInfo.programId,
        poolId: farmId.publicKey
      });
      const lpVault = _Farm.getAssociatedLedgerPoolAccount({
        programId: poolInfo.programId,
        poolId: farmId.publicKey,
        mint: poolInfo.lpMint,
        type: "lpVault"
      });
      const rewardInfoConfig = [];
      const rewardInfoKey = [];
      for (const rewardInfo of poolInfo.rewardInfos) {
        logger8.assertArgument(
          rewardInfo.rewardOpenTime < rewardInfo.rewardEndTime,
          "start time error",
          "rewardInfo.rewardOpenTime",
          rewardInfo.rewardOpenTime
        );
        logger8.assertArgument(
          poolTypeV6[rewardInfo.rewardType] !== void 0,
          "reward type error",
          "rewardInfo.rewardType",
          rewardInfo.rewardType
        );
        logger8.assertArgument(
          parseBigNumberish(rewardInfo.rewardPerSecond).gt(ZERO),
          "rewardPerSecond error",
          "rewardInfo.rewardPerSecond",
          rewardInfo.rewardPerSecond
        );
        rewardInfoConfig.push({
          isSet: new import_bn9.default(1),
          rewardPerSecond: parseBigNumberish(rewardInfo.rewardPerSecond),
          rewardOpenTime: parseBigNumberish(rewardInfo.rewardOpenTime),
          rewardEndTime: parseBigNumberish(rewardInfo.rewardEndTime),
          rewardType: parseBigNumberish(poolTypeV6[rewardInfo.rewardType])
        });
        let userRewardToken;
        if (rewardInfo.rewardMint.equals(PublicKey.default)) {
          userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
            connection,
            owner: userKeys.owner,
            payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
            instructions: frontInstructions,
            signers,
            amount: parseBigNumberish(rewardInfo.rewardEndTime).sub(parseBigNumberish(rewardInfo.rewardOpenTime)).mul(parseBigNumberish(rewardInfo.rewardPerSecond)),
            instructionsType: frontInstructionsType
          });
          endInstructions.push(
            Spl.makeCloseAccountInstruction({
              programId: TOKEN_PROGRAM_ID,
              tokenAccount: userRewardToken,
              owner: userKeys.owner,
              payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
              instructionsType: endInstructionsType
            })
          );
        } else {
          userRewardToken = this._selectTokenAccount({
            programId: TOKEN_PROGRAM_ID,
            tokenAccounts: userKeys.tokenAccounts,
            mint: rewardInfo.rewardMint,
            owner: userKeys.owner,
            config: { associatedOnly: false }
          });
        }
        logger8.assertArgument(
          userRewardToken !== null,
          "cannot found target token accounts",
          "tokenAccounts",
          userKeys.tokenAccounts
        );
        if (userRewardToken === null) throw Error("cannot found target token accounts");
        const rewardMint = rewardInfo.rewardMint.equals(PublicKey.default) ? Token.WSOL.mint : rewardInfo.rewardMint;
        rewardInfoKey.push({
          rewardMint,
          rewardVault: _Farm.getAssociatedLedgerPoolAccount({
            programId: poolInfo.programId,
            poolId: farmId.publicKey,
            mint: rewardMint,
            type: "rewardVault"
          }),
          userRewardToken
        });
      }
      const lockUserAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts: userKeys.tokenAccounts,
        mint: poolInfo.lockInfo.lockMint,
        owner: userKeys.owner,
        config: { associatedOnly: false }
      });
      logger8.assertArgument(lockUserAccount !== null, "cannot found lock vault", "tokenAccounts", userKeys.tokenAccounts);
      const rewardTimeInfo = struct50([
        u642("isSet"),
        u642("rewardPerSecond"),
        u642("rewardOpenTime"),
        u642("rewardEndTime"),
        u642("rewardType")
      ]);
      const LAYOUT = struct50([u8210("instruction"), u642("nonce"), seq22(rewardTimeInfo, 5, "rewardTimeInfo")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 0,
          nonce: new import_bn9.default(nonce),
          rewardTimeInfo: rewardInfoConfig
        },
        data
      );
      const keys = [
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
        AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false),
        AccountMeta(farmId.publicKey, false),
        AccountMetaReadonly(authority, false),
        AccountMeta(lpVault, false),
        AccountMetaReadonly(poolInfo.lpMint, false),
        AccountMeta(poolInfo.lockInfo.lockVault, false),
        AccountMetaReadonly(poolInfo.lockInfo.lockMint, false),
        AccountMeta(lockUserAccount != null ? lockUserAccount : PublicKey.default, false),
        AccountMetaReadonly(userKeys.owner, true)
      ];
      for (const item of rewardInfoKey) {
        keys.push(
          ...[
            { pubkey: item.rewardMint, isSigner: false, isWritable: false },
            { pubkey: item.rewardVault, isSigner: false, isWritable: true },
            { pubkey: item.userRewardToken, isSigner: false, isWritable: true }
          ]
        );
      }
      const ins = new TransactionInstruction({
        programId: poolInfo.programId,
        keys,
        data
      });
      return {
        address: { farmId: farmId.publicKey },
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: [
              46
              /* farmV6Create */
            ], instructions: [ins], signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeRestartFarmInstructionSimple(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 6) {
      return this.makeRestartFarmInstructionV6Simple(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeRestartFarmInstructionV6Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      userKeys,
      newRewardInfo,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b, _c, _d;
      logger8.assertArgument(
        newRewardInfo.rewardOpenTime < newRewardInfo.rewardEndTime,
        "start time error",
        "newRewardInfo",
        newRewardInfo
      );
      const rewardMint = newRewardInfo.rewardMint.equals(PublicKey.default) ? Token.WSOL.mint : newRewardInfo.rewardMint;
      const rewardInfo = poolKeys.rewardInfos.find((item) => item.rewardMint.equals(rewardMint));
      logger8.assertArgument(rewardInfo, "configuration does not exist", "rewardInfo", rewardInfo);
      const rewardVault = (_a = rewardInfo == null ? void 0 : rewardInfo.rewardVault) != null ? _a : PublicKey.default;
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let userRewardToken;
      if (newRewardInfo.rewardMint.equals(PublicKey.default)) {
        userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
          connection,
          owner: userKeys.owner,
          payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
          instructions: frontInstructions,
          signers,
          amount: parseBigNumberish(newRewardInfo.rewardEndTime).sub(parseBigNumberish(newRewardInfo.rewardOpenTime)).mul(parseBigNumberish(newRewardInfo.rewardPerSecond)),
          instructionsType: frontInstructionsType
        });
        endInstructions.push(
          Spl.makeCloseAccountInstruction({
            programId: TOKEN_PROGRAM_ID,
            tokenAccount: userRewardToken,
            owner: userKeys.owner,
            payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
            instructionsType: endInstructionsType
          })
        );
      } else {
        userRewardToken = this._selectTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          tokenAccounts: userKeys.tokenAccounts,
          mint: newRewardInfo.rewardMint,
          owner: userKeys.owner,
          config: { associatedOnly: false }
        });
      }
      logger8.assertArgument(
        userRewardToken !== null,
        "cannot found target token accounts",
        "tokenAccounts",
        userKeys.tokenAccounts
      );
      if (userRewardToken === null) throw Error("cannot found target token accounts");
      const LAYOUT = struct50([u8210("instruction"), u642("rewardReopenTime"), u642("rewardEndTime"), u642("rewardPerSecond")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 3,
          rewardReopenTime: parseBigNumberish(newRewardInfo.rewardOpenTime),
          rewardEndTime: parseBigNumberish(newRewardInfo.rewardEndTime),
          rewardPerSecond: parseBigNumberish(newRewardInfo.rewardPerSecond)
        },
        data
      );
      const keys = [
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        AccountMeta(poolKeys.id, false),
        AccountMetaReadonly(poolKeys.lpVault, false),
        AccountMeta(rewardVault, false),
        AccountMeta(userRewardToken, false),
        AccountMetaReadonly(userKeys.owner, true)
      ];
      const ins = new TransactionInstruction({
        programId: poolKeys.programId,
        keys,
        data
      });
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: [
              47
              /* farmV6Restart */
            ], instructions: [ins], signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeFarmCreatorAddRewardTokenInstructionSimple(params) {
    const { poolKeys } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 6) {
      return this.makeFarmCreatorAddRewardTokenInstructionV6Simple(params);
    }
    return logger8.throwArgumentError("invalid version", "version", version2);
  }
  static makeFarmCreatorAddRewardTokenInstructionV6Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      userKeys,
      newRewardInfo,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b, _c;
      const rewardVault = _Farm.getAssociatedLedgerPoolAccount({
        programId: poolKeys.programId,
        poolId: poolKeys.id,
        mint: newRewardInfo.rewardMint.equals(PublicKey.default) ? Token.WSOL.mint : newRewardInfo.rewardMint,
        type: "rewardVault"
      });
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let userRewardToken;
      if (newRewardInfo.rewardMint.equals(PublicKey.default)) {
        userRewardToken = yield Spl.insertCreateWrappedNativeAccount({
          connection,
          owner: userKeys.owner,
          payer: (_a = userKeys.payer) != null ? _a : userKeys.owner,
          instructions: frontInstructions,
          signers,
          amount: parseBigNumberish(newRewardInfo.rewardEndTime).sub(parseBigNumberish(newRewardInfo.rewardOpenTime)).mul(parseBigNumberish(newRewardInfo.rewardPerSecond)),
          instructionsType: frontInstructionsType
        });
        endInstructions.push(
          Spl.makeCloseAccountInstruction({
            programId: TOKEN_PROGRAM_ID,
            tokenAccount: userRewardToken,
            owner: userKeys.owner,
            payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
            instructionsType: endInstructionsType
          })
        );
      } else {
        userRewardToken = this._selectTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          tokenAccounts: userKeys.tokenAccounts,
          mint: newRewardInfo.rewardMint,
          owner: userKeys.owner,
          config: { associatedOnly: false }
        });
      }
      logger8.assertArgument(
        userRewardToken !== null,
        "cannot found target token accounts",
        "tokenAccounts",
        userKeys.tokenAccounts
      );
      if (userRewardToken === null) throw Error("cannot found target token accounts");
      const rewardMint = newRewardInfo.rewardMint.equals(PublicKey.default) ? Token.WSOL.mint : newRewardInfo.rewardMint;
      const LAYOUT = struct50([
        u8210("instruction"),
        u642("isSet"),
        u642("rewardPerSecond"),
        u642("rewardOpenTime"),
        u642("rewardEndTime"),
        u642("rewardType")
      ]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 4,
          isSet: new import_bn9.default(1),
          rewardPerSecond: parseBigNumberish(newRewardInfo.rewardPerSecond),
          rewardOpenTime: parseBigNumberish(newRewardInfo.rewardOpenTime),
          rewardEndTime: parseBigNumberish(newRewardInfo.rewardEndTime),
          rewardType: parseBigNumberish(poolTypeV6[newRewardInfo.rewardType])
        },
        data
      );
      const keys = [
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        AccountMetaReadonly(SYSTEM_PROGRAM_ID, false),
        AccountMetaReadonly(SYSVAR_RENT_PUBKEY, false),
        AccountMeta(poolKeys.id, false),
        AccountMetaReadonly(poolKeys.authority, false),
        AccountMetaReadonly(rewardMint, false),
        AccountMeta(rewardVault, false),
        AccountMeta(userRewardToken, false),
        AccountMetaReadonly(userKeys.owner, true)
      ];
      const ins = new TransactionInstruction({
        programId: poolKeys.programId,
        keys,
        data
      });
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: [
              48
              /* farmV6CreatorAddReward */
            ], instructions: [ins], signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeDepositInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      fetchPoolInfo,
      ownerInfo,
      amount,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a;
      const ownerMintToAccount = {};
      for (const item of ownerInfo.tokenAccounts) {
        if (associatedOnly) {
          const ata = getATAAddress(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
          if (ata.equals(item.pubkey)) ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        } else {
          ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const { lpVault, apiPoolInfo, ledger } = fetchPoolInfo;
      const lpMint = lpVault.mint;
      const ownerLpTokenAccount = ownerMintToAccount[lpMint.toString()];
      logger8.assertArgument(ownerLpTokenAccount, "you don't have any lp", "lp zero", ownerMintToAccount);
      const rewardAccounts = [];
      for (const itemReward of apiPoolInfo.rewardInfos) {
        const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token.WSOL.mint);
        const ownerRewardAccount = (_a = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          mint: itemReward.rewardMint,
          tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: rewardUseSOLBalance ? endInstructions : [],
            endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
        rewardAccounts.push(ownerRewardAccount);
      }
      const ledgerAddress = yield _Farm.getAssociatedLedgerAccount({
        programId: new PublicKey(apiPoolInfo.programId),
        poolId: new PublicKey(apiPoolInfo.id),
        owner: ownerInfo.wallet,
        version: apiPoolInfo.version
      });
      if (apiPoolInfo.version < 6 && !ledger) {
        const ins = _Farm.makeCreateAssociatedLedgerAccountInstruction({
          poolKeys,
          userKeys: {
            owner: ownerInfo.wallet,
            ledger: ledgerAddress
          }
        });
        frontInstructions.push(...ins.innerTransaction.instructions);
        frontInstructionsType.push(...ins.innerTransaction.instructionTypes);
      }
      const depositInstruction = _Farm.makeDepositInstruction({
        poolKeys,
        userKeys: {
          ledger: ledgerAddress,
          lpTokenAccount: ownerLpTokenAccount,
          owner: ownerInfo.wallet,
          rewardTokenAccounts: rewardAccounts
        },
        amount
      });
      return {
        address: depositInstruction.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            depositInstruction.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeWithdrawInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      fetchPoolInfo,
      ownerInfo,
      amount,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b;
      const ownerMintToAccount = {};
      for (const item of ownerInfo.tokenAccounts) {
        if (associatedOnly) {
          const ata = getATAAddress(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
          if (ata.equals(item.pubkey)) ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        } else {
          ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const withdrawInstructions = [];
      const withdrawInstructionsType = [];
      const signers = [];
      const { lpVault, wrapped, apiPoolInfo } = fetchPoolInfo;
      if (wrapped === void 0) throw Error("no lp");
      const lpMint = lpVault.mint;
      const lpMintUseSOLBalance = ownerInfo.useSOLBalance && lpMint.equals(Token.WSOL.mint);
      const ownerLpTokenAccount = (_a = ownerMintToAccount[lpMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: lpMint,
        tokenAccounts: lpMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: {
          connection,
          payer: ownerInfo.feePayer,
          amount: 0,
          frontInstructions,
          frontInstructionsType,
          signers
        },
        associatedOnly: lpMintUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      ownerMintToAccount[lpMint.toString()] = ownerLpTokenAccount;
      const rewardAccounts = [];
      for (const itemReward of apiPoolInfo.rewardInfos) {
        const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token.WSOL.mint);
        const ownerRewardAccount = (_b = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          mint: itemReward.rewardMint,
          tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: rewardUseSOLBalance ? endInstructions : [],
            endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
        rewardAccounts.push(ownerRewardAccount);
      }
      const ins = this.makeWithdrawInstruction({
        poolKeys: apiPoolInfo,
        userKeys: {
          ledger: this.getAssociatedLedgerAccount({
            programId: apiPoolInfo.programId,
            poolId: apiPoolInfo.id,
            owner: ownerInfo.wallet,
            version: apiPoolInfo.version
          }),
          lpTokenAccount: ownerLpTokenAccount,
          rewardTokenAccounts: rewardAccounts,
          owner: ownerInfo.wallet
        },
        amount
      });
      withdrawInstructions.push(...ins.innerTransaction.instructions);
      withdrawInstructionsType.push(...ins.innerTransaction.instructionTypes);
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: withdrawInstructionsType, instructions: withdrawInstructions, signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeHarvestAllRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      fetchPoolInfos,
      ownerInfo,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      var _a, _b;
      const ownerMintToAccount = {};
      for (const item of ownerInfo.tokenAccounts) {
        if (associatedOnly) {
          const ata = getATAAddress(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
          if (ata.equals(item.pubkey)) ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        } else {
          ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const harvestInstructions = [];
      const signers = [];
      for (const { lpVault, wrapped, apiPoolInfo, ledger } of Object.values(fetchPoolInfos)) {
        if (wrapped === void 0 || ledger === void 0 || !(wrapped.pendingRewards.find((i) => i.gt(ZERO)) !== void 0 || ledger.deposited.isZero()))
          continue;
        const lpMint = lpVault.mint;
        const lpMintUseSOLBalance = ownerInfo.useSOLBalance && lpMint.equals(Token.WSOL.mint);
        const ownerLpTokenAccount = (_a = ownerMintToAccount[lpMint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
          programId: TOKEN_PROGRAM_ID,
          mint: lpMint,
          tokenAccounts: lpMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            signers
          },
          associatedOnly: lpMintUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        ownerMintToAccount[lpMint.toString()] = ownerLpTokenAccount;
        const rewardAccounts = [];
        for (const itemReward of apiPoolInfo.rewardInfos) {
          const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.rewardMint.equals(Token.WSOL.mint);
          const ownerRewardAccount = (_b = ownerMintToAccount[itemReward.rewardMint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
            programId: TOKEN_PROGRAM_ID,
            mint: itemReward.rewardMint,
            tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.feePayer,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: rewardUseSOLBalance ? endInstructions : [],
              endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
              signers
            },
            associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          ownerMintToAccount[itemReward.rewardMint.toString()] = ownerRewardAccount;
          rewardAccounts.push(ownerRewardAccount);
        }
        const ins = this.makeWithdrawInstruction({
          poolKeys: apiPoolInfo,
          userKeys: {
            ledger: this.getAssociatedLedgerAccount({
              programId: apiPoolInfo.programId,
              poolId: apiPoolInfo.id,
              owner: ownerInfo.wallet,
              version: apiPoolInfo.version
            }),
            lpTokenAccount: ownerLpTokenAccount,
            rewardTokenAccounts: rewardAccounts,
            owner: ownerInfo.wallet
          },
          amount: 0
        });
        harvestInstructions.push(ins.innerTransaction);
      }
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...harvestInstructions,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  /**
   * @deprecated the method is **DANGEROUS**, please don't use
   */
  static makeV1InfoToV2PdaAndHarvestSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      wallet,
      tokenAccounts,
      programIdV3,
      programIdV5,
      makeTxVersion,
      lookupTableCache,
      computeBudgetConfig
    }) {
      const mintToAccount = {};
      for (const item of tokenAccounts) {
        const mint = item.accountInfo.mint;
        const ata = getATAAddress(wallet, mint, item.programId).publicKey;
        if (ata.equals(item.pubkey)) mintToAccount[mint.toString()] = ata;
        if (mintToAccount[mint.toString()] === void 0) mintToAccount[mint.toString()] = item.pubkey;
      }
      const dataInfoV3 = yield connection.getProgramAccounts(programIdV3, {
        filters: [{ memcmp: { offset: 40, bytes: wallet.toString() } }]
      });
      const dataInfoV5 = yield connection.getProgramAccounts(programIdV5, {
        filters: [{ memcmp: { offset: 40, bytes: wallet.toString() } }]
      });
      const poolIdToAccountV3 = {};
      const poolIdToAccountV5 = {};
      for (const item of dataInfoV3) {
        const layout = item.account.data.length === FARM_LEDGER_LAYOUT_V3_1.span ? FARM_LEDGER_LAYOUT_V3_1 : FARM_LEDGER_LAYOUT_V3_2;
        const info = layout.decode(item.account.data);
        const poolId = info.id.toString();
        const pda = this.getAssociatedLedgerAccount({
          programId: programIdV3,
          poolId: info.id,
          owner: wallet,
          version: 3
        });
        if (poolIdToAccountV3[poolId] === void 0) {
          poolIdToAccountV3[poolId] = { pda: void 0, other: [] };
        }
        if (pda.equals(item.pubkey)) {
          poolIdToAccountV3[poolId].pda = item.pubkey;
        } else {
          poolIdToAccountV3[poolId].other.push(item.pubkey);
        }
      }
      for (const item of dataInfoV5) {
        const layout = item.account.data.length === FARM_LEDGER_LAYOUT_V5_1.span ? FARM_LEDGER_LAYOUT_V5_1 : FARM_LEDGER_LAYOUT_V5_2;
        const info = layout.decode(item.account.data);
        const poolId = info.id.toString();
        const pda = this.getAssociatedLedgerAccount({
          programId: programIdV5,
          poolId: info.id,
          owner: wallet,
          version: 5
        });
        if (poolIdToAccountV5[poolId] === void 0) {
          poolIdToAccountV5[poolId] = { pda: void 0, other: [] };
        }
        if (pda.equals(item.pubkey)) {
          poolIdToAccountV5[poolId].pda = item.pubkey;
        } else {
          poolIdToAccountV5[poolId].other.push(item.pubkey);
        }
      }
      const needCheckPoolId = [
        ...Object.entries(poolIdToAccountV3).filter((i) => i[1].other.length > 0).map((i) => i[0]),
        ...Object.entries(poolIdToAccountV5).filter((i) => i[1].other.length > 0).map((i) => i[0])
      ];
      const allPoolInfo = yield connection.getMultipleAccountsInfo(needCheckPoolId.map((i) => new PublicKey(i)));
      const poolIdToInfo = {};
      for (let i = 0; i < needCheckPoolId.length; i++) {
        const id = needCheckPoolId[i];
        const info = allPoolInfo[i];
        if (info === null) continue;
        poolIdToInfo[id] = info.data;
      }
      const frontInstructions = [];
      const frontInstructionsType = [];
      const instructions = [];
      const endInstructions = [];
      const endInstructionsType = [];
      for (const [poolId, info] of Object.entries(poolIdToAccountV3)) {
        if (info.other.length === 0) continue;
        if (poolIdToInfo[poolId] === void 0) continue;
        const poolInfo = REAL_FARM_STATE_LAYOUT_V3.decode(poolIdToInfo[poolId]);
        const [_lpInfo, _rewardInfo] = yield connection.getMultipleAccountsInfo([poolInfo.lpVault, poolInfo.rewardVault]);
        if (_lpInfo === null || _rewardInfo === null) throw Error("get lp and reward info error");
        const lpInfo = SPL_ACCOUNT_LAYOUT.decode(_lpInfo.data);
        const rewardInfo = SPL_ACCOUNT_LAYOUT.decode(_rewardInfo.data);
        let lpAccount = mintToAccount[lpInfo.mint.toString()];
        if (lpAccount === void 0) {
          lpAccount = yield this._selectOrCreateTokenAccount({
            programId: _lpInfo.owner,
            mint: lpInfo.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: [],
              endInstructionsType: [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[lpInfo.mint.toString()] = lpAccount;
        }
        let rewardAccount = mintToAccount[rewardInfo.mint.toString()];
        if (rewardAccount === void 0) {
          rewardAccount = yield this._selectOrCreateTokenAccount({
            programId: _rewardInfo.owner,
            mint: rewardInfo.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: rewardInfo.mint.toString() === WSOL.mint ? endInstructions : [],
              endInstructionsType: rewardInfo.mint.toString() === WSOL.mint ? endInstructionsType : [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[rewardInfo.mint.toString()] = rewardAccount;
        }
        if (info.pda === void 0) {
          const _i2 = this.makeCreateAssociatedLedgerAccountInstructionV3({
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            poolKeys: { programId: programIdV3, id: new PublicKey(poolId) },
            userKeys: {
              ledger: this.getAssociatedLedgerAccount({
                programId: programIdV3,
                poolId: new PublicKey(poolId),
                owner: wallet,
                version: 3
              }),
              owner: wallet
            }
          });
          instructions.push(_i2.innerTransaction);
        }
        const _i = this.makeDepositInstructionV3({
          amount: 0,
          userKeys: {
            ledger: this.getAssociatedLedgerAccount({
              programId: programIdV3,
              poolId: new PublicKey(poolId),
              owner: wallet,
              version: 3
            }),
            owner: wallet,
            lpTokenAccount: lpAccount,
            rewardTokenAccounts: [rewardAccount],
            auxiliaryLedgers: info.other
          },
          poolKeys: {
            programId: programIdV3,
            id: new PublicKey(poolId),
            authority: this.getAssociatedAuthority({ programId: programIdV3, poolId: new PublicKey(poolId) }).publicKey,
            lpVault: poolInfo.lpVault,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            rewardInfos: [{ rewardVault: poolInfo.rewardVault }]
          }
        });
        instructions.push(_i.innerTransaction);
      }
      for (const [poolId, info] of Object.entries(poolIdToAccountV5)) {
        if (info.other.length === 0) continue;
        if (poolIdToInfo[poolId] === void 0) continue;
        const poolInfo = REAL_FARM_STATE_LAYOUT_V5.decode(poolIdToInfo[poolId]);
        const [_lpInfo, _rewardInfoA, _rewardInfoB] = yield connection.getMultipleAccountsInfo([
          poolInfo.lpVault,
          poolInfo.rewardVaultA,
          poolInfo.rewardVaultB
        ]);
        if (_lpInfo === null || _rewardInfoA === null || _rewardInfoB === null)
          throw Error("get lp and reward A / B info error");
        const lpInfo = SPL_ACCOUNT_LAYOUT.decode(_lpInfo.data);
        const rewardInfoA = SPL_ACCOUNT_LAYOUT.decode(_rewardInfoA.data);
        const rewardInfoB = SPL_ACCOUNT_LAYOUT.decode(_rewardInfoB.data);
        let lpAccount = mintToAccount[lpInfo.mint.toString()];
        if (lpAccount === void 0) {
          lpAccount = yield this._selectOrCreateTokenAccount({
            programId: _lpInfo.owner,
            mint: lpInfo.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: [],
              endInstructionsType: [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[lpInfo.mint.toString()] = lpAccount;
        }
        let rewardAccountA = mintToAccount[rewardInfoA.mint.toString()];
        if (rewardAccountA === void 0) {
          rewardAccountA = yield this._selectOrCreateTokenAccount({
            programId: _rewardInfoA.owner,
            mint: rewardInfoA.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: rewardInfoA.mint.toString() === WSOL.mint ? endInstructions : [],
              endInstructionsType: rewardInfoA.mint.toString() === WSOL.mint ? endInstructionsType : [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[rewardInfoA.mint.toString()] = rewardAccountA;
        }
        let rewardAccountB = mintToAccount[rewardInfoB.mint.toString()];
        if (rewardAccountB === void 0) {
          rewardAccountB = yield this._selectOrCreateTokenAccount({
            programId: _rewardInfoB.owner,
            mint: rewardInfoB.mint,
            tokenAccounts: [],
            owner: wallet,
            createInfo: {
              connection,
              payer: wallet,
              amount: 0,
              frontInstructions,
              frontInstructionsType,
              endInstructions: rewardInfoB.mint.toString() === WSOL.mint ? endInstructions : [],
              endInstructionsType: rewardInfoB.mint.toString() === WSOL.mint ? endInstructionsType : [],
              signers: []
            },
            associatedOnly: true,
            checkCreateATAOwner: true
          });
          mintToAccount[rewardInfoB.mint.toString()] = rewardAccountB;
        }
        if (info.pda === void 0) {
          const _i2 = this.makeCreateAssociatedLedgerAccountInstructionV5({
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            poolKeys: { programId: programIdV5, id: new PublicKey(poolId) },
            userKeys: {
              ledger: this.getAssociatedLedgerAccount({
                programId: programIdV5,
                poolId: new PublicKey(poolId),
                owner: wallet,
                version: 5
              }),
              owner: wallet
            }
          });
          instructions.push(_i2.innerTransaction);
        }
        const _i = this.makeDepositInstructionV5({
          amount: 0,
          userKeys: {
            ledger: this.getAssociatedLedgerAccount({
              programId: programIdV5,
              poolId: new PublicKey(poolId),
              owner: wallet,
              version: 5
            }),
            owner: wallet,
            lpTokenAccount: lpAccount,
            rewardTokenAccounts: [rewardAccountA, rewardAccountB],
            auxiliaryLedgers: info.other
          },
          poolKeys: {
            programId: programIdV5,
            id: new PublicKey(poolId),
            authority: this.getAssociatedAuthority({ programId: programIdV5, poolId: new PublicKey(poolId) }).publicKey,
            lpVault: poolInfo.lpVault,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            rewardInfos: [{ rewardVault: poolInfo.rewardVaultA }, { rewardVault: poolInfo.rewardVaultB }]
          }
        });
        instructions.push(_i.innerTransaction);
      }
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: wallet,
          innerTransaction: [
            {
              instructionTypes: frontInstructionsType.slice(0, 10),
              instructions: frontInstructions.slice(0, 10),
              signers: []
            },
            ...frontInstructions.length > 10 ? [
              {
                instructionTypes: frontInstructionsType.slice(10),
                instructions: frontInstructions.slice(10),
                signers: []
              }
            ] : [],
            ...instructions,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeDepositTokenInstruction(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      governanceProgramId,
      voteWeightAddinProgramId,
      realm,
      communityTokenMint,
      owner,
      poolId
    }) {
      const registrar = getRegistrarAddress(voteWeightAddinProgramId, realm, communityTokenMint).publicKey;
      const ownerPda = this.getAssociatedLedgerAccount({ programId, poolId, owner, version: 3 });
      const ownerAccountInfo = yield connection.getAccountInfo(ownerPda);
      if (ownerAccountInfo === null) {
        throw Error("user is not staker");
      }
      const ownerInfo = FARM_LEDGER_LAYOUT_V3_2.decode(ownerAccountInfo.data);
      const mintAmount = ownerInfo.deposited.sub(ownerInfo.voteLockedBalance);
      if (mintAmount.eq(ZERO)) {
        throw Error("user do not has new stake amount");
      }
      const votingMint = getVotingTokenMint(programId, poolId).publicKey;
      const votingMintAuthority = getVotingMintAuthority(programId, poolId).publicKey;
      const { publicKey: voter, nonce: voterBump } = getVoterAddress(voteWeightAddinProgramId, registrar, owner);
      const voterVault = getATAAddress(voter, votingMint, TOKEN_PROGRAM_ID).publicKey;
      const { publicKey: voterWeightRecord, nonce: voterWeightRecordBump } = getVoterWeightRecordAddress(
        voteWeightAddinProgramId,
        registrar,
        owner
      );
      const tokenOwnerRecordAddress = getTokenOwnerRecordAddress(
        governanceProgramId,
        realm,
        communityTokenMint,
        owner
      ).publicKey;
      const instructions = [];
      const depositToken = getATAAddress(owner, votingMint, TOKEN_PROGRAM_ID).publicKey;
      const depositTokenAccountInfo = yield connection.getAccountInfo(depositToken);
      if (depositTokenAccountInfo === null) {
        instructions.push(
          Spl.makeCreateAssociatedTokenAccountInstruction({
            programId: TOKEN_PROGRAM_ID,
            mint: votingMint,
            associatedAccount: depositToken,
            owner,
            payer: owner,
            instructionsType: []
          })
        );
      }
      const voterAccountInfo = yield connection.getAccountInfo(voter);
      if (voterAccountInfo === null) {
        const createTokenOwnerRecodeIns = governanceCreateTokenOwnerRecord(
          governanceProgramId,
          realm,
          owner,
          communityTokenMint,
          owner,
          tokenOwnerRecordAddress
        );
        instructions.push(
          createTokenOwnerRecodeIns,
          voterStakeRegistryCreateVoter(
            voteWeightAddinProgramId,
            registrar,
            voter,
            voterWeightRecord,
            owner,
            owner,
            voterBump,
            voterWeightRecordBump
          )
        );
      }
      const { index: depositEntryIndex, isInit: depositEntryInit } = yield getDepositEntryIndex(
        connection,
        registrar,
        voter,
        votingMint
      );
      if (!depositEntryInit) {
        instructions.push(
          voterStakeRegistryCreateDepositEntry(
            voteWeightAddinProgramId,
            registrar,
            voter,
            voterVault,
            owner,
            owner,
            votingMint,
            depositEntryIndex,
            0,
            void 0,
            0,
            false
          )
        );
      }
      instructions.push(
        voterStakeRegistryDeposit(
          voteWeightAddinProgramId,
          registrar,
          voter,
          voterVault,
          depositToken,
          owner,
          ownerPda,
          poolId,
          votingMint,
          votingMintAuthority,
          programId,
          depositEntryIndex,
          mintAmount
        ),
        voterStakeRegistryUpdateVoterWeightRecord(voteWeightAddinProgramId, registrar, voter, voterWeightRecord)
      );
      return {
        address: {},
        innerTransaction: {
          instructions,
          signers: [],
          lookupTableAddress: [],
          instructionTypes: Array(instructions.length).fill(
            50
            /* test */
          )
        }
      };
    });
  }
  static makeWithdrawTokenInstruction(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      governanceProgramId,
      voteWeightAddinProgramId,
      realm,
      communityTokenMint,
      owner,
      poolId
    }) {
      const registrar = getRegistrarAddress(voteWeightAddinProgramId, realm, communityTokenMint).publicKey;
      const ownerPda = this.getAssociatedLedgerAccount({ programId, poolId, owner, version: 3 });
      const ownerAccountInfo = yield connection.getAccountInfo(ownerPda);
      if (ownerAccountInfo === null) {
        throw Error("user is not staker");
      }
      const ownerInfo = FARM_LEDGER_LAYOUT_V3_2.decode(ownerAccountInfo.data);
      if (ownerInfo.voteLockedBalance.eq(ZERO)) {
        throw Error("user has vote locked balance = 0");
      }
      const votingMint = getVotingTokenMint(programId, poolId).publicKey;
      const votingMintAuthority = getVotingMintAuthority(programId, poolId).publicKey;
      const { publicKey: voter } = getVoterAddress(voteWeightAddinProgramId, registrar, owner);
      const voterVault = getATAAddress(voter, votingMint, TOKEN_PROGRAM_ID).publicKey;
      const { publicKey: voterWeightRecord } = getVoterWeightRecordAddress(voteWeightAddinProgramId, registrar, owner);
      const tokenOwnerRecordAddress = getTokenOwnerRecordAddress(
        governanceProgramId,
        realm,
        communityTokenMint,
        owner
      ).publicKey;
      const instructions = [];
      const { index: depositEntryIndex, isInit: depositEntryInit } = yield getDepositEntryIndex(
        connection,
        registrar,
        voter,
        votingMint
      );
      if (!depositEntryInit) throw Error("deposit entry index check error");
      instructions.push(
        voterStakeRegistryWithdraw(
          voteWeightAddinProgramId,
          registrar,
          voter,
          owner,
          tokenOwnerRecordAddress,
          voterWeightRecord,
          voterVault,
          getATAAddress(owner, votingMint, TOKEN_PROGRAM_ID).publicKey,
          ownerPda,
          poolId,
          votingMint,
          votingMintAuthority,
          programId,
          depositEntryIndex,
          ownerInfo.voteLockedBalance
        )
      );
      return {
        address: {},
        innerTransaction: {
          instructions,
          signers: [],
          lookupTableAddress: [],
          instructionTypes: Array(instructions.length).fill(
            50
            /* test */
          )
        }
      };
    });
  }
};
function getDepositEntryIndex(connection, registrar, voter, voterMint) {
  return __async(this, null, function* () {
    const registrarAccountData = yield connection.getAccountInfo(registrar);
    if (registrarAccountData === null) throw Error("registrar info check error");
    const registrarData = VoterRegistrar.decode(registrarAccountData.data);
    const votingMintConfigIndex = registrarData.votingMints.findIndex((i) => i.mint.equals(voterMint));
    if (votingMintConfigIndex === -1) throw Error("find voter mint error");
    const voterAccountData = yield connection.getAccountInfo(voter);
    if (voterAccountData === null) return { index: votingMintConfigIndex, isInit: false };
    const voterData = Voter.decode(voterAccountData.data);
    const depositEntryIndex = voterData.deposits.findIndex(
      (i) => i.isUsed && i.votingMintConfigIdx === votingMintConfigIndex
    );
    if (depositEntryIndex === -1) return { index: votingMintConfigIndex, isInit: false };
    else return { index: depositEntryIndex, isInit: true };
  });
}
var MAINNET_FARM_POOLS = [
  {
    id: "AvbVWpBi2e4C9HPmZgShGdPoNydG4Yw8GJvG9HUcLgce",
    lp: MAINNET_LP_TOKENS.RAY_USDT_V4,
    version: 3
  },
  {
    id: "4EwbZo8BZXP5313z5A2H11MRBP15M5n6YxfmkjXESKAW",
    lp: MAINNET_SPL_TOKENS.RAY,
    version: 3
  },
  {
    id: "XnRBbNMf6YcWvC1u2vBXXuMcagmRBRLu1y84mpqnKwW",
    lp: MAINNET_LP_TOKENS.xCOPE_USDC_V4,
    version: 5
  },
  {
    id: "8xhjCzfzVcP79jE7jXR2xtNaSL6aJYoDRLVT9FMjpRTC",
    lp: MAINNET_LP_TOKENS.STEP_USDC_V4,
    version: 5
  },
  {
    id: "Ef1gD9JMzWF6PNw2uc4744zouh57GyWAeVTjHHbQ2nsu",
    lp: MAINNET_LP_TOKENS.MEDIA_USDC_V4,
    version: 5
  },
  {
    id: "AxVvbT9fDFEkmdLwKUJRY5HsG2RXAZbe1dRAgJ2bDDwg",
    lp: MAINNET_LP_TOKENS.COPE_USDC_V4,
    version: 5
  },
  {
    id: "D4pYuD4tbir9KBsb7Kr63v9e86JY2UoUZeFK9eHKQFZM",
    lp: MAINNET_LP_TOKENS.MER_USDC_V4,
    version: 5
  },
  {
    id: "BLy8KuRck5bcJkQdMDLSZnL1Ka4heAZSGiwTJfEfY727",
    lp: MAINNET_LP_TOKENS.ROPE_USDC_V4,
    version: 5
  },
  {
    id: "JAP8SFagJBm6vt2LoFGNeSJ1hKDZ2p3yXb3CvBx11How",
    lp: MAINNET_LP_TOKENS.ALEPH_USDC_V4,
    version: 5
  },
  {
    id: "7U8Z6TWQMtsMcHV2htALnF9VQonnD1MrVm17YtmGEGEw",
    lp: MAINNET_LP_TOKENS.TULIP_USDC_V4,
    version: 5
  },
  {
    id: "31QSh1TwgoA9GbvkgfEEwKEm11t8CR4KiQr6WCyJr7EN",
    lp: MAINNET_LP_TOKENS.SNY_USDC_V4,
    version: 5
  },
  {
    id: "EEe8b72w5q6T86nYRNJdFcY25tznPzrd1jGjuxZ7f9mX",
    lp: MAINNET_LP_TOKENS.BOP_RAY_V4,
    version: 5
  },
  {
    id: "5PVVwSqwzkCvuiKEZwWkM35ApBnoWqF8XopsVZjPwA8z",
    lp: MAINNET_LP_TOKENS.SLRS_USDC_V4,
    version: 5
  },
  {
    id: "Bw932pURVJRYjEJwRZGWjfUNpeyz18kjMNdb833eMxoj",
    lp: MAINNET_LP_TOKENS.SAMO_RAY_V4,
    version: 5
  },
  {
    id: "BRM5bdX2mjmFGg2RAent1Whd61o9asQD16BXsC6QvEni",
    lp: MAINNET_LP_TOKENS.LIKE_USDC_V4,
    version: 5
  },
  {
    id: "HUDr9BDaAGqi37xbQHzxCyXvfMCKPTPNF8g9c9bPu1Fu",
    lp: MAINNET_LP_TOKENS.RAY_SOL_V4,
    version: 3
  },
  {
    id: "CHYrUBX2RKX8iBg7gYTkccoGNBzP44LdaazMHCLcdEgS",
    lp: MAINNET_LP_TOKENS.RAY_USDC_V4,
    version: 3
  },
  {
    id: "B6fbnZZ7sbKHR18ffEDD5Nncgp54iKN1GbCgjTRdqhS1",
    lp: MAINNET_LP_TOKENS.RAY_ETH_V4,
    version: 3
  },
  {
    id: "5DFbcYNLLy5SJiBpCCDzNSs7cWCsUbYnCkLXzcPQiKnR",
    lp: MAINNET_LP_TOKENS.RAY_SRM_V4,
    version: 3
  },
  {
    id: "GzEDEkHSFFfxKMu3Toww1nrEjtbQGJKRPNRK1Pfd59Zn",
    lp: MAINNET_LP_TOKENS.MNGO_USDC_V4,
    version: 5
  },
  {
    id: "CM9XTJfXEHceGPXhmXxheR87Ng9CZ4jiBoTVQHhs9DVN",
    lp: MAINNET_LP_TOKENS.COPE_RAY_V4,
    version: 5
  },
  {
    id: "AMcVWK66iexwwCHn8drxywdNr2UgH3vmRzLXQFdErGmL",
    lp: MAINNET_LP_TOKENS.LIKE_RAY_V4,
    version: 5
  },
  {
    id: "DJfvL6srBht8XFMWYuuKHYGainqvwXyA5icVsDne3pwN",
    lp: MAINNET_LP_TOKENS.MEDIA_RAY_V4,
    version: 5
  },
  {
    id: "21xhrT4j8QnaBvj3QjhP5kZu8sXJMCE7hzHKGtWEkdKr",
    lp: MAINNET_LP_TOKENS.MER_RAY_V4,
    version: 5
  },
  {
    id: "J61AnYYSwjtJ4wDqEqqWSBuZbiR2SDDrtF7FFobutM6a",
    lp: MAINNET_LP_TOKENS.SLRS_RAY_V4,
    version: 5
  },
  {
    id: "JEC3P83x2GEijYDwXiksuh5H6YrQt5xW6MC2GDKkMoe",
    lp: MAINNET_LP_TOKENS.SNY_RAY_V4,
    version: 5
  },
  {
    id: "BmbG9hv5PazcW3rYWvatA6HpNPkozEdkWBiU64pZxuwr",
    lp: MAINNET_LP_TOKENS.TULIP_RAY_V4,
    version: 5
  },
  {
    id: "4wvZ9SwWaHKTpshQbCSKQoPosZp9KGwUzuQdESi39qPn",
    lp: MAINNET_LP_TOKENS.ALEPH_RAY_V4,
    version: 5
  },
  {
    id: "BnYoq5y2MoH4TsBHeEZrEPowhwebHxQq7nJW1vTjPTWu",
    lp: MAINNET_LP_TOKENS.RAY_SRM_V4,
    version: 5
  },
  {
    id: "93wRz2LeQ3TJoair827VTng62MjCzYDgJjG9Q5GmQ3Pd",
    lp: MAINNET_LP_TOKENS.ATLAS_USDC_V4,
    version: 5
  },
  {
    id: "7qcihXTsRW5wS5BgK7iuD84W43ECByoJP45R3hu2r6mF",
    lp: MAINNET_LP_TOKENS.POLIS_USDC_V4,
    version: 5
  },
  {
    id: "BHHhNLdJn69K1XPJcpcw4MBY3TPetpLxhj8s4K4ydsDV",
    lp: MAINNET_LP_TOKENS.ATLAS_RAY_V4,
    version: 5
  },
  {
    id: "HHm8Pgnzc56fTUYkicPv4DqGYp5fcPZFV1V1uhixSrMk",
    lp: MAINNET_LP_TOKENS.POLIS_RAY_V4,
    version: 5
  },
  {
    id: "8GBa1cK1NxevoxiRNK6YW9tWuo2xftcA3as9Cu4nhFL7",
    lp: MAINNET_LP_TOKENS.GRAPE_USDC_V4,
    version: 5
  },
  {
    id: "HzxveT6pUMwYByqnScvTbpUv4avzkUDrDpS9D7DToEry",
    lp: MAINNET_LP_TOKENS.LARIX_USDC_V4,
    version: 5
  },
  {
    id: "Fbwy4XWMjXuP1nXg4xph4RJ9E9twVXeknXokF38PVgG1",
    lp: MAINNET_LP_TOKENS.LARIX_RAY_V4,
    version: 5
  },
  {
    id: "5gzQgxaKAU13SZeffmjjE2y9HwMJ42FxQkqJhJ5nqHeh",
    lp: MAINNET_LP_TOKENS.stSOL_USDC_V4,
    version: 5
  },
  {
    id: "914jyHBQFiroKFVCpKkzjGSaZyr4gMwgxE7snbNfGjnL",
    lp: MAINNET_LP_TOKENS.BTC_mSOL_V4,
    version: 5
  },
  {
    id: "54vUWjEmg9wfCsZF7wwq2HJu5BU3cfDFAQQQgXPECcwE",
    lp: MAINNET_LP_TOKENS.ETH_mSOL_V4,
    version: 5
  },
  {
    id: "HxhxYASqdLcR6yehT9hB9HUpgcF1R2t9HtkHdngGZ2Dh",
    lp: MAINNET_LP_TOKENS.mSOL_USDT_V4,
    version: 5
  },
  {
    id: "97N6tPMVCrAunC9embwTcffye9xC95fA5y3LauhNZ444",
    lp: MAINNET_LP_TOKENS.MNDE_mSOL_V4,
    version: 5
  },
  {
    id: "DjtZxyFBgifzpaZEzfsWXogNX5zUCnTRXJqarGe9CiSv",
    lp: MAINNET_LP_TOKENS.mSOL_USDC_V4,
    version: 5
  },
  {
    id: "7wNhbTS6XQczXs52wcVmfiodRMPfycB3YaG52dWWY6SD",
    lp: MAINNET_LP_TOKENS.mSOL_RAY_V4,
    version: 5
  },
  {
    id: "CzKUrVbP7hH8EjcHNc55ZFW33rJyLQ2r52bxCzaGTpz",
    lp: MAINNET_LP_TOKENS.LIQ_USDC_V4,
    version: 5
  },
  {
    id: "5XdeFdcJoCAPMfgYndMPcsijFBKFp2cPSCjrCZzmpTE5",
    lp: MAINNET_LP_TOKENS.LIQ_RAY_V4,
    version: 5
  },
  {
    id: "Gf3qFzKnGvMCVMQZERW2Qso5uEYxd9B9kWZZHsrMmmHj",
    lp: MAINNET_LP_TOKENS.SYP_RAY_V4,
    version: 5
  },
  {
    id: "2pQQnoNpm5LoG6sZs5toNBXi4m1Pj3ExXdggPQYyiP2x",
    lp: MAINNET_LP_TOKENS.SYP_SOL_V4,
    version: 5
  },
  {
    id: "Byt2kL5qi45pMpdAsNNciKZ8HLp7oU5jizCbyARLtQJy",
    lp: MAINNET_LP_TOKENS.SYP_USDC_V4,
    version: 5
  },
  {
    id: "8W2TqGCiFiqR1JD4sbW8uTRjV2HvFjLhkZ2tAQTYE4Gc",
    lp: MAINNET_LP_TOKENS.WOOF_RAY_V4,
    version: 5
  },
  {
    id: "FgApVk6mASrkuWNxmsFvsaAYkFKqdiwMTvYZK36A2DaC",
    lp: MAINNET_LP_TOKENS.KIN_RAY_V4,
    version: 5
  },
  {
    id: "AwUDfg4NYbLQRAcFipoJwyZTpqNvw5v6C7EypryL12Y6",
    lp: MAINNET_LP_TOKENS.STARS_USDC_V4,
    version: 5
  },
  {
    id: "Gi3Z6TXeH1ZhCCbwg6oJL8SE4LcmxmGRNhhfA6NZhwTK",
    lp: MAINNET_LP_TOKENS.weWETH_SOL_V4,
    version: 5
  },
  {
    id: "8JJSdD1ca5SDtGCEm3yBbQKek2FvJ1EbNt9q2ET3E9Jt",
    lp: MAINNET_LP_TOKENS.weWETH_USDC_V4,
    version: 5
  },
  {
    id: "6X495xkPWkw9SQFYf7yL1K8QooZyaeEQ6u7yMWNNZxNV",
    lp: MAINNET_LP_TOKENS.weUNI_USDC_V4,
    version: 5
  },
  {
    id: "AuyqPBiY6sNUpH6jx415NGcdvNdYbkbYsyVabUqEVdkj",
    lp: MAINNET_LP_TOKENS.weSUSHI_USDC_V4,
    version: 5
  },
  {
    id: "7fe8QcJ6W2kHKL1h1HMYYJoGXz2LUcwCjkxX6MX35orK",
    lp: MAINNET_LP_TOKENS.weAXS_USDC_V4,
    version: 5
  },
  {
    id: "C8BjS9DGDvC2zS3n6fTvm1rjPbA33uZ7CAvEUZ3tg7aM",
    lp: MAINNET_LP_TOKENS.weDYDX_USDC_V4,
    version: 5
  },
  {
    id: "CZZnmfvSgNVUiDBG4wN2NNcaYbsKDN4kLsc3SN8DMw6i",
    lp: MAINNET_LP_TOKENS.weSHIB_USDC_V4,
    version: 5
  },
  {
    id: "FAKzZoGVCEBDRuHN4gDswAx7PsocCorDqH6dQaxnyorT",
    lp: MAINNET_LP_TOKENS.weSAND_USDC_V4,
    version: 5
  },
  {
    id: "EBS8tc4proQE2Fj6HxU4piiZP8oiDrvyJUijDCX7P7QN",
    lp: MAINNET_LP_TOKENS.weMANA_USDC_V4,
    version: 5
  },
  {
    id: "6AxxjJhAz6APspTQM4vVCHgfzEyZgBTCogJLdai7bXYE",
    lp: MAINNET_LP_TOKENS.wbWBNB_USDC_V4,
    version: 5
  },
  {
    id: "3HGPRHH3XFFu972MR1EdS65qc1nN9sM7miZtFTi6QcEd",
    lp: MAINNET_LP_TOKENS.wePEOPLE_USDC_V4,
    version: 5
  },
  {
    id: "27bysJaX5eu5Urb5kftR66otiVc6DKK7TnifKwnpNzYu",
    lp: MAINNET_LP_TOKENS.SRM_USDC_V4,
    version: 5
  },
  {
    id: "FDnxy4NkJVG3GNMMrtUZmUmoYeYE34YRDwCYTi1yBTM",
    lp: MAINNET_LP_TOKENS.CAVE_USDC_V4,
    version: 5
  },
  {
    id: "DDRNVVJBEXEemcprVVUcrTbYnR88JyN6jjT2ypgAQHC8",
    lp: MAINNET_LP_TOKENS.GENE_USDC_V4,
    version: 5
  },
  {
    id: "GVfLbXA3dpEHPvc4do9HvMZ8TACxm3x54BVrHPMEixcr",
    lp: MAINNET_LP_TOKENS.GENE_RAY_V4,
    version: 5
  },
  {
    id: "7NZ18KhsSdJBQkJEJwhEHfdaPRNdbMd17CMoxsKxavEo",
    lp: MAINNET_LP_TOKENS.CWAR_USDC_V4,
    version: 5
  },
  {
    id: "5Mdq5o3KKPyeVVBsbnivVk9qCATjfEQ22oysXVsd2DvJ",
    lp: MAINNET_LP_TOKENS.SONAR_USDC_V4,
    version: 5
  },
  {
    id: "7W8BKbMgcVpGYvTgEK758pJgDRZJ9WafKfgkV1XCkP33",
    lp: MAINNET_LP_TOKENS.APT_USDC_V4,
    version: 5
  },
  {
    id: "CgokwBwwdYsgo8hbUMtJ3GoNM3bVjvMcmaPrVvCw4sBi",
    lp: MAINNET_LP_TOKENS.SHILL_USDC_V4,
    version: 5
  },
  {
    id: "AWbmotuJS7NLBmra9ctbfVR1BnoHmiG1HGW6hm49TuRZ",
    lp: MAINNET_LP_TOKENS.DFL_USDC_V4,
    version: 5
  },
  {
    id: "665VvECKsLpXN4fLy8GYbyQpGJRNkxRx56X93U9FVSbv",
    lp: MAINNET_LP_TOKENS.BOKU_USDC_V4,
    version: 5
  },
  {
    id: "7yk1XUWmZpWMCoFpUT985z61UNTypyBGgZF3JpKgcwmL",
    lp: MAINNET_LP_TOKENS.MIMO_SOL_V4,
    version: 5
  },
  {
    id: "E5L4Bx3Lsif7bDb9XMWi5guHUt4kkYpbqQ4CbmnRjHs1",
    lp: MAINNET_LP_TOKENS.XTAG_USDC_V4,
    version: 5
  },
  {
    id: "HtvQ5AEvu8sDM7C1oB4r5fJ5E2Q1wsJ4TADwNMqR9ccF",
    lp: MAINNET_LP_TOKENS.TTT_USDC_V4,
    version: 5
  },
  {
    id: "GUzaohfNuFbBqQTnPgPSNciv3aUvriXYjQduRE3ZkqFw",
    lp: MAINNET_LP_TOKENS.SOL_USDC_V4,
    version: 5
  },
  {
    id: "5r878BSWPtoXgnqaeFJi7BCycKZ5CodBB2vS9SeiV8q",
    lp: MAINNET_LP_TOKENS.SOL_USDT_V4,
    version: 5
  },
  {
    id: "3J3SYLeFZWKnUCsrPzikw9bcD9vRs7YNGfmg7ZSg3tsK",
    lp: MAINNET_LP_TOKENS.RUN_USDC_V4,
    version: 5
  },
  {
    id: "BYmeWrwA4ixvJhNrxWzQsA3Fsz6EtUDJTo39WYZ6o1FS",
    lp: MAINNET_LP_TOKENS.CRWNY_RAY_V4,
    version: 5
  },
  {
    id: "6VNF4rF7ESUohzNeRf3aTg61dyFjbab749RGUHCTDFQL",
    lp: MAINNET_LP_TOKENS.CRWNY_USDC_V4,
    version: 5
  },
  {
    id: "7RQDGZ1cvHcREu211R35WSKHFjTxM5dmJHeFAWag29BA",
    lp: MAINNET_LP_TOKENS.REAL_USDC_V4,
    version: 5
  },
  {
    id: "ELovJ3jDKMiWhCUCdZzPfTeVmQwhj4cvYuGwS8FfhEtJ",
    lp: MAINNET_LP_TOKENS.BLOCK_USDC_V4,
    version: 5
  },
  {
    id: "36Rf8dzq5gy4Ew2bLQEgKoCKVTku4EJPLqFYG6mzFrkr",
    lp: MAINNET_LP_TOKENS.FRKT_SOL_V4,
    version: 5
  },
  {
    id: "HXpQJeAcBCKfGY6YhZgBocZGgV4xApPVK7r8CPXfvCin",
    lp: MAINNET_LP_TOKENS.FRKT_USDC_V4,
    version: 5
  },
  {
    id: "Eqn7unnxmneDuTuXQ7EAN1wBkHMFD4LgCCAkCdPA9KbV",
    lp: MAINNET_LP_TOKENS.MBS_USDC_V4,
    version: 5
  },
  {
    id: "DtU5pZB99rVtxe5qe5hQa2rRpw7poFiqaHvMAbPgT2TM",
    lp: MAINNET_LP_TOKENS.PRISM_USDC_V4,
    version: 5
  },
  {
    id: "Gue2c9J2aRtY3aJ1HEwabQznwg2MUt9d9kUyr6otujR",
    lp: MAINNET_LP_TOKENS.CHICKS_USDC_V4,
    version: 5
  },
  {
    id: "Ej7iBkW79EdF26RxaRQfGo58PqRdzHzRmE4C2e3z3dPY",
    lp: MAINNET_LP_TOKENS.MEAN_RAY_V4,
    version: 5
  },
  {
    id: "Bd1hAsMAghtCjK38Ut4m938Ep7zyEp2TydQ7G35nPvUj",
    lp: MAINNET_LP_TOKENS.TINY_USDC_V4,
    version: 5
  },
  {
    id: "2G7qTQzw3KXm7WEMJf2izqFQWh8CLZ1wFbQVP5qo3ME9",
    lp: MAINNET_LP_TOKENS.SCY_USDC_V4,
    version: 5
  }
];
var TESTNET_FARM_POOLS = [];
var DEVNET_FARM_POOLS = [];
var LIQUIDITY_STATE_LAYOUT_V4 = struct50([
  u642("status"),
  u642("nonce"),
  u642("maxOrder"),
  u642("depth"),
  u642("baseDecimal"),
  u642("quoteDecimal"),
  u642("state"),
  u642("resetFlag"),
  u642("minSize"),
  u642("volMaxCutRatio"),
  u642("amountWaveRatio"),
  u642("baseLotSize"),
  u642("quoteLotSize"),
  u642("minPriceMultiplier"),
  u642("maxPriceMultiplier"),
  u642("systemDecimalValue"),
  u642("minSeparateNumerator"),
  u642("minSeparateDenominator"),
  u642("tradeFeeNumerator"),
  u642("tradeFeeDenominator"),
  u642("pnlNumerator"),
  u642("pnlDenominator"),
  u642("swapFeeNumerator"),
  u642("swapFeeDenominator"),
  u642("baseNeedTakePnl"),
  u642("quoteNeedTakePnl"),
  u642("quoteTotalPnl"),
  u642("baseTotalPnl"),
  u642("poolOpenTime"),
  u642("punishPcAmount"),
  u642("punishCoinAmount"),
  u642("orderbookToInitTime"),
  // u128('poolTotalDepositPc'),
  // u128('poolTotalDepositCoin'),
  u128("swapBaseInAmount"),
  u128("swapQuoteOutAmount"),
  u642("swapBase2QuoteFee"),
  u128("swapQuoteInAmount"),
  u128("swapBaseOutAmount"),
  u642("swapQuote2BaseFee"),
  // amm vault
  publicKey2("baseVault"),
  publicKey2("quoteVault"),
  // mint
  publicKey2("baseMint"),
  publicKey2("quoteMint"),
  publicKey2("lpMint"),
  // market
  publicKey2("openOrders"),
  publicKey2("marketId"),
  publicKey2("marketProgramId"),
  publicKey2("targetOrders"),
  publicKey2("withdrawQueue"),
  publicKey2("lpVault"),
  publicKey2("owner"),
  // true circulating supply without lock up
  u642("lpReserve"),
  seq22(u642(), 3, "padding")
]);
var LIQUIDITY_STATE_LAYOUT_V5 = struct50([
  u642("accountType"),
  u642("status"),
  u642("nonce"),
  u642("maxOrder"),
  u642("depth"),
  u642("baseDecimal"),
  u642("quoteDecimal"),
  u642("state"),
  u642("resetFlag"),
  u642("minSize"),
  u642("volMaxCutRatio"),
  u642("amountWaveRatio"),
  u642("baseLotSize"),
  u642("quoteLotSize"),
  u642("minPriceMultiplier"),
  u642("maxPriceMultiplier"),
  u642("systemDecimalsValue"),
  u642("abortTradeFactor"),
  u642("priceTickMultiplier"),
  u642("priceTick"),
  // Fees
  u642("minSeparateNumerator"),
  u642("minSeparateDenominator"),
  u642("tradeFeeNumerator"),
  u642("tradeFeeDenominator"),
  u642("pnlNumerator"),
  u642("pnlDenominator"),
  u642("swapFeeNumerator"),
  u642("swapFeeDenominator"),
  // OutPutData
  u642("baseNeedTakePnl"),
  u642("quoteNeedTakePnl"),
  u642("quoteTotalPnl"),
  u642("baseTotalPnl"),
  u642("poolOpenTime"),
  u642("punishPcAmount"),
  u642("punishCoinAmount"),
  u642("orderbookToInitTime"),
  u128("swapBaseInAmount"),
  u128("swapQuoteOutAmount"),
  u128("swapQuoteInAmount"),
  u128("swapBaseOutAmount"),
  u642("swapQuote2BaseFee"),
  u642("swapBase2QuoteFee"),
  publicKey2("baseVault"),
  publicKey2("quoteVault"),
  publicKey2("baseMint"),
  publicKey2("quoteMint"),
  publicKey2("lpMint"),
  publicKey2("modelDataAccount"),
  publicKey2("openOrders"),
  publicKey2("marketId"),
  publicKey2("marketProgramId"),
  publicKey2("targetOrders"),
  publicKey2("owner"),
  seq22(u642(), 64, "padding")
]);
var LIQUIDITY_VERSION_TO_STATE_LAYOUT = {
  4: LIQUIDITY_STATE_LAYOUT_V4,
  5: LIQUIDITY_STATE_LAYOUT_V5
};
var anchorDataBuf2 = {
  createPool: [233, 146, 209, 142, 207, 104, 64, 188],
  initReward: [95, 135, 192, 196, 242, 129, 230, 68],
  setRewardEmissions: [112, 52, 167, 75, 32, 201, 211, 137],
  openPosition: [77, 184, 74, 214, 112, 86, 241, 199],
  closePosition: [123, 134, 81, 0, 49, 68, 98, 98],
  increaseLiquidity: [133, 29, 89, 223, 69, 238, 176, 10],
  decreaseLiquidity: [58, 127, 188, 62, 79, 82, 196, 96],
  swap: [43, 4, 237, 11, 26, 201, 30, 98],
  // [248, 198, 158, 145, 225, 117, 135, 200],
  collectReward: [18, 237, 166, 197, 34, 16, 213, 144]
};
function createPoolInstruction(programId, poolId, poolCreator, ammConfigId, observationId, mintA, mintVaultA, mintProgramIdA, mintB, mintVaultB, mintProgramIdB, exTickArrayBitmap, sqrtPriceX64, startTime) {
  const dataLayout = struct50([u128("sqrtPriceX64"), u642("startTime")]);
  const keys = [
    { pubkey: poolCreator, isSigner: true, isWritable: true },
    { pubkey: ammConfigId, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: mintA, isSigner: false, isWritable: false },
    { pubkey: mintB, isSigner: false, isWritable: false },
    { pubkey: mintVaultA, isSigner: false, isWritable: true },
    { pubkey: mintVaultB, isSigner: false, isWritable: true },
    { pubkey: observationId, isSigner: false, isWritable: false },
    { pubkey: exTickArrayBitmap, isSigner: false, isWritable: true },
    { pubkey: mintProgramIdA, isSigner: false, isWritable: false },
    { pubkey: mintProgramIdB, isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      sqrtPriceX64,
      startTime
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.createPool, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function openPositionFromLiquidityInstruction(programId, payer, poolId, positionNftOwner, positionNftMint, positionNftAccount, metadataAccount, protocolPosition, tickArrayLower, tickArrayUpper, personalPosition, ownerTokenAccountA, ownerTokenAccountB, tokenVaultA, tokenVaultB, tokenMintA, tokenMintB, tickLowerIndex, tickUpperIndex, tickArrayLowerStartIndex, tickArrayUpperStartIndex, liquidity, amountMaxA, amountMaxB, withMetadata, exTickArrayBitmap) {
  const dataLayout = struct50([
    s32("tickLowerIndex"),
    s32("tickUpperIndex"),
    s32("tickArrayLowerStartIndex"),
    s32("tickArrayUpperStartIndex"),
    u128("liquidity"),
    u642("amountMaxA"),
    u642("amountMaxB"),
    bool22("withMetadata"),
    u8210("optionBaseFlag"),
    bool22("baseFlag")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
  ];
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: positionNftOwner, isSigner: false, isWritable: false },
    { pubkey: positionNftMint, isSigner: true, isWritable: true },
    { pubkey: positionNftAccount, isSigner: false, isWritable: true },
    { pubkey: metadataAccount, isSigner: false, isWritable: true },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: tokenVaultA, isSigner: false, isWritable: true },
    { pubkey: tokenVaultB, isSigner: false, isWritable: true },
    { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: METADATA_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: tokenMintA, isSigner: false, isWritable: false },
    { pubkey: tokenMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      tickLowerIndex,
      tickUpperIndex,
      tickArrayLowerStartIndex,
      tickArrayUpperStartIndex,
      liquidity,
      amountMaxA,
      amountMaxB,
      withMetadata: withMetadata === "create",
      baseFlag: false,
      optionBaseFlag: 0
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.openPosition, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function openPositionFromBaseInstruction(programId, payer, poolId, positionNftOwner, positionNftMint, positionNftAccount, metadataAccount, protocolPosition, tickArrayLower, tickArrayUpper, personalPosition, ownerTokenAccountA, ownerTokenAccountB, tokenVaultA, tokenVaultB, tokenMintA, tokenMintB, tickLowerIndex, tickUpperIndex, tickArrayLowerStartIndex, tickArrayUpperStartIndex, withMetadata, base, baseAmount, otherAmountMax, exTickArrayBitmap) {
  const dataLayout = struct50([
    s32("tickLowerIndex"),
    s32("tickUpperIndex"),
    s32("tickArrayLowerStartIndex"),
    s32("tickArrayUpperStartIndex"),
    u128("liquidity"),
    u642("amountMaxA"),
    u642("amountMaxB"),
    bool22("withMetadata"),
    u8210("optionBaseFlag"),
    bool22("baseFlag")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
  ];
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: positionNftOwner, isSigner: false, isWritable: false },
    { pubkey: positionNftMint, isSigner: true, isWritable: true },
    { pubkey: positionNftAccount, isSigner: false, isWritable: true },
    { pubkey: metadataAccount, isSigner: false, isWritable: true },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: tokenVaultA, isSigner: false, isWritable: true },
    { pubkey: tokenVaultB, isSigner: false, isWritable: true },
    { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: METADATA_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: tokenMintA, isSigner: false, isWritable: false },
    { pubkey: tokenMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      tickLowerIndex,
      tickUpperIndex,
      tickArrayLowerStartIndex,
      tickArrayUpperStartIndex,
      liquidity: ZERO,
      amountMaxA: base === "MintA" ? baseAmount : otherAmountMax,
      amountMaxB: base === "MintA" ? otherAmountMax : baseAmount,
      withMetadata: withMetadata === "create",
      baseFlag: base === "MintA",
      optionBaseFlag: 1
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.openPosition, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function closePositionInstruction(programId, positionNftOwner, positionNftMint, positionNftAccount, personalPosition) {
  const dataLayout = struct50([]);
  const keys = [
    { pubkey: positionNftOwner, isSigner: true, isWritable: true },
    { pubkey: positionNftMint, isSigner: false, isWritable: true },
    { pubkey: positionNftAccount, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode({}, data);
  const aData = Buffer.from([...anchorDataBuf2.closePosition, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function increasePositionFromLiquidityInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, liquidity, amountMaxA, amountMaxB, exTickArrayBitmap) {
  const dataLayout = struct50([
    u128("liquidity"),
    u642("amountMaxA"),
    u642("amountMaxB"),
    u8210("optionBaseFlag"),
    bool22("baseFlag")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
  ];
  const keys = [
    { pubkey: positionNftOwner, isSigner: true, isWritable: false },
    { pubkey: positionNftAccount, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: mintVaultA, isSigner: false, isWritable: true },
    { pubkey: mintVaultB, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: mintMintA, isSigner: false, isWritable: false },
    { pubkey: mintMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      liquidity,
      amountMaxA,
      amountMaxB,
      optionBaseFlag: 0,
      baseFlag: false
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.increaseLiquidity, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function increasePositionFromBaseInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, base, baseAmount, otherAmountMax, exTickArrayBitmap) {
  const dataLayout = struct50([
    u128("liquidity"),
    u642("amountMaxA"),
    u642("amountMaxB"),
    u8210("optionBaseFlag"),
    bool22("baseFlag")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : []
  ];
  const keys = [
    { pubkey: positionNftOwner, isSigner: true, isWritable: false },
    { pubkey: positionNftAccount, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: mintVaultA, isSigner: false, isWritable: true },
    { pubkey: mintVaultB, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: mintMintA, isSigner: false, isWritable: false },
    { pubkey: mintMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      liquidity: ZERO,
      amountMaxA: base === "MintA" ? baseAmount : otherAmountMax,
      amountMaxB: base === "MintA" ? otherAmountMax : baseAmount,
      baseFlag: base === "MintA",
      optionBaseFlag: 1
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.increaseLiquidity, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function decreaseLiquidityInstruction(programId, positionNftOwner, positionNftAccount, personalPosition, poolId, protocolPosition, tickArrayLower, tickArrayUpper, ownerTokenAccountA, ownerTokenAccountB, mintVaultA, mintVaultB, mintMintA, mintMintB, rewardAccounts, liquidity, amountMinA, amountMinB, exTickArrayBitmap) {
  const dataLayout = struct50([u128("liquidity"), u642("amountMinA"), u642("amountMinB")]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : [],
    ...rewardAccounts.map((i) => [
      { pubkey: i.poolRewardVault, isSigner: false, isWritable: true },
      { pubkey: i.ownerRewardVault, isSigner: false, isWritable: true },
      { pubkey: i.rewardMint, isSigner: false, isWritable: false }
    ]).flat()
  ];
  const keys = [
    { pubkey: positionNftOwner, isSigner: true, isWritable: false },
    { pubkey: positionNftAccount, isSigner: false, isWritable: false },
    { pubkey: personalPosition, isSigner: false, isWritable: true },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: protocolPosition, isSigner: false, isWritable: true },
    { pubkey: mintVaultA, isSigner: false, isWritable: true },
    { pubkey: mintVaultB, isSigner: false, isWritable: true },
    { pubkey: tickArrayLower, isSigner: false, isWritable: true },
    { pubkey: tickArrayUpper, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountA, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccountB, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: MEMO_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: mintMintA, isSigner: false, isWritable: false },
    { pubkey: mintMintB, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      liquidity,
      amountMinA,
      amountMinB
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.decreaseLiquidity, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function swapInstruction(programId, payer, poolId, ammConfigId, inputTokenAccount, outputTokenAccount, inputVault, outputVault, inputMint, outputMint, tickArray, observationId, amount, otherAmountThreshold, sqrtPriceLimitX64, isBaseInput, exTickArrayBitmap) {
  const dataLayout = struct50([
    u642("amount"),
    u642("otherAmountThreshold"),
    u128("sqrtPriceLimitX64"),
    bool22("isBaseInput")
  ]);
  const remainingAccounts = [
    ...exTickArrayBitmap ? [{ pubkey: exTickArrayBitmap, isSigner: false, isWritable: true }] : [],
    ...tickArray.map((i) => ({ pubkey: i, isSigner: false, isWritable: true }))
  ];
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: false },
    { pubkey: ammConfigId, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: inputTokenAccount, isSigner: false, isWritable: true },
    { pubkey: outputTokenAccount, isSigner: false, isWritable: true },
    { pubkey: inputVault, isSigner: false, isWritable: true },
    { pubkey: outputVault, isSigner: false, isWritable: true },
    { pubkey: observationId, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: MEMO_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: inputMint, isSigner: false, isWritable: false },
    { pubkey: outputMint, isSigner: false, isWritable: false },
    ...remainingAccounts
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      amount,
      otherAmountThreshold,
      sqrtPriceLimitX64,
      isBaseInput
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.swap, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function initRewardInstruction(programId, payer, poolId, operationId, ammConfigId, ownerTokenAccount, rewardProgramId, rewardMint, rewardVault, openTime, endTime, emissionsPerSecondX64) {
  const dataLayout = struct50([u642("openTime"), u642("endTime"), u128("emissionsPerSecondX64")]);
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
    { pubkey: ammConfigId, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: operationId, isSigner: false, isWritable: true },
    { pubkey: rewardMint, isSigner: false, isWritable: false },
    { pubkey: rewardVault, isSigner: false, isWritable: true },
    { pubkey: rewardProgramId, isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      openTime: parseBigNumberish(openTime),
      endTime: parseBigNumberish(endTime),
      emissionsPerSecondX64
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.initReward, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function setRewardInstruction(programId, payer, poolId, operationId, ammConfigId, ownerTokenAccount, rewardVault, rewardMint, rewardIndex, openTime, endTime, emissionsPerSecondX64) {
  const dataLayout = struct50([u8210("rewardIndex"), u128("emissionsPerSecondX64"), u642("openTime"), u642("endTime")]);
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: ammConfigId, isSigner: false, isWritable: false },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: operationId, isSigner: false, isWritable: true },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: rewardVault, isSigner: false, isWritable: true },
    { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
    { pubkey: rewardMint, isSigner: false, isWritable: true }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      rewardIndex,
      emissionsPerSecondX64,
      openTime: parseBigNumberish(openTime),
      endTime: parseBigNumberish(endTime)
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.setRewardEmissions, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
function collectRewardInstruction(programId, payer, poolId, ownerTokenAccount, rewardVault, rewardMint, rewardIndex) {
  const dataLayout = struct50([u8210("rewardIndex")]);
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: ownerTokenAccount, isSigner: false, isWritable: true },
    { pubkey: poolId, isSigner: false, isWritable: true },
    { pubkey: rewardVault, isSigner: false, isWritable: true },
    { pubkey: rewardMint, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: MEMO_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      rewardIndex
    },
    data
  );
  const aData = Buffer.from([...anchorDataBuf2.collectReward, ...data]);
  return new TransactionInstruction({
    keys,
    programId,
    data: aData
  });
}
var NEGATIVE_ONE = new import_bn13.default(-1);
var Q64 = new import_bn13.default(1).shln(64);
var Q128 = new import_bn13.default(1).shln(128);
var MaxU64 = Q64.sub(ONE);
var U64Resolution = 64;
var MaxUint128 = Q128.subn(1);
var MIN_TICK = -443636;
var MAX_TICK = -MIN_TICK;
var MIN_SQRT_PRICE_X64 = new import_bn13.default("4295048016");
var MAX_SQRT_PRICE_X64 = new import_bn13.default("79226673521066979257578248091");
var BIT_PRECISION = 16;
var LOG_B_2_X32 = "59543866431248";
var LOG_B_P_ERR_MARGIN_LOWER_X64 = "184467440737095516";
var LOG_B_P_ERR_MARGIN_UPPER_X64 = "15793534762490258745";
var FEE_RATE_DENOMINATOR = new import_bn13.default(10).pow(new import_bn13.default(6));
var Fee = ((Fee3) => {
  Fee3[Fee3["rate_500"] = 500] = "rate_500";
  Fee3[Fee3["rate_3000"] = 3e3] = "rate_3000";
  Fee3[Fee3["rate_10000"] = 1e4] = "rate_10000";
  return Fee3;
})(Fee || {});
var TICK_SPACINGS = {
  [
    500
    /* rate_500 */
  ]: 10,
  [
    3e3
    /* rate_3000 */
  ]: 60,
  [
    1e4
    /* rate_10000 */
  ]: 200
};
var U64_IGNORE_RANGE = new import_bn13.default("18446744073700000000");
function u16ToBytes(num) {
  const arr = new ArrayBuffer(2);
  const view = new DataView(arr);
  view.setUint16(0, num, false);
  return new Uint8Array(arr);
}
function i16ToBytes(num) {
  const arr = new ArrayBuffer(2);
  const view = new DataView(arr);
  view.setInt16(0, num, false);
  return new Uint8Array(arr);
}
function u32ToBytes(num) {
  const arr = new ArrayBuffer(4);
  const view = new DataView(arr);
  view.setUint32(0, num, false);
  return new Uint8Array(arr);
}
function i32ToBytes(num) {
  const arr = new ArrayBuffer(4);
  const view = new DataView(arr);
  view.setInt32(0, num, false);
  return new Uint8Array(arr);
}
function leadingZeros(bitNum, data) {
  let i = 0;
  for (let j = bitNum - 1; j >= 0; j--) {
    if (!data.testn(j)) {
      i++;
    } else {
      break;
    }
  }
  return i;
}
function trailingZeros(bitNum, data) {
  let i = 0;
  for (let j = 0; j < bitNum; j++) {
    if (!data.testn(j)) {
      i++;
    } else {
      break;
    }
  }
  return i;
}
function isZero(bitNum, data) {
  for (let i = 0; i < bitNum; i++) {
    if (data.testn(i)) return false;
  }
  return true;
}
function mostSignificantBit(bitNum, data) {
  if (isZero(bitNum, data)) return null;
  else return leadingZeros(bitNum, data);
}
function leastSignificantBit(bitNum, data) {
  if (isZero(bitNum, data)) return null;
  else return trailingZeros(bitNum, data);
}
var AMM_CONFIG_SEED = Buffer.from("amm_config", "utf8");
var POOL_SEED = Buffer.from("pool", "utf8");
var POOL_VAULT_SEED = Buffer.from("pool_vault", "utf8");
var POOL_REWARD_VAULT_SEED = Buffer.from("pool_reward_vault", "utf8");
var POSITION_SEED = Buffer.from("position", "utf8");
var TICK_ARRAY_SEED = Buffer.from("tick_array", "utf8");
var OPERATION_SEED = Buffer.from("operation", "utf8");
var POOL_TICK_ARRAY_BITMAP_SEED = Buffer.from("pool_tick_array_bitmap_extension", "utf8");
function getPdaAmmConfigId(programId, index) {
  return findProgramAddress([AMM_CONFIG_SEED, u16ToBytes(index)], programId);
}
function getPdaPoolId(programId, ammConfigId, mintA, mintB) {
  return findProgramAddress([POOL_SEED, ammConfigId.toBuffer(), mintA.toBuffer(), mintB.toBuffer()], programId);
}
function getPdaPoolVaultId(programId, poolId, vaultMint) {
  return findProgramAddress([POOL_VAULT_SEED, poolId.toBuffer(), vaultMint.toBuffer()], programId);
}
function getPdaPoolRewardVaulId(programId, poolId, rewardMint) {
  return findProgramAddress([POOL_REWARD_VAULT_SEED, poolId.toBuffer(), rewardMint.toBuffer()], programId);
}
function getPdaTickArrayAddress(programId, poolId, startIndex) {
  return findProgramAddress([TICK_ARRAY_SEED, poolId.toBuffer(), i32ToBytes(startIndex)], programId);
}
function getPdaProtocolPositionAddress(programId, poolId, tickLower, tickUpper) {
  return findProgramAddress([POSITION_SEED, poolId.toBuffer(), i32ToBytes(tickLower), i32ToBytes(tickUpper)], programId);
}
function getPdaPersonalPositionAddress(programId, nftMint) {
  return findProgramAddress([POSITION_SEED, nftMint.toBuffer()], programId);
}
function getPdaMetadataKey(mint) {
  return findProgramAddress(
    [Buffer.from("metadata", "utf8"), METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()],
    METADATA_PROGRAM_ID
  );
}
function getPdaOperationAccount(programId) {
  return findProgramAddress([OPERATION_SEED], programId);
}
function getPdaExBitmapAccount(programId, poolId) {
  return findProgramAddress([POOL_TICK_ARRAY_BITMAP_SEED, poolId.toBuffer()], programId);
}
var FETCH_TICKARRAY_COUNT = 15;
var TickQuery = class _TickQuery {
  static getTickArrays(connection, programId, poolId, tickCurrent, tickSpacing, tickArrayBitmapArray, exTickArrayBitmap) {
    return __async(this, null, function* () {
      const tickArraysToFetch = [];
      const currentTickArrayStartIndex = TickUtils.getTickArrayStartIndexByTick(tickCurrent, tickSpacing);
      const startIndexArray = TickUtils.getInitializedTickArrayInRange(
        tickArrayBitmapArray,
        exTickArrayBitmap,
        tickSpacing,
        currentTickArrayStartIndex,
        Math.floor(FETCH_TICKARRAY_COUNT / 2)
      );
      for (let i = 0; i < startIndexArray.length; i++) {
        const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, startIndexArray[i]);
        tickArraysToFetch.push(tickArrayAddress);
      }
      const fetchedTickArrays = (yield getMultipleAccountsInfo(connection, tickArraysToFetch)).map(
        (i) => i !== null ? TickArrayLayout.decode(i.data) : null
      );
      const tickArrayCache = {};
      for (let i = 0; i < tickArraysToFetch.length; i++) {
        const _info = fetchedTickArrays[i];
        if (_info === null) continue;
        tickArrayCache[_info.startTickIndex] = __spreadProps(__spreadValues({}, _info), {
          address: tickArraysToFetch[i]
        });
      }
      return tickArrayCache;
    });
  }
  static nextInitializedTick(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne) {
    let {
      initializedTick: nextTick,
      tickArrayAddress,
      tickArrayStartTickIndex
    } = this.nextInitializedTickInOneArray(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne);
    while (nextTick == void 0 || nextTick.liquidityGross.lten(0)) {
      tickArrayStartTickIndex = TickUtils.getNextTickArrayStartIndex(tickArrayStartTickIndex, tickSpacing, zeroForOne);
      if (this.checkIsValidStartIndex(tickArrayStartTickIndex, tickSpacing)) {
        throw new Error("No enough initialized tickArray");
      }
      const cachedTickArray = tickArrayCache[tickArrayStartTickIndex];
      if (cachedTickArray === void 0) continue;
      const {
        nextTick: _nextTick,
        tickArrayAddress: _tickArrayAddress,
        tickArrayStartTickIndex: _tickArrayStartTickIndex
      } = this.firstInitializedTickInOneArray(programId, poolId, cachedTickArray, zeroForOne);
      [nextTick, tickArrayAddress, tickArrayStartTickIndex] = [_nextTick, _tickArrayAddress, _tickArrayStartTickIndex];
    }
    if (nextTick == void 0) {
      throw new Error("No invaild tickArray cache");
    }
    return { nextTick, tickArrayAddress, tickArrayStartTickIndex };
  }
  static nextInitializedTickArray(tickIndex, tickSpacing, zeroForOne, tickArrayBitmap, exBitmapInfo) {
    const currentOffset = Math.floor(tickIndex / _TickQuery.tickCount(tickSpacing));
    const result = zeroForOne ? TickUtils.searchLowBitFromStart(tickArrayBitmap, exBitmapInfo, currentOffset - 1, 1, tickSpacing) : TickUtils.searchHightBitFromStart(tickArrayBitmap, exBitmapInfo, currentOffset + 1, 1, tickSpacing);
    return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
  }
  static firstInitializedTickInOneArray(programId, poolId, tickArray, zeroForOne) {
    let nextInitializedTick = void 0;
    if (zeroForOne) {
      let i = TICK_ARRAY_SIZE - 1;
      while (i >= 0) {
        const tickInArray = tickArray.ticks[i];
        if (tickInArray.liquidityGross.gtn(0)) {
          nextInitializedTick = tickInArray;
          break;
        }
        i = i - 1;
      }
    } else {
      let i = 0;
      while (i < TICK_ARRAY_SIZE) {
        const tickInArray = tickArray.ticks[i];
        if (tickInArray.liquidityGross.gtn(0)) {
          nextInitializedTick = tickInArray;
          break;
        }
        i = i + 1;
      }
    }
    const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, tickArray.startTickIndex);
    return { nextTick: nextInitializedTick, tickArrayAddress, tickArrayStartTickIndex: tickArray.startTickIndex };
  }
  static nextInitializedTickInOneArray(programId, poolId, tickArrayCache, tickIndex, tickSpacing, zeroForOne) {
    const startIndex = TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
    let tickPositionInArray = Math.floor((tickIndex - startIndex) / tickSpacing);
    const cachedTickArray = tickArrayCache[startIndex];
    if (cachedTickArray == void 0) {
      return {
        initializedTick: void 0,
        tickArrayAddress: void 0,
        tickArrayStartTickIndex: startIndex
      };
    }
    let nextInitializedTick = void 0;
    if (zeroForOne) {
      while (tickPositionInArray >= 0) {
        const tickInArray = cachedTickArray.ticks[tickPositionInArray];
        if (tickInArray.liquidityGross.gtn(0)) {
          nextInitializedTick = tickInArray;
          break;
        }
        tickPositionInArray = tickPositionInArray - 1;
      }
    } else {
      tickPositionInArray = tickPositionInArray + 1;
      while (tickPositionInArray < TICK_ARRAY_SIZE) {
        const tickInArray = cachedTickArray.ticks[tickPositionInArray];
        if (tickInArray.liquidityGross.gtn(0)) {
          nextInitializedTick = tickInArray;
          break;
        }
        tickPositionInArray = tickPositionInArray + 1;
      }
    }
    const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, startIndex);
    return {
      initializedTick: nextInitializedTick,
      tickArrayAddress,
      tickArrayStartTickIndex: cachedTickArray.startTickIndex
    };
  }
  static getArrayStartIndex(tickIndex, tickSpacing) {
    const ticksInArray = this.tickCount(tickSpacing);
    const start = Math.floor(tickIndex / ticksInArray);
    return start * ticksInArray;
  }
  static checkIsValidStartIndex(tickIndex, tickSpacing) {
    if (TickUtils.checkIsOutOfBoundary(tickIndex)) {
      if (tickIndex > MAX_TICK) {
        return false;
      }
      const minStartIndex = TickUtils.getTickArrayStartIndexByTick(MIN_TICK, tickSpacing);
      return tickIndex == minStartIndex;
    }
    return tickIndex % this.tickCount(tickSpacing) == 0;
  }
  static tickCount(tickSpacing) {
    return TICK_ARRAY_SIZE * tickSpacing;
  }
};
var TICK_ARRAY_SIZE = 60;
var TICK_ARRAY_BITMAP_SIZE = 512;
var TickUtils = class _TickUtils {
  static getTickArrayAddressByTick(programId, poolId, tickIndex, tickSpacing) {
    const startIndex = _TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
    const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(programId, poolId, startIndex);
    return tickArrayAddress;
  }
  static getTickOffsetInArray(tickIndex, tickSpacing) {
    if (tickIndex % tickSpacing != 0) {
      throw new Error("tickIndex % tickSpacing not equal 0");
    }
    const startTickIndex = _TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
    const offsetInArray = Math.floor((tickIndex - startTickIndex) / tickSpacing);
    if (offsetInArray < 0 || offsetInArray >= TICK_ARRAY_SIZE) {
      throw new Error("tick offset in array overflow");
    }
    return offsetInArray;
  }
  static getTickArrayBitIndex(tickIndex, tickSpacing) {
    const ticksInArray = TickQuery.tickCount(tickSpacing);
    let startIndex = tickIndex / ticksInArray;
    if (tickIndex < 0 && tickIndex % ticksInArray != 0) {
      startIndex = Math.ceil(startIndex) - 1;
    } else {
      startIndex = Math.floor(startIndex);
    }
    return startIndex;
  }
  static getTickArrayStartIndexByTick(tickIndex, tickSpacing) {
    return this.getTickArrayBitIndex(tickIndex, tickSpacing) * TickQuery.tickCount(tickSpacing);
  }
  static getTickArrayOffsetInBitmapByTick(tick, tickSpacing) {
    const multiplier = tickSpacing * TICK_ARRAY_SIZE;
    const compressed = Math.floor(tick / multiplier) + 512;
    return Math.abs(compressed);
  }
  static checkTickArrayIsInitialized(bitmap, tick, tickSpacing) {
    const multiplier = tickSpacing * TICK_ARRAY_SIZE;
    const compressed = Math.floor(tick / multiplier) + 512;
    const bitPos = Math.abs(compressed);
    return {
      isInitialized: bitmap.testn(bitPos),
      startIndex: (bitPos - 512) * multiplier
    };
  }
  static getNextTickArrayStartIndex(lastTickArrayStartIndex, tickSpacing, zeroForOne) {
    return zeroForOne ? lastTickArrayStartIndex - tickSpacing * TICK_ARRAY_SIZE : lastTickArrayStartIndex + tickSpacing * TICK_ARRAY_SIZE;
  }
  static mergeTickArrayBitmap(bns) {
    let b = new import_bn12.default(0);
    for (let i = 0; i < bns.length; i++) {
      b = b.add(bns[i].shln(64 * i));
    }
    return b;
  }
  static getInitializedTickArrayInRange(tickArrayBitmap, exTickArrayBitmap, tickSpacing, tickArrayStartIndex, expectedCount) {
    const tickArrayOffset = Math.floor(tickArrayStartIndex / (tickSpacing * TICK_ARRAY_SIZE));
    return [
      // find right of currenct offset
      ..._TickUtils.searchLowBitFromStart(
        tickArrayBitmap,
        exTickArrayBitmap,
        tickArrayOffset - 1,
        expectedCount,
        tickSpacing
      ),
      // find left of current offset
      ..._TickUtils.searchHightBitFromStart(
        tickArrayBitmap,
        exTickArrayBitmap,
        tickArrayOffset,
        expectedCount,
        tickSpacing
      )
    ];
  }
  static getAllInitializedTickArrayStartIndex(tickArrayBitmap, exTickArrayBitmap, tickSpacing) {
    return _TickUtils.searchHightBitFromStart(tickArrayBitmap, exTickArrayBitmap, 0, TICK_ARRAY_BITMAP_SIZE, tickSpacing);
  }
  static getAllInitializedTickArrayInfo(programId, poolId, tickArrayBitmap, exTickArrayBitmap, tickSpacing) {
    const result = [];
    const allInitializedTickArrayIndex = _TickUtils.getAllInitializedTickArrayStartIndex(
      tickArrayBitmap,
      exTickArrayBitmap,
      tickSpacing
    );
    for (const startIndex of allInitializedTickArrayIndex) {
      const { publicKey: address } = getPdaTickArrayAddress(programId, poolId, startIndex);
      result.push({
        tickArrayStartIndex: startIndex,
        tickArrayAddress: address
      });
    }
    return result;
  }
  static getAllInitializedTickInTickArray(tickArray) {
    return tickArray.ticks.filter((i) => i.liquidityGross.gtn(0));
  }
  static searchLowBitFromStart(tickArrayBitmap, exTickArrayBitmap, currentTickArrayBitStartIndex, expectedCount, tickSpacing) {
    const tickArrayBitmaps = [
      ...[...exTickArrayBitmap.negativeTickArrayBitmap].reverse(),
      tickArrayBitmap.slice(0, 8),
      tickArrayBitmap.slice(8, 16),
      ...exTickArrayBitmap.positiveTickArrayBitmap
    ].map((i) => _TickUtils.mergeTickArrayBitmap(i));
    const result = [];
    while (currentTickArrayBitStartIndex >= -7680) {
      const arrayIndex = Math.floor((currentTickArrayBitStartIndex + 7680) / 512);
      const searchIndex = (currentTickArrayBitStartIndex + 7680) % 512;
      if (tickArrayBitmaps[arrayIndex].testn(searchIndex)) result.push(currentTickArrayBitStartIndex);
      currentTickArrayBitStartIndex--;
      if (result.length === expectedCount) break;
    }
    const tickCount = TickQuery.tickCount(tickSpacing);
    return result.map((i) => i * tickCount);
  }
  static searchHightBitFromStart(tickArrayBitmap, exTickArrayBitmap, currentTickArrayBitStartIndex, expectedCount, tickSpacing) {
    const tickArrayBitmaps = [
      ...[...exTickArrayBitmap.negativeTickArrayBitmap].reverse(),
      tickArrayBitmap.slice(0, 8),
      tickArrayBitmap.slice(8, 16),
      ...exTickArrayBitmap.positiveTickArrayBitmap
    ].map((i) => _TickUtils.mergeTickArrayBitmap(i));
    const result = [];
    while (currentTickArrayBitStartIndex < 7680) {
      const arrayIndex = Math.floor((currentTickArrayBitStartIndex + 7680) / 512);
      const searchIndex = (currentTickArrayBitStartIndex + 7680) % 512;
      if (tickArrayBitmaps[arrayIndex].testn(searchIndex)) result.push(currentTickArrayBitStartIndex);
      currentTickArrayBitStartIndex++;
      if (result.length === expectedCount) break;
    }
    const tickCount = TickQuery.tickCount(tickSpacing);
    return result.map((i) => i * tickCount);
  }
  static checkIsOutOfBoundary(tick) {
    return tick < MIN_TICK || tick > MAX_TICK;
  }
  static nextInitTick(tickArrayCurrent, currentTickIndex, tickSpacing, zeroForOne, t) {
    const currentTickArrayStartIndex = TickQuery.getArrayStartIndex(currentTickIndex, tickSpacing);
    if (currentTickArrayStartIndex != tickArrayCurrent.startTickIndex) {
      return null;
    }
    let offsetInArray = Math.floor((currentTickIndex - tickArrayCurrent.startTickIndex) / tickSpacing);
    if (zeroForOne) {
      while (offsetInArray >= 0) {
        if (tickArrayCurrent.ticks[offsetInArray].liquidityGross.gtn(0)) {
          return tickArrayCurrent.ticks[offsetInArray];
        }
        offsetInArray = offsetInArray - 1;
      }
    } else {
      if (!t) offsetInArray = offsetInArray + 1;
      while (offsetInArray < TICK_ARRAY_SIZE) {
        if (tickArrayCurrent.ticks[offsetInArray].liquidityGross.gtn(0)) {
          return tickArrayCurrent.ticks[offsetInArray];
        }
        offsetInArray = offsetInArray + 1;
      }
    }
    return null;
  }
  static firstInitializedTick(tickArrayCurrent, zeroForOne) {
    if (zeroForOne) {
      let i = TICK_ARRAY_SIZE - 1;
      while (i >= 0) {
        if (tickArrayCurrent.ticks[i].liquidityGross.gtn(0)) {
          return tickArrayCurrent.ticks[i];
        }
        i = i - 1;
      }
    } else {
      let i = 0;
      while (i < TICK_ARRAY_SIZE) {
        if (tickArrayCurrent.ticks[i].liquidityGross.gtn(0)) {
          return tickArrayCurrent.ticks[i];
        }
        i = i + 1;
      }
    }
    throw Error(`firstInitializedTick check error: ${tickArrayCurrent} - ${zeroForOne}`);
  }
};
var EXTENSION_TICKARRAY_BITMAP_SIZE = 14;
var TickArrayBitmap = class {
  static maxTickInTickarrayBitmap(tickSpacing) {
    return tickSpacing * TICK_ARRAY_SIZE * TICK_ARRAY_BITMAP_SIZE;
  }
  static getBitmapTickBoundary(tickarrayStartIndex, tickSpacing) {
    const ticksInOneBitmap = this.maxTickInTickarrayBitmap(tickSpacing);
    let m = Math.floor(Math.abs(tickarrayStartIndex) / ticksInOneBitmap);
    if (tickarrayStartIndex < 0 && Math.abs(tickarrayStartIndex) % ticksInOneBitmap != 0) m += 1;
    const minValue = ticksInOneBitmap * m;
    return tickarrayStartIndex < 0 ? { minValue: -minValue, maxValue: -minValue + ticksInOneBitmap } : { minValue, maxValue: minValue + ticksInOneBitmap };
  }
  static nextInitializedTickArrayStartIndex(bitMap, lastTickArrayStartIndex, tickSpacing, zeroForOne) {
    if (!TickQuery.checkIsValidStartIndex(lastTickArrayStartIndex, tickSpacing))
      throw Error("nextInitializedTickArrayStartIndex check error");
    const tickBoundary = this.maxTickInTickarrayBitmap(tickSpacing);
    const nextTickArrayStartIndex = zeroForOne ? lastTickArrayStartIndex - TickQuery.tickCount(tickSpacing) : lastTickArrayStartIndex + TickQuery.tickCount(tickSpacing);
    if (nextTickArrayStartIndex < -tickBoundary || nextTickArrayStartIndex >= tickBoundary) {
      return { isInit: false, tickIndex: lastTickArrayStartIndex };
    }
    const multiplier = tickSpacing * TICK_ARRAY_SIZE;
    let compressed = nextTickArrayStartIndex / multiplier + 512;
    if (nextTickArrayStartIndex < 0 && nextTickArrayStartIndex % multiplier != 0) {
      compressed--;
    }
    const bitPos = Math.abs(compressed);
    if (zeroForOne) {
      const offsetBitMap = bitMap.shln(1024 - bitPos - 1);
      const nextBit = mostSignificantBit(1024, offsetBitMap);
      if (nextBit !== null) {
        const nextArrayStartIndex = (bitPos - nextBit - 512) * multiplier;
        return { isInit: true, tickIndex: nextArrayStartIndex };
      } else {
        return { isInit: false, tickIndex: -tickBoundary };
      }
    } else {
      const offsetBitMap = bitMap.shrn(bitPos);
      const nextBit = leastSignificantBit(1024, offsetBitMap);
      if (nextBit !== null) {
        const nextArrayStartIndex = (bitPos + nextBit - 512) * multiplier;
        return { isInit: true, tickIndex: nextArrayStartIndex };
      } else {
        return { isInit: false, tickIndex: tickBoundary - TickQuery.tickCount(tickSpacing) };
      }
    }
  }
};
var TickArrayBitmapExtension = class {
  static getBitmapOffset(tickIndex, tickSpacing) {
    if (!TickQuery.checkIsValidStartIndex(tickIndex, tickSpacing)) {
      throw new Error("No enough initialized tickArray");
    }
    this.checkExtensionBoundary(tickIndex, tickSpacing);
    const ticksInOneBitmap = TickArrayBitmap.maxTickInTickarrayBitmap(tickSpacing);
    let offset2 = Math.floor(Math.abs(tickIndex) / ticksInOneBitmap) - 1;
    if (tickIndex < 0 && Math.abs(tickIndex) % ticksInOneBitmap === 0) offset2--;
    return offset2;
  }
  static getBitmap(tickIndex, tickSpacing, tickArrayBitmapExtension) {
    const offset2 = this.getBitmapOffset(tickIndex, tickSpacing);
    if (tickIndex < 0) {
      return { offset: offset2, tickarrayBitmap: tickArrayBitmapExtension.negativeTickArrayBitmap[offset2] };
    } else {
      return { offset: offset2, tickarrayBitmap: tickArrayBitmapExtension.positiveTickArrayBitmap[offset2] };
    }
  }
  static checkExtensionBoundary(tickIndex, tickSpacing) {
    const { positiveTickBoundary, negativeTickBoundary } = this.extensionTickBoundary(tickSpacing);
    if (tickIndex >= negativeTickBoundary && tickIndex < positiveTickBoundary) {
      throw Error("checkExtensionBoundary -> InvalidTickArrayBoundary");
    }
  }
  static extensionTickBoundary(tickSpacing) {
    const positiveTickBoundary = TickArrayBitmap.maxTickInTickarrayBitmap(tickSpacing);
    const negativeTickBoundary = -positiveTickBoundary;
    if (MAX_TICK <= positiveTickBoundary)
      throw Error(`extensionTickBoundary check error: ${MAX_TICK}, ${positiveTickBoundary}`);
    if (negativeTickBoundary <= MIN_TICK)
      throw Error(`extensionTickBoundary check error: ${negativeTickBoundary}, ${MIN_TICK}`);
    return { positiveTickBoundary, negativeTickBoundary };
  }
  static checkTickArrayIsInit(tickArrayStartIndex, tickSpacing, tickArrayBitmapExtension) {
    const { tickarrayBitmap } = this.getBitmap(tickArrayStartIndex, tickSpacing, tickArrayBitmapExtension);
    const tickArrayOffsetInBitmap = this.tickArrayOffsetInBitmap(tickArrayStartIndex, tickSpacing);
    return {
      isInitialized: TickUtils.mergeTickArrayBitmap(tickarrayBitmap).testn(tickArrayOffsetInBitmap),
      startIndex: tickArrayStartIndex
    };
  }
  static nextInitializedTickArrayFromOneBitmap(lastTickArrayStartIndex, tickSpacing, zeroForOne, tickArrayBitmapExtension) {
    const multiplier = TickQuery.tickCount(tickSpacing);
    const nextTickArrayStartIndex = zeroForOne ? lastTickArrayStartIndex - multiplier : lastTickArrayStartIndex + multiplier;
    const minTickArrayStartIndex = TickQuery.getArrayStartIndex(MIN_TICK, tickSpacing);
    const maxTickArrayStartIndex = TickQuery.getArrayStartIndex(MAX_TICK, tickSpacing);
    if (nextTickArrayStartIndex < minTickArrayStartIndex || nextTickArrayStartIndex > maxTickArrayStartIndex) {
      return {
        isInit: false,
        tickIndex: nextTickArrayStartIndex
      };
    }
    const { tickarrayBitmap } = this.getBitmap(nextTickArrayStartIndex, tickSpacing, tickArrayBitmapExtension);
    return this.nextInitializedTickArrayInBitmap(tickarrayBitmap, nextTickArrayStartIndex, tickSpacing, zeroForOne);
  }
  static nextInitializedTickArrayInBitmap(tickarrayBitmap, nextTickArrayStartIndex, tickSpacing, zeroForOne) {
    const { minValue: bitmapMinTickBoundary, maxValue: bitmapMaxTickBoundary } = TickArrayBitmap.getBitmapTickBoundary(
      nextTickArrayStartIndex,
      tickSpacing
    );
    const tickArrayOffsetInBitmap = this.tickArrayOffsetInBitmap(nextTickArrayStartIndex, tickSpacing);
    if (zeroForOne) {
      const offsetBitMap = TickUtils.mergeTickArrayBitmap(tickarrayBitmap).shln(
        TICK_ARRAY_BITMAP_SIZE - 1 - tickArrayOffsetInBitmap
      );
      const nextBit = isZero(512, offsetBitMap) ? null : leadingZeros(512, offsetBitMap);
      if (nextBit !== null) {
        const nextArrayStartIndex = nextTickArrayStartIndex - nextBit * TickQuery.tickCount(tickSpacing);
        return { isInit: true, tickIndex: nextArrayStartIndex };
      } else {
        return { isInit: false, tickIndex: bitmapMinTickBoundary };
      }
    } else {
      const offsetBitMap = TickUtils.mergeTickArrayBitmap(tickarrayBitmap).shrn(tickArrayOffsetInBitmap);
      const nextBit = isZero(512, offsetBitMap) ? null : trailingZeros(512, offsetBitMap);
      if (nextBit !== null) {
        const nextArrayStartIndex = nextTickArrayStartIndex + nextBit * TickQuery.tickCount(tickSpacing);
        return { isInit: true, tickIndex: nextArrayStartIndex };
      } else {
        return { isInit: false, tickIndex: bitmapMaxTickBoundary - TickQuery.tickCount(tickSpacing) };
      }
    }
  }
  static tickArrayOffsetInBitmap(tickArrayStartIndex, tickSpacing) {
    const m = Math.abs(tickArrayStartIndex) % TickArrayBitmap.maxTickInTickarrayBitmap(tickSpacing);
    let tickArrayOffsetInBitmap = Math.floor(m / TickQuery.tickCount(tickSpacing));
    if (tickArrayStartIndex < 0 && m != 0) {
      tickArrayOffsetInBitmap = TICK_ARRAY_BITMAP_SIZE - tickArrayOffsetInBitmap;
    }
    return tickArrayOffsetInBitmap;
  }
};
var AmmConfigLayout = struct50([
  blob3(8),
  u8210("bump"),
  u164("index"),
  publicKey2(""),
  u3222("protocolFeeRate"),
  u3222("tradeFeeRate"),
  u164("tickSpacing"),
  u3222("fundFeeRate"),
  seq22(u3222(), 1, "padding"),
  publicKey2("fundOwner"),
  seq22(u642(), 3, "padding")
]);
var ObservationLayout = struct50([
  u3222("blockTimestamp"),
  u128("sqrtPriceX64"),
  u128("cumulativeTimePriceX64"),
  seq22(u128(), 1, "")
]);
var ObservationInfoLayout = struct50([
  blob3(8),
  bool22("initialized"),
  publicKey2("poolId"),
  seq22(ObservationLayout, 1e3, "observations"),
  seq22(u128(), 5, "")
]);
var RewardInfo = struct50([
  u8210("rewardState"),
  u642("openTime"),
  u642("endTime"),
  u642("lastUpdateTime"),
  u128("emissionsPerSecondX64"),
  u642("rewardTotalEmissioned"),
  u642("rewardClaimed"),
  publicKey2("tokenMint"),
  publicKey2("tokenVault"),
  publicKey2("creator"),
  u128("rewardGrowthGlobalX64")
]);
var PoolInfoLayout = struct50([
  blob3(8),
  u8210("bump"),
  publicKey2("ammConfig"),
  publicKey2("creator"),
  publicKey2("mintA"),
  publicKey2("mintB"),
  publicKey2("vaultA"),
  publicKey2("vaultB"),
  publicKey2("observationId"),
  u8210("mintDecimalsA"),
  u8210("mintDecimalsB"),
  u164("tickSpacing"),
  u128("liquidity"),
  u128("sqrtPriceX64"),
  s32("tickCurrent"),
  u164("observationIndex"),
  u164("observationUpdateDuration"),
  u128("feeGrowthGlobalX64A"),
  u128("feeGrowthGlobalX64B"),
  u642("protocolFeesTokenA"),
  u642("protocolFeesTokenB"),
  u128("swapInAmountTokenA"),
  u128("swapOutAmountTokenB"),
  u128("swapInAmountTokenB"),
  u128("swapOutAmountTokenA"),
  u8210("status"),
  seq22(u8210(), 7, ""),
  seq22(RewardInfo, 3, "rewardInfos"),
  seq22(u642(), 16, "tickArrayBitmap"),
  u642("totalFeesTokenA"),
  u642("totalFeesClaimedTokenA"),
  u642("totalFeesTokenB"),
  u642("totalFeesClaimedTokenB"),
  u642("fundFeesTokenA"),
  u642("fundFeesTokenB"),
  u642("startTime"),
  seq22(u642(), 15 * 4 - 3, "padding")
]);
var PositionRewardInfoLayout = struct50([u128("growthInsideLastX64"), u642("rewardAmountOwed")]);
var PositionInfoLayout = struct50([
  blob3(8),
  u8210("bump"),
  publicKey2("nftMint"),
  publicKey2("poolId"),
  s32("tickLower"),
  s32("tickUpper"),
  u128("liquidity"),
  u128("feeGrowthInsideLastX64A"),
  u128("feeGrowthInsideLastX64B"),
  u642("tokenFeesOwedA"),
  u642("tokenFeesOwedB"),
  seq22(PositionRewardInfoLayout, 3, "rewardInfos"),
  seq22(u642(), 8, "")
]);
var ProtocolPositionLayout = struct50([
  blob3(8),
  u8210("bump"),
  publicKey2("poolId"),
  s32("tickLowerIndex"),
  s32("tickUpperIndex"),
  u128("liquidity"),
  u128("feeGrowthInsideLastX64A"),
  u128("feeGrowthInsideLastX64B"),
  u642("tokenFeesOwedA"),
  u642("tokenFeesOwedB"),
  seq22(u128(), 3, "rewardGrowthInside"),
  seq22(u642(), 8, "")
]);
var TickLayout = struct50([
  s32("tick"),
  i128("liquidityNet"),
  u128("liquidityGross"),
  u128("feeGrowthOutsideX64A"),
  u128("feeGrowthOutsideX64B"),
  seq22(u128(), 3, "rewardGrowthsOutsideX64"),
  seq22(u3222(), 13, "")
]);
var TickArrayLayout = struct50([
  blob3(8),
  publicKey2("poolId"),
  s32("startTickIndex"),
  seq22(TickLayout, TICK_ARRAY_SIZE, "ticks"),
  u8210("initializedTickCount"),
  seq22(u8210(), 115, "")
]);
var OperationLayout = struct50([blob3(329), seq22(publicKey2(), 100, "whitelistMints")]);
var TickArrayBitmapExtensionLayout = struct50([
  blob3(8),
  publicKey2("poolId"),
  seq22(seq22(u642(), 8), EXTENSION_TICKARRAY_BITMAP_SIZE, "positiveTickArrayBitmap"),
  seq22(seq22(u642(), 8), EXTENSION_TICKARRAY_BITMAP_SIZE, "negativeTickArrayBitmap")
]);
var PoolUtils = class _PoolUtils {
  static getOutputAmountAndRemainAccounts(poolInfo, tickArrayCache, inputTokenMint, inputAmount, sqrtPriceLimitX64, catchLiquidityInsufficient = false) {
    const zeroForOne = inputTokenMint.equals(poolInfo.mintA.mint);
    const allNeededAccounts = [];
    const {
      isExist,
      startIndex: firstTickArrayStartIndex,
      nextAccountMeta
    } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
    if (!isExist || firstTickArrayStartIndex === void 0 || !nextAccountMeta) throw new Error("Invalid tick array");
    try {
      const preTick = this.preInitializedTickArrayStartIndex(poolInfo, zeroForOne);
      if (preTick.isExist) {
        const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
        allNeededAccounts.push(address);
      }
    } catch (e) {
    }
    allNeededAccounts.push(nextAccountMeta);
    const {
      allTrade,
      amountSpecifiedRemaining,
      amountCalculated: outputAmount,
      accounts: reaminAccounts,
      sqrtPriceX64: executionPrice,
      feeAmount
    } = SwapMath.swapCompute(
      poolInfo.programId,
      poolInfo.id,
      tickArrayCache,
      poolInfo.tickArrayBitmap,
      poolInfo.exBitmapInfo,
      zeroForOne,
      poolInfo.ammConfig.tradeFeeRate,
      poolInfo.liquidity,
      poolInfo.tickCurrent,
      poolInfo.tickSpacing,
      poolInfo.sqrtPriceX64,
      inputAmount,
      firstTickArrayStartIndex,
      sqrtPriceLimitX64,
      catchLiquidityInsufficient
    );
    allNeededAccounts.push(...reaminAccounts);
    return {
      allTrade,
      realTradeAmountIn: inputAmount.sub(amountSpecifiedRemaining),
      expectedAmountOut: outputAmount.mul(NEGATIVE_ONE),
      remainingAccounts: allNeededAccounts,
      executionPrice,
      feeAmount
    };
  }
  static getInputAmountAndRemainAccounts(poolInfo, tickArrayCache, outputTokenMint, outputAmount, sqrtPriceLimitX64) {
    const zeroForOne = outputTokenMint.equals(poolInfo.mintB.mint);
    const allNeededAccounts = [];
    const {
      isExist,
      startIndex: firstTickArrayStartIndex,
      nextAccountMeta
    } = this.getFirstInitializedTickArray(poolInfo, zeroForOne);
    if (!isExist || firstTickArrayStartIndex === void 0 || !nextAccountMeta) throw new Error("Invalid tick array");
    try {
      const preTick = this.preInitializedTickArrayStartIndex(poolInfo, zeroForOne);
      if (preTick.isExist) {
        const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, preTick.nextStartIndex);
        allNeededAccounts.push(address);
      }
    } catch (e) {
    }
    allNeededAccounts.push(nextAccountMeta);
    const {
      amountCalculated: inputAmount,
      accounts: reaminAccounts,
      sqrtPriceX64: executionPrice,
      feeAmount
    } = SwapMath.swapCompute(
      poolInfo.programId,
      poolInfo.id,
      tickArrayCache,
      poolInfo.tickArrayBitmap,
      poolInfo.exBitmapInfo,
      zeroForOne,
      poolInfo.ammConfig.tradeFeeRate,
      poolInfo.liquidity,
      poolInfo.tickCurrent,
      poolInfo.tickSpacing,
      poolInfo.sqrtPriceX64,
      outputAmount.mul(NEGATIVE_ONE),
      firstTickArrayStartIndex,
      sqrtPriceLimitX64
    );
    allNeededAccounts.push(...reaminAccounts);
    return { expectedAmountIn: inputAmount, remainingAccounts: allNeededAccounts, executionPrice, feeAmount };
  }
  static getFirstInitializedTickArray(poolInfo, zeroForOne) {
    const { isInitialized, startIndex } = _PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
      poolInfo.tickCurrent
    ]) ? TickArrayBitmapExtension.checkTickArrayIsInit(
      TickQuery.getArrayStartIndex(poolInfo.tickCurrent, poolInfo.tickSpacing),
      poolInfo.tickSpacing,
      poolInfo.exBitmapInfo
    ) : TickUtils.checkTickArrayIsInitialized(
      TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap),
      poolInfo.tickCurrent,
      poolInfo.tickSpacing
    );
    if (isInitialized) {
      const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, startIndex);
      return {
        isExist: true,
        startIndex,
        nextAccountMeta: address
      };
    }
    const { isExist, nextStartIndex } = this.nextInitializedTickArrayStartIndex(
      poolInfo,
      TickQuery.getArrayStartIndex(poolInfo.tickCurrent, poolInfo.tickSpacing),
      zeroForOne
    );
    if (isExist) {
      const { publicKey: address } = getPdaTickArrayAddress(poolInfo.programId, poolInfo.id, nextStartIndex);
      return {
        isExist: true,
        startIndex: nextStartIndex,
        nextAccountMeta: address
      };
    }
    return { isExist: false, nextAccountMeta: void 0, startIndex: void 0 };
  }
  static preInitializedTickArrayStartIndex(poolInfo, zeroForOne) {
    const currentOffset = Math.floor(poolInfo.tickCurrent / TickQuery.tickCount(poolInfo.tickSpacing));
    const result = !zeroForOne ? TickUtils.searchLowBitFromStart(
      poolInfo.tickArrayBitmap,
      poolInfo.exBitmapInfo,
      currentOffset - 1,
      1,
      poolInfo.tickSpacing
    ) : TickUtils.searchHightBitFromStart(
      poolInfo.tickArrayBitmap,
      poolInfo.exBitmapInfo,
      currentOffset + 1,
      1,
      poolInfo.tickSpacing
    );
    return result.length > 0 ? { isExist: true, nextStartIndex: result[0] } : { isExist: false, nextStartIndex: 0 };
  }
  static nextInitializedTickArrayStartIndex(poolInfo, lastTickArrayStartIndex, zeroForOne) {
    lastTickArrayStartIndex = TickQuery.getArrayStartIndex(lastTickArrayStartIndex, poolInfo.tickSpacing);
    while (true) {
      const { isInit: startIsInit, tickIndex: startIndex } = TickArrayBitmap.nextInitializedTickArrayStartIndex(
        TickUtils.mergeTickArrayBitmap(poolInfo.tickArrayBitmap),
        lastTickArrayStartIndex,
        poolInfo.tickSpacing,
        zeroForOne
      );
      if (startIsInit) {
        return { isExist: true, nextStartIndex: startIndex };
      }
      lastTickArrayStartIndex = startIndex;
      const { isInit, tickIndex } = TickArrayBitmapExtension.nextInitializedTickArrayFromOneBitmap(
        lastTickArrayStartIndex,
        poolInfo.tickSpacing,
        zeroForOne,
        poolInfo.exBitmapInfo
      );
      if (isInit) return { isExist: true, nextStartIndex: tickIndex };
      lastTickArrayStartIndex = tickIndex;
      if (lastTickArrayStartIndex < MIN_TICK || lastTickArrayStartIndex > MAX_TICK)
        return { isExist: false, nextStartIndex: 0 };
    }
  }
  static updatePoolRewardInfos(_0) {
    return __async(this, arguments, function* ({
      connection,
      apiPoolInfo,
      chainTime,
      poolLiquidity,
      rewardInfos
    }) {
      var _a, _b, _c;
      const nRewardInfo = [];
      for (let i = 0; i < rewardInfos.length; i++) {
        const _itemReward = rewardInfos[i];
        const apiRewardProgram = (_c = (_a = apiPoolInfo.rewardInfos[i]) == null ? void 0 : _a.programId) != null ? _c : (_b = yield connection.getAccountInfo(_itemReward.tokenMint)) == null ? void 0 : _b.owner;
        if (apiRewardProgram === void 0) throw Error("get new reward mint info error");
        const itemReward = __spreadProps(__spreadValues({}, _itemReward), {
          perSecond: MathUtil.x64ToDecimal(_itemReward.emissionsPerSecondX64),
          remainingRewards: void 0,
          tokenProgramId: new PublicKey(apiRewardProgram)
        });
        if (itemReward.tokenMint.equals(PublicKey.default)) continue;
        if (chainTime <= itemReward.openTime.toNumber() || poolLiquidity.eq(ZERO)) {
          nRewardInfo.push(itemReward);
          continue;
        }
        const latestUpdateTime = new import_bn15.default(Math.min(itemReward.endTime.toNumber(), chainTime));
        const timeDelta = latestUpdateTime.sub(itemReward.lastUpdateTime);
        const rewardGrowthDeltaX64 = MathUtil.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, poolLiquidity);
        const rewardGrowthGlobalX64 = itemReward.rewardGrowthGlobalX64.add(rewardGrowthDeltaX64);
        const rewardEmissionedDelta = MathUtil.mulDivFloor(timeDelta, itemReward.emissionsPerSecondX64, Q64);
        const rewardTotalEmissioned = itemReward.rewardTotalEmissioned.add(rewardEmissionedDelta);
        nRewardInfo.push(__spreadProps(__spreadValues({}, itemReward), {
          rewardGrowthGlobalX64,
          rewardTotalEmissioned,
          lastUpdateTime: latestUpdateTime
        }));
      }
      return nRewardInfo;
    });
  }
  static isOverflowDefaultTickarrayBitmap(tickSpacing, tickarrayStartIndexs) {
    const { maxTickBoundary, minTickBoundary } = this.tickRange(tickSpacing);
    for (const tickIndex of tickarrayStartIndexs) {
      const tickarrayStartIndex = TickUtils.getTickArrayStartIndexByTick(tickIndex, tickSpacing);
      if (tickarrayStartIndex >= maxTickBoundary || tickarrayStartIndex < minTickBoundary) {
        return true;
      }
    }
    return false;
  }
  static tickRange(tickSpacing) {
    let maxTickBoundary = TickArrayBitmap.maxTickInTickarrayBitmap(tickSpacing);
    let minTickBoundary = -maxTickBoundary;
    if (maxTickBoundary > MAX_TICK) {
      maxTickBoundary = TickQuery.getArrayStartIndex(MAX_TICK, tickSpacing) + TickQuery.tickCount(tickSpacing);
    }
    if (minTickBoundary < MIN_TICK) {
      minTickBoundary = TickQuery.getArrayStartIndex(MIN_TICK, tickSpacing);
    }
    return { maxTickBoundary, minTickBoundary };
  }
  static get_tick_array_offset(tickarrayStartIndex, tickSpacing) {
    if (!TickQuery.checkIsValidStartIndex(tickarrayStartIndex, tickSpacing)) {
      throw new Error("No enough initialized tickArray");
    }
    return tickarrayStartIndex / TickQuery.tickCount(tickSpacing) * TICK_ARRAY_BITMAP_SIZE;
  }
};
var MathUtil = class {
  static mulDivRoundingUp(a, b, denominator) {
    const numerator = a.mul(b);
    let result = numerator.div(denominator);
    if (!numerator.mod(denominator).eq(ZERO)) {
      result = result.add(ONE);
    }
    return result;
  }
  static mulDivFloor(a, b, denominator) {
    if (denominator.eq(ZERO)) {
      throw new Error("division by 0");
    }
    return a.mul(b).div(denominator);
  }
  static mulDivCeil(a, b, denominator) {
    if (denominator.eq(ZERO)) {
      throw new Error("division by 0");
    }
    const numerator = a.mul(b).add(denominator.sub(ONE));
    return numerator.div(denominator);
  }
  static x64ToDecimal(num, decimalPlaces) {
    return new decimal_default2(num.toString()).div(decimal_default2.pow(2, 64)).toDecimalPlaces(decimalPlaces);
  }
  static decimalToX64(num) {
    return new import_bn14.default(num.mul(decimal_default2.pow(2, 64)).floor().toFixed());
  }
  static wrappingSubU128(n0, n1) {
    return n0.add(Q128).sub(n1).mod(Q128);
  }
};
function mulRightShift(val, mulBy) {
  return signedRightShift(val.mul(mulBy), 64, 256);
}
function signedLeftShift(n0, shiftBy, bitWidth) {
  const twosN0 = n0.toTwos(bitWidth).shln(shiftBy);
  twosN0.imaskn(bitWidth + 1);
  return twosN0.fromTwos(bitWidth);
}
function signedRightShift(n0, shiftBy, bitWidth) {
  const twoN0 = n0.toTwos(bitWidth).shrn(shiftBy);
  twoN0.imaskn(bitWidth - shiftBy + 1);
  return twoN0.fromTwos(bitWidth - shiftBy);
}
var SqrtPriceMath = class _SqrtPriceMath {
  static sqrtPriceX64ToPrice(sqrtPriceX64, decimalsA, decimalsB) {
    return MathUtil.x64ToDecimal(sqrtPriceX64).pow(2).mul(decimal_default2.pow(10, decimalsA - decimalsB));
  }
  static priceToSqrtPriceX64(price, decimalsA, decimalsB) {
    return MathUtil.decimalToX64(price.mul(decimal_default2.pow(10, decimalsB - decimalsA)).sqrt());
  }
  static getNextSqrtPriceX64FromInput(sqrtPriceX64, liquidity, amountIn, zeroForOne) {
    if (!sqrtPriceX64.gt(ZERO)) {
      throw new Error("sqrtPriceX64 must greater than 0");
    }
    if (!liquidity.gt(ZERO)) {
      throw new Error("liquidity must greater than 0");
    }
    return zeroForOne ? this.getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amountIn, true) : this.getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amountIn, true);
  }
  static getNextSqrtPriceX64FromOutput(sqrtPriceX64, liquidity, amountOut, zeroForOne) {
    if (!sqrtPriceX64.gt(ZERO)) {
      throw new Error("sqrtPriceX64 must greater than 0");
    }
    if (!liquidity.gt(ZERO)) {
      throw new Error("liquidity must greater than 0");
    }
    return zeroForOne ? this.getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amountOut, false) : this.getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amountOut, false);
  }
  static getNextSqrtPriceFromTokenAmountARoundingUp(sqrtPriceX64, liquidity, amount, add2) {
    if (amount.eq(ZERO)) return sqrtPriceX64;
    const liquidityLeftShift = liquidity.shln(U64Resolution);
    if (add2) {
      const numerator1 = liquidityLeftShift;
      const denominator = liquidityLeftShift.add(amount.mul(sqrtPriceX64));
      if (denominator.gte(numerator1)) {
        return MathUtil.mulDivCeil(numerator1, sqrtPriceX64, denominator);
      }
      return MathUtil.mulDivRoundingUp(numerator1, ONE, numerator1.div(sqrtPriceX64).add(amount));
    } else {
      const amountMulSqrtPrice = amount.mul(sqrtPriceX64);
      if (!liquidityLeftShift.gt(amountMulSqrtPrice)) {
        throw new Error("getNextSqrtPriceFromTokenAmountARoundingUp,liquidityLeftShift must gt amountMulSqrtPrice");
      }
      const denominator = liquidityLeftShift.sub(amountMulSqrtPrice);
      return MathUtil.mulDivCeil(liquidityLeftShift, sqrtPriceX64, denominator);
    }
  }
  static getNextSqrtPriceFromTokenAmountBRoundingDown(sqrtPriceX64, liquidity, amount, add2) {
    const deltaY = amount.shln(U64Resolution);
    if (add2) {
      return sqrtPriceX64.add(deltaY.div(liquidity));
    } else {
      const amountDivLiquidity = MathUtil.mulDivRoundingUp(deltaY, ONE, liquidity);
      if (!sqrtPriceX64.gt(amountDivLiquidity)) {
        throw new Error("getNextSqrtPriceFromTokenAmountBRoundingDown sqrtPriceX64 must gt amountDivLiquidity");
      }
      return sqrtPriceX64.sub(amountDivLiquidity);
    }
  }
  static getSqrtPriceX64FromTick(tick) {
    if (!Number.isInteger(tick)) {
      throw new Error("tick must be integer");
    }
    if (tick < MIN_TICK || tick > MAX_TICK) {
      throw new Error("tick must be in MIN_TICK and MAX_TICK");
    }
    const tickAbs = tick < 0 ? tick * -1 : tick;
    let ratio = (tickAbs & 1) != 0 ? new import_bn14.default("18445821805675395072") : new import_bn14.default("18446744073709551616");
    if ((tickAbs & 2) != 0) ratio = mulRightShift(ratio, new import_bn14.default("18444899583751176192"));
    if ((tickAbs & 4) != 0) ratio = mulRightShift(ratio, new import_bn14.default("18443055278223355904"));
    if ((tickAbs & 8) != 0) ratio = mulRightShift(ratio, new import_bn14.default("18439367220385607680"));
    if ((tickAbs & 16) != 0) ratio = mulRightShift(ratio, new import_bn14.default("18431993317065453568"));
    if ((tickAbs & 32) != 0) ratio = mulRightShift(ratio, new import_bn14.default("18417254355718170624"));
    if ((tickAbs & 64) != 0) ratio = mulRightShift(ratio, new import_bn14.default("18387811781193609216"));
    if ((tickAbs & 128) != 0) ratio = mulRightShift(ratio, new import_bn14.default("18329067761203558400"));
    if ((tickAbs & 256) != 0) ratio = mulRightShift(ratio, new import_bn14.default("18212142134806163456"));
    if ((tickAbs & 512) != 0) ratio = mulRightShift(ratio, new import_bn14.default("17980523815641700352"));
    if ((tickAbs & 1024) != 0) ratio = mulRightShift(ratio, new import_bn14.default("17526086738831433728"));
    if ((tickAbs & 2048) != 0) ratio = mulRightShift(ratio, new import_bn14.default("16651378430235570176"));
    if ((tickAbs & 4096) != 0) ratio = mulRightShift(ratio, new import_bn14.default("15030750278694412288"));
    if ((tickAbs & 8192) != 0) ratio = mulRightShift(ratio, new import_bn14.default("12247334978884435968"));
    if ((tickAbs & 16384) != 0) ratio = mulRightShift(ratio, new import_bn14.default("8131365268886854656"));
    if ((tickAbs & 32768) != 0) ratio = mulRightShift(ratio, new import_bn14.default("3584323654725218816"));
    if ((tickAbs & 65536) != 0) ratio = mulRightShift(ratio, new import_bn14.default("696457651848324352"));
    if ((tickAbs & 131072) != 0) ratio = mulRightShift(ratio, new import_bn14.default("26294789957507116"));
    if ((tickAbs & 262144) != 0) ratio = mulRightShift(ratio, new import_bn14.default("37481735321082"));
    if (tick > 0) ratio = MaxUint128.div(ratio);
    return ratio;
  }
  static getTickFromPrice(price, decimalsA, decimalsB) {
    return _SqrtPriceMath.getTickFromSqrtPriceX64(_SqrtPriceMath.priceToSqrtPriceX64(price, decimalsA, decimalsB));
  }
  static getTickFromSqrtPriceX64(sqrtPriceX64) {
    if (sqrtPriceX64.gt(MAX_SQRT_PRICE_X64) || sqrtPriceX64.lt(MIN_SQRT_PRICE_X64)) {
      throw new Error("Provided sqrtPrice is not within the supported sqrtPrice range.");
    }
    const msb = sqrtPriceX64.bitLength() - 1;
    const adjustedMsb = new import_bn14.default(msb - 64);
    const log2pIntegerX32 = signedLeftShift(adjustedMsb, 32, 128);
    let bit = new import_bn14.default("8000000000000000", "hex");
    let precision = 0;
    let log2pFractionX64 = new import_bn14.default(0);
    let r = msb >= 64 ? sqrtPriceX64.shrn(msb - 63) : sqrtPriceX64.shln(63 - msb);
    while (bit.gt(new import_bn14.default(0)) && precision < BIT_PRECISION) {
      r = r.mul(r);
      const rMoreThanTwo = r.shrn(127);
      r = r.shrn(63 + rMoreThanTwo.toNumber());
      log2pFractionX64 = log2pFractionX64.add(bit.mul(rMoreThanTwo));
      bit = bit.shrn(1);
      precision += 1;
    }
    const log2pFractionX32 = log2pFractionX64.shrn(32);
    const log2pX32 = log2pIntegerX32.add(log2pFractionX32);
    const logbpX64 = log2pX32.mul(new import_bn14.default(LOG_B_2_X32));
    const tickLow = signedRightShift(logbpX64.sub(new import_bn14.default(LOG_B_P_ERR_MARGIN_LOWER_X64)), 64, 128).toNumber();
    const tickHigh = signedRightShift(logbpX64.add(new import_bn14.default(LOG_B_P_ERR_MARGIN_UPPER_X64)), 64, 128).toNumber();
    if (tickLow == tickHigh) {
      return tickLow;
    } else {
      const derivedTickHighSqrtPriceX64 = _SqrtPriceMath.getSqrtPriceX64FromTick(tickHigh);
      return derivedTickHighSqrtPriceX64.lte(sqrtPriceX64) ? tickHigh : tickLow;
    }
  }
};
var TickMath = class _TickMath {
  static getTickWithPriceAndTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB) {
    const tick = SqrtPriceMath.getTickFromSqrtPriceX64(
      SqrtPriceMath.priceToSqrtPriceX64(price, mintDecimalsA, mintDecimalsB)
    );
    let result = tick / tickSpacing;
    if (result < 0) {
      result = Math.floor(result);
    } else {
      result = Math.ceil(result);
    }
    return result * tickSpacing;
  }
  static roundPriceWithTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB) {
    const tick = _TickMath.getTickWithPriceAndTickspacing(price, tickSpacing, mintDecimalsA, mintDecimalsB);
    const sqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    return SqrtPriceMath.sqrtPriceX64ToPrice(sqrtPriceX64, mintDecimalsA, mintDecimalsB);
  }
};
var LiquidityMath = class _LiquidityMath {
  static addDelta(x, y) {
    return x.add(y);
  }
  static getTokenAmountAFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (!sqrtPriceX64A.gt(ZERO)) {
      throw new Error("sqrtPriceX64A must greater than 0");
    }
    const numerator1 = liquidity.ushln(U64Resolution);
    const numerator2 = sqrtPriceX64B.sub(sqrtPriceX64A);
    return roundUp ? MathUtil.mulDivRoundingUp(MathUtil.mulDivCeil(numerator1, numerator2, sqrtPriceX64B), ONE, sqrtPriceX64A) : MathUtil.mulDivFloor(numerator1, numerator2, sqrtPriceX64B).div(sqrtPriceX64A);
  }
  static getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (!sqrtPriceX64A.gt(ZERO)) {
      throw new Error("sqrtPriceX64A must greater than 0");
    }
    return roundUp ? MathUtil.mulDivCeil(liquidity, sqrtPriceX64B.sub(sqrtPriceX64A), Q64) : MathUtil.mulDivFloor(liquidity, sqrtPriceX64B.sub(sqrtPriceX64A), Q64);
  }
  static getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, amountA, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    const numerator = amountA.mul(sqrtPriceX64A).mul(sqrtPriceX64B);
    const denominator = sqrtPriceX64B.sub(sqrtPriceX64A);
    const result = numerator.div(denominator);
    if (roundUp) {
      return MathUtil.mulDivRoundingUp(result, ONE, MaxU64);
    } else {
      return result.shrn(U64Resolution);
    }
  }
  static getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, amountB) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    return MathUtil.mulDivFloor(amountB, MaxU64, sqrtPriceX64B.sub(sqrtPriceX64A));
  }
  static getLiquidityFromTokenAmounts(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, amountA, amountB) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (sqrtPriceCurrentX64.lte(sqrtPriceX64A)) {
      return _LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, amountA, false);
    } else if (sqrtPriceCurrentX64.lt(sqrtPriceX64B)) {
      const liquidity0 = _LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceCurrentX64, sqrtPriceX64B, amountA, false);
      const liquidity1 = _LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceCurrentX64, amountB);
      return liquidity0.lt(liquidity1) ? liquidity0 : liquidity1;
    } else {
      return _LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, amountB);
    }
  }
  static getAmountsFromLiquidity(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp) {
    if (sqrtPriceX64A.gt(sqrtPriceX64B)) {
      ;
      [sqrtPriceX64A, sqrtPriceX64B] = [sqrtPriceX64B, sqrtPriceX64A];
    }
    if (sqrtPriceCurrentX64.lte(sqrtPriceX64A)) {
      return {
        amountA: _LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp),
        amountB: new import_bn14.default(0)
      };
    } else if (sqrtPriceCurrentX64.lt(sqrtPriceX64B)) {
      const amountA = _LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceCurrentX64, sqrtPriceX64B, liquidity, roundUp);
      const amountB = _LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceCurrentX64, liquidity, roundUp);
      return { amountA, amountB };
    } else {
      return {
        amountA: new import_bn14.default(0),
        amountB: _LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64A, sqrtPriceX64B, liquidity, roundUp)
      };
    }
  }
  static getAmountsFromLiquidityWithSlippage(sqrtPriceCurrentX64, sqrtPriceX64A, sqrtPriceX64B, liquidity, amountMax, roundUp, amountSlippage) {
    const { amountA, amountB } = _LiquidityMath.getAmountsFromLiquidity(
      sqrtPriceCurrentX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      liquidity,
      roundUp
    );
    const coefficient = amountMax ? 1 + amountSlippage : 1 - amountSlippage;
    const amount0Slippage = new import_bn14.default(new decimal_default2(amountA.toString()).mul(coefficient).toFixed(0));
    const amount1Slippage = new import_bn14.default(new decimal_default2(amountB.toString()).mul(coefficient).toFixed(0));
    return {
      amountSlippageA: amount0Slippage,
      amountSlippageB: amount1Slippage
    };
  }
};
var SwapMath = class _SwapMath {
  static swapCompute(programId, poolId, tickArrayCache, tickArrayBitmap, tickarrayBitmapExtension, zeroForOne, fee, liquidity, currentTick, tickSpacing, currentSqrtPriceX64, amountSpecified, lastSavedTickArrayStartIndex, sqrtPriceLimitX64, catchLiquidityInsufficient = false) {
    if (amountSpecified.eq(ZERO)) {
      throw new Error("amountSpecified must not be 0");
    }
    if (!sqrtPriceLimitX64) sqrtPriceLimitX64 = zeroForOne ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
    if (zeroForOne) {
      if (sqrtPriceLimitX64.lt(MIN_SQRT_PRICE_X64)) {
        throw new Error("sqrtPriceX64 must greater than MIN_SQRT_PRICE_X64");
      }
      if (sqrtPriceLimitX64.gte(currentSqrtPriceX64)) {
        throw new Error("sqrtPriceX64 must smaller than current");
      }
    } else {
      if (sqrtPriceLimitX64.gt(MAX_SQRT_PRICE_X64)) {
        throw new Error("sqrtPriceX64 must smaller than MAX_SQRT_PRICE_X64");
      }
      if (sqrtPriceLimitX64.lte(currentSqrtPriceX64)) {
        throw new Error("sqrtPriceX64 must greater than current");
      }
    }
    const baseInput = amountSpecified.gt(ZERO);
    const state = {
      amountSpecifiedRemaining: amountSpecified,
      amountCalculated: ZERO,
      sqrtPriceX64: currentSqrtPriceX64,
      tick: currentTick > lastSavedTickArrayStartIndex ? Math.min(lastSavedTickArrayStartIndex + TickQuery.tickCount(tickSpacing) - 1, currentTick) : lastSavedTickArrayStartIndex,
      accounts: [],
      liquidity,
      feeAmount: new import_bn14.default(0)
    };
    let tickAarrayStartIndex = lastSavedTickArrayStartIndex;
    let tickArrayCurrent = tickArrayCache[lastSavedTickArrayStartIndex];
    let loopCount = 0;
    let t = !zeroForOne && tickArrayCurrent.startTickIndex === state.tick;
    while (!state.amountSpecifiedRemaining.eq(ZERO) && !state.sqrtPriceX64.eq(sqrtPriceLimitX64)) {
      if (loopCount > 10) {
      }
      const step = {};
      step.sqrtPriceStartX64 = state.sqrtPriceX64;
      const tickState = TickUtils.nextInitTick(tickArrayCurrent, state.tick, tickSpacing, zeroForOne, t);
      let nextInitTick = tickState ? tickState : null;
      let tickArrayAddress = null;
      if (!(nextInitTick == null ? void 0 : nextInitTick.liquidityGross.gtn(0))) {
        const nextInitTickArrayIndex = PoolUtils.nextInitializedTickArrayStartIndex(
          {
            tickCurrent: state.tick,
            tickSpacing,
            tickArrayBitmap,
            exBitmapInfo: tickarrayBitmapExtension
          },
          tickAarrayStartIndex,
          zeroForOne
        );
        if (!nextInitTickArrayIndex.isExist) {
          if (catchLiquidityInsufficient) {
            return {
              allTrade: false,
              amountSpecifiedRemaining: state.amountSpecifiedRemaining,
              amountCalculated: state.amountCalculated,
              feeAmount: state.feeAmount,
              sqrtPriceX64: state.sqrtPriceX64,
              liquidity: state.liquidity,
              tickCurrent: state.tick,
              accounts: state.accounts
            };
          }
          throw Error("swapCompute LiquidityInsufficient");
        }
        tickAarrayStartIndex = nextInitTickArrayIndex.nextStartIndex;
        const { publicKey: expectedNextTickArrayAddress } = getPdaTickArrayAddress(
          programId,
          poolId,
          tickAarrayStartIndex
        );
        tickArrayAddress = expectedNextTickArrayAddress;
        tickArrayCurrent = tickArrayCache[tickAarrayStartIndex];
        try {
          nextInitTick = TickUtils.firstInitializedTick(tickArrayCurrent, zeroForOne);
        } catch (e) {
          throw Error("not found next tick info");
        }
      }
      step.tickNext = nextInitTick.tick;
      step.initialized = nextInitTick.liquidityGross.gtn(0);
      if (lastSavedTickArrayStartIndex !== tickAarrayStartIndex && tickArrayAddress) {
        state.accounts.push(tickArrayAddress);
        lastSavedTickArrayStartIndex = tickAarrayStartIndex;
      }
      if (step.tickNext < MIN_TICK) {
        step.tickNext = MIN_TICK;
      } else if (step.tickNext > MAX_TICK) {
        step.tickNext = MAX_TICK;
      }
      step.sqrtPriceNextX64 = SqrtPriceMath.getSqrtPriceX64FromTick(step.tickNext);
      let targetPrice;
      if (zeroForOne && step.sqrtPriceNextX64.lt(sqrtPriceLimitX64) || !zeroForOne && step.sqrtPriceNextX64.gt(sqrtPriceLimitX64)) {
        targetPrice = sqrtPriceLimitX64;
      } else {
        targetPrice = step.sqrtPriceNextX64;
      }
      ;
      [state.sqrtPriceX64, step.amountIn, step.amountOut, step.feeAmount] = _SwapMath.swapStepCompute(
        state.sqrtPriceX64,
        targetPrice,
        state.liquidity,
        state.amountSpecifiedRemaining,
        fee
      );
      state.feeAmount = state.feeAmount.add(step.feeAmount);
      if (baseInput) {
        state.amountSpecifiedRemaining = state.amountSpecifiedRemaining.sub(step.amountIn.add(step.feeAmount));
        state.amountCalculated = state.amountCalculated.sub(step.amountOut);
      } else {
        state.amountSpecifiedRemaining = state.amountSpecifiedRemaining.add(step.amountOut);
        state.amountCalculated = state.amountCalculated.add(step.amountIn.add(step.feeAmount));
      }
      if (state.sqrtPriceX64.eq(step.sqrtPriceNextX64)) {
        if (step.initialized) {
          let liquidityNet = nextInitTick.liquidityNet;
          if (zeroForOne) liquidityNet = liquidityNet.mul(NEGATIVE_ONE);
          state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
        }
        t = step.tickNext != state.tick && !zeroForOne && tickArrayCurrent.startTickIndex === step.tickNext;
        state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
      } else if (state.sqrtPriceX64 != step.sqrtPriceStartX64) {
        const _T = SqrtPriceMath.getTickFromSqrtPriceX64(state.sqrtPriceX64);
        t = _T != state.tick && !zeroForOne && tickArrayCurrent.startTickIndex === _T;
        state.tick = _T;
      }
      ++loopCount;
    }
    try {
      const { nextStartIndex: tickAarrayStartIndex2, isExist } = TickQuery.nextInitializedTickArray(
        state.tick,
        tickSpacing,
        zeroForOne,
        tickArrayBitmap,
        tickarrayBitmapExtension
      );
      if (isExist && lastSavedTickArrayStartIndex !== tickAarrayStartIndex2) {
        state.accounts.push(getPdaTickArrayAddress(programId, poolId, tickAarrayStartIndex2).publicKey);
        lastSavedTickArrayStartIndex = tickAarrayStartIndex2;
      }
    } catch (e) {
    }
    return {
      allTrade: true,
      amountSpecifiedRemaining: ZERO,
      amountCalculated: state.amountCalculated,
      feeAmount: state.feeAmount,
      sqrtPriceX64: state.sqrtPriceX64,
      liquidity: state.liquidity,
      tickCurrent: state.tick,
      accounts: state.accounts
    };
  }
  static swapStepCompute(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, amountRemaining, feeRate) {
    const swapStep = {
      sqrtPriceX64Next: new import_bn14.default(0),
      amountIn: new import_bn14.default(0),
      amountOut: new import_bn14.default(0),
      feeAmount: new import_bn14.default(0)
    };
    const zeroForOne = sqrtPriceX64Current.gte(sqrtPriceX64Target);
    const baseInput = amountRemaining.gte(ZERO);
    if (baseInput) {
      const amountRemainingSubtractFee = MathUtil.mulDivFloor(
        amountRemaining,
        FEE_RATE_DENOMINATOR.sub(new import_bn14.default(feeRate.toString())),
        FEE_RATE_DENOMINATOR
      );
      swapStep.amountIn = zeroForOne ? LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64Target, sqrtPriceX64Current, liquidity, true) : LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, true);
      if (amountRemainingSubtractFee.gte(swapStep.amountIn)) {
        swapStep.sqrtPriceX64Next = sqrtPriceX64Target;
      } else {
        swapStep.sqrtPriceX64Next = SqrtPriceMath.getNextSqrtPriceX64FromInput(
          sqrtPriceX64Current,
          liquidity,
          amountRemainingSubtractFee,
          zeroForOne
        );
      }
    } else {
      swapStep.amountOut = zeroForOne ? LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64Target, sqrtPriceX64Current, liquidity, false) : LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64Current, sqrtPriceX64Target, liquidity, false);
      if (amountRemaining.mul(NEGATIVE_ONE).gte(swapStep.amountOut)) {
        swapStep.sqrtPriceX64Next = sqrtPriceX64Target;
      } else {
        swapStep.sqrtPriceX64Next = SqrtPriceMath.getNextSqrtPriceX64FromOutput(
          sqrtPriceX64Current,
          liquidity,
          amountRemaining.mul(NEGATIVE_ONE),
          zeroForOne
        );
      }
    }
    const reachTargetPrice = sqrtPriceX64Target.eq(swapStep.sqrtPriceX64Next);
    if (zeroForOne) {
      if (!(reachTargetPrice && baseInput)) {
        swapStep.amountIn = LiquidityMath.getTokenAmountAFromLiquidity(
          swapStep.sqrtPriceX64Next,
          sqrtPriceX64Current,
          liquidity,
          true
        );
      }
      if (!(reachTargetPrice && !baseInput)) {
        swapStep.amountOut = LiquidityMath.getTokenAmountBFromLiquidity(
          swapStep.sqrtPriceX64Next,
          sqrtPriceX64Current,
          liquidity,
          false
        );
      }
    } else {
      swapStep.amountIn = reachTargetPrice && baseInput ? swapStep.amountIn : LiquidityMath.getTokenAmountBFromLiquidity(sqrtPriceX64Current, swapStep.sqrtPriceX64Next, liquidity, true);
      swapStep.amountOut = reachTargetPrice && !baseInput ? swapStep.amountOut : LiquidityMath.getTokenAmountAFromLiquidity(sqrtPriceX64Current, swapStep.sqrtPriceX64Next, liquidity, false);
    }
    if (!baseInput && swapStep.amountOut.gt(amountRemaining.mul(NEGATIVE_ONE))) {
      swapStep.amountOut = amountRemaining.mul(NEGATIVE_ONE);
    }
    if (baseInput && !swapStep.sqrtPriceX64Next.eq(sqrtPriceX64Target)) {
      swapStep.feeAmount = amountRemaining.sub(swapStep.amountIn);
    } else {
      swapStep.feeAmount = MathUtil.mulDivCeil(
        swapStep.amountIn,
        new import_bn14.default(feeRate),
        FEE_RATE_DENOMINATOR.sub(new import_bn14.default(feeRate))
      );
    }
    return [swapStep.sqrtPriceX64Next, swapStep.amountIn, swapStep.amountOut, swapStep.feeAmount];
  }
};
var PositionUtils = class {
  static getfeeGrowthInside(poolState, tickLowerState, tickUpperState) {
    let feeGrowthBelowX64A = new import_bn16.default(0);
    let feeGrowthBelowX64B = new import_bn16.default(0);
    if (poolState.tickCurrent >= tickLowerState.tick) {
      feeGrowthBelowX64A = tickLowerState.feeGrowthOutsideX64A;
      feeGrowthBelowX64B = tickLowerState.feeGrowthOutsideX64B;
    } else {
      feeGrowthBelowX64A = poolState.feeGrowthGlobalX64A.sub(tickLowerState.feeGrowthOutsideX64A);
      feeGrowthBelowX64B = poolState.feeGrowthGlobalX64B.sub(tickLowerState.feeGrowthOutsideX64B);
    }
    let feeGrowthAboveX64A = new import_bn16.default(0);
    let feeGrowthAboveX64B = new import_bn16.default(0);
    if (poolState.tickCurrent < tickUpperState.tick) {
      feeGrowthAboveX64A = tickUpperState.feeGrowthOutsideX64A;
      feeGrowthAboveX64B = tickUpperState.feeGrowthOutsideX64B;
    } else {
      feeGrowthAboveX64A = poolState.feeGrowthGlobalX64A.sub(tickUpperState.feeGrowthOutsideX64A);
      feeGrowthAboveX64B = poolState.feeGrowthGlobalX64B.sub(tickUpperState.feeGrowthOutsideX64B);
    }
    const feeGrowthInsideX64A = MathUtil.wrappingSubU128(
      MathUtil.wrappingSubU128(poolState.feeGrowthGlobalX64A, feeGrowthBelowX64A),
      feeGrowthAboveX64A
    );
    const feeGrowthInsideBX64 = MathUtil.wrappingSubU128(
      MathUtil.wrappingSubU128(poolState.feeGrowthGlobalX64B, feeGrowthBelowX64B),
      feeGrowthAboveX64B
    );
    return { feeGrowthInsideX64A, feeGrowthInsideBX64 };
  }
  static GetPositionFees(ammPool, positionState, tickLowerState, tickUpperState) {
    const { feeGrowthInsideX64A, feeGrowthInsideBX64 } = this.getfeeGrowthInside(
      ammPool,
      tickLowerState,
      tickUpperState
    );
    const feeGrowthdeltaA = MathUtil.mulDivFloor(
      MathUtil.wrappingSubU128(feeGrowthInsideX64A, positionState.feeGrowthInsideLastX64A),
      positionState.liquidity,
      Q64
    );
    const tokenFeeAmountA = positionState.tokenFeesOwedA.add(feeGrowthdeltaA);
    const feeGrowthdelta1 = MathUtil.mulDivFloor(
      MathUtil.wrappingSubU128(feeGrowthInsideBX64, positionState.feeGrowthInsideLastX64B),
      positionState.liquidity,
      Q64
    );
    const tokenFeeAmountB = positionState.tokenFeesOwedB.add(feeGrowthdelta1);
    return { tokenFeeAmountA, tokenFeeAmountB };
  }
  static GetPositionRewards(ammPool, positionState, tickLowerState, tickUpperState) {
    const rewards = [];
    const rewardGrowthsInside = this.getRewardGrowthInside(
      ammPool.tickCurrent,
      tickLowerState,
      tickUpperState,
      ammPool.rewardInfos
    );
    for (let i = 0; i < rewardGrowthsInside.length; i++) {
      const rewardGrowthInside = rewardGrowthsInside[i];
      const currRewardInfo = positionState.rewardInfos[i];
      const rewardGrowthDelta = MathUtil.wrappingSubU128(rewardGrowthInside, currRewardInfo.growthInsideLastX64);
      const amountOwedDelta = MathUtil.mulDivFloor(rewardGrowthDelta, positionState.liquidity, Q64);
      const rewardAmountOwed = currRewardInfo.rewardAmountOwed.add(amountOwedDelta);
      rewards.push(rewardAmountOwed);
    }
    return rewards;
  }
  static getRewardGrowthInside(tickCurrentIndex, tickLowerState, tickUpperState, rewardInfos) {
    const rewardGrowthsInside = [];
    for (let i = 0; i < rewardInfos.length; i++) {
      let rewardGrowthsBelow = new import_bn16.default(0);
      if (tickLowerState.liquidityGross.eqn(0)) {
        rewardGrowthsBelow = rewardInfos[i].rewardGrowthGlobalX64;
      } else if (tickCurrentIndex < tickLowerState.tick) {
        rewardGrowthsBelow = rewardInfos[i].rewardGrowthGlobalX64.sub(tickLowerState.rewardGrowthsOutsideX64[i]);
      } else {
        rewardGrowthsBelow = tickLowerState.rewardGrowthsOutsideX64[i];
      }
      let rewardGrowthsAbove = new import_bn16.default(0);
      if (tickUpperState.liquidityGross.eqn(0)) {
      } else if (tickCurrentIndex < tickUpperState.tick) {
        rewardGrowthsAbove = tickUpperState.rewardGrowthsOutsideX64[i];
      } else {
        rewardGrowthsAbove = rewardInfos[i].rewardGrowthGlobalX64.sub(tickUpperState.rewardGrowthsOutsideX64[i]);
      }
      rewardGrowthsInside.push(
        MathUtil.wrappingSubU128(
          MathUtil.wrappingSubU128(rewardInfos[i].rewardGrowthGlobalX64, rewardGrowthsBelow),
          rewardGrowthsAbove
        )
      );
    }
    return rewardGrowthsInside;
  }
};
var logger9 = Logger.from("Clmm");
var Clmm = class extends Base {
  static makeMockPoolInfo({
    programId,
    mint1,
    mint2,
    ammConfig,
    createPoolInstructionSimpleAddress,
    initialPrice,
    startTime,
    owner
  }) {
    const [mintA, mintB, initPrice] = new import_bn11.default(mint1.mint.toBuffer()).gt(new import_bn11.default(mint2.mint.toBuffer())) ? [mint2, mint1, new decimal_default2(1).div(initialPrice)] : [mint1, mint2, initialPrice];
    const initialPriceX64 = SqrtPriceMath.priceToSqrtPriceX64(initPrice, mintA.decimals, mintB.decimals);
    return {
      id: createPoolInstructionSimpleAddress.poolId,
      mintA: {
        programId: createPoolInstructionSimpleAddress.mintProgramIdA,
        mint: createPoolInstructionSimpleAddress.mintA,
        vault: createPoolInstructionSimpleAddress.mintAVault,
        decimals: mintA.decimals
      },
      mintB: {
        programId: createPoolInstructionSimpleAddress.mintProgramIdB,
        mint: createPoolInstructionSimpleAddress.mintB,
        vault: createPoolInstructionSimpleAddress.mintBVault,
        decimals: mintB.decimals
      },
      ammConfig,
      observationId: createPoolInstructionSimpleAddress.observationId,
      creator: owner,
      programId,
      version: 6,
      tickSpacing: ammConfig.tickSpacing,
      liquidity: ZERO,
      sqrtPriceX64: initialPriceX64,
      currentPrice: initPrice,
      tickCurrent: 0,
      observationIndex: 0,
      observationUpdateDuration: 0,
      feeGrowthGlobalX64A: ZERO,
      feeGrowthGlobalX64B: ZERO,
      protocolFeesTokenA: ZERO,
      protocolFeesTokenB: ZERO,
      swapInAmountTokenA: ZERO,
      swapOutAmountTokenB: ZERO,
      swapInAmountTokenB: ZERO,
      swapOutAmountTokenA: ZERO,
      tickArrayBitmap: [],
      rewardInfos: [],
      day: {
        volume: 0,
        volumeFee: 0,
        feeA: 0,
        feeB: 0,
        feeApr: 0,
        rewardApr: { A: 0, B: 0, C: 0 },
        apr: 0,
        priceMax: 0,
        priceMin: 0
      },
      week: {
        volume: 0,
        volumeFee: 0,
        feeA: 0,
        feeB: 0,
        feeApr: 0,
        rewardApr: { A: 0, B: 0, C: 0 },
        apr: 0,
        priceMax: 0,
        priceMin: 0
      },
      month: {
        volume: 0,
        volumeFee: 0,
        feeA: 0,
        feeB: 0,
        feeApr: 0,
        rewardApr: { A: 0, B: 0, C: 0 },
        apr: 0,
        priceMax: 0,
        priceMin: 0
      },
      tvl: 0,
      lookupTableAccount: PublicKey.default,
      startTime: startTime.toNumber(),
      exBitmapInfo: {
        poolId: createPoolInstructionSimpleAddress.poolId,
        positiveTickArrayBitmap: Array.from(
          { length: EXTENSION_TICKARRAY_BITMAP_SIZE },
          () => Array.from({ length: 8 }, () => new import_bn11.default(0))
        ),
        negativeTickArrayBitmap: Array.from(
          { length: EXTENSION_TICKARRAY_BITMAP_SIZE },
          () => Array.from({ length: 8 }, () => new import_bn11.default(0))
        )
      }
    };
  }
  // transaction
  static makeCreatePoolInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      makeTxVersion,
      connection,
      programId,
      owner,
      payer,
      mint1,
      mint2,
      ammConfig,
      initialPrice,
      startTime,
      computeBudgetConfig,
      lookupTableCache
    }) {
      const [mintA, mintB, initPrice] = new import_bn11.default(mint1.mint.toBuffer()).gt(new import_bn11.default(mint2.mint.toBuffer())) ? [mint2, mint1, new decimal_default2(1).div(initialPrice)] : [mint1, mint2, initialPrice];
      const initialPriceX64 = SqrtPriceMath.priceToSqrtPriceX64(initPrice, mintA.decimals, mintB.decimals);
      const makeCreatePoolInstructions = yield this.makeCreatePoolInstructions({
        connection,
        programId,
        owner,
        mintA,
        mintB,
        ammConfigId: ammConfig.id,
        initialPriceX64,
        startTime
      });
      return {
        address: __spreadProps(__spreadValues({}, makeCreatePoolInstructions.address), {
          mintA: mintA.mint,
          mintB: mintB.mint,
          mintProgramIdA: mintA.programId,
          mintProgramIdB: mintB.programId
        }),
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer,
          innerTransaction: [makeCreatePoolInstructions.innerTransaction],
          lookupTableCache
        })
      };
    });
  }
  static makeOpenPositionFromLiquidityInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      makeTxVersion,
      connection,
      poolInfo,
      ownerInfo,
      amountMaxA,
      amountMaxB,
      tickLower,
      tickUpper,
      liquidity,
      associatedOnly = true,
      checkCreateATAOwner = false,
      withMetadata = "create",
      getEphemeralSigners,
      computeBudgetConfig,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance || amountMaxA.eq(ZERO) ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: amountMaxA,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance || amountMaxB.eq(ZERO) ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: amountMaxB,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        ownerTokenAccountA !== void 0 && ownerTokenAccountB !== void 0,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeOpenPositionInstructions = yield this.makeOpenPositionFromLiquidityInstructions({
        poolInfo,
        ownerInfo: __spreadProps(__spreadValues({}, ownerInfo), {
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        }),
        tickLower,
        tickUpper,
        liquidity,
        amountMaxA,
        amountMaxB,
        withMetadata,
        getEphemeralSigners
      });
      return {
        address: makeOpenPositionInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeOpenPositionInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeOpenPositionFromBaseInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      tickLower,
      tickUpper,
      base,
      baseAmount,
      otherAmountMax,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      withMetadata = "create",
      makeTxVersion,
      lookupTableCache,
      getEphemeralSigners
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: base === "MintA" ? baseAmount : otherAmountMax,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: base === "MintA" ? otherAmountMax : baseAmount,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        ownerTokenAccountA !== void 0 && ownerTokenAccountB !== void 0,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeOpenPositionInstructions = yield this.makeOpenPositionFromBaseInstructions({
        poolInfo,
        ownerInfo: __spreadProps(__spreadValues({}, ownerInfo), {
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        }),
        tickLower,
        tickUpper,
        base,
        baseAmount,
        otherAmountMax,
        withMetadata,
        getEphemeralSigners
      });
      return {
        address: makeOpenPositionInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeOpenPositionInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeIncreasePositionFromLiquidityInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerPosition,
      ownerInfo,
      amountMaxA,
      amountMaxB,
      liquidity,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: amountMaxA,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: amountMaxB,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeIncreaseLiquidityInstructions = this.makeIncreasePositionFromLiquidityInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        },
        liquidity,
        amountMaxA,
        amountMaxB
      });
      return {
        address: makeIncreaseLiquidityInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeIncreaseLiquidityInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeIncreasePositionFromBaseInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerPosition,
      ownerInfo,
      base,
      baseAmount,
      otherAmountMax,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: base === "MintA" ? baseAmount : otherAmountMax,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: base === "MintA" ? otherAmountMax : baseAmount,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeIncreaseLiquidityInstructions = this.makeIncreasePositionFromBaseInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        },
        base,
        baseAmount,
        otherAmountMax
      });
      return {
        address: makeIncreaseLiquidityInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeIncreaseLiquidityInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeDecreaseLiquidityInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerPosition,
      ownerInfo,
      liquidity,
      amountMinA,
      amountMinB,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: {
          connection,
          payer: ownerInfo.feePayer,
          amount: 0,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintAUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
          signers
        },
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: {
          connection,
          payer: ownerInfo.feePayer,
          amount: 0,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintBUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
          signers
        },
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const rewardAccounts = [];
      for (const itemReward of poolInfo.rewardInfos) {
        const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.tokenMint.equals(Token.WSOL.mint);
        const ownerRewardAccount = itemReward.tokenMint.equals(poolInfo.mintA.mint) ? ownerTokenAccountA : itemReward.tokenMint.equals(poolInfo.mintB.mint) ? ownerTokenAccountB : yield this._selectOrCreateTokenAccount({
          programId: itemReward.tokenProgramId,
          mint: itemReward.tokenMint,
          tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: rewardUseSOLBalance ? endInstructions : [],
            endInstructionsType: rewardUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        rewardAccounts.push(ownerRewardAccount);
      }
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeDecreaseLiquidityInstructions = this.makeDecreaseLiquidityInstructions({
        poolInfo,
        ownerPosition,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB,
          rewardAccounts
        },
        liquidity,
        amountMinA,
        amountMinB
      });
      const makeClosePositionInstructions = ownerInfo.closePosition ? this.makeClosePositionInstructions({
        poolInfo,
        ownerInfo,
        ownerPosition
      }) : { address: {}, innerTransaction: { instructions: [], signers: [], instructionTypes: [] } };
      return {
        address: makeDecreaseLiquidityInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeDecreaseLiquidityInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] },
            makeClosePositionInstructions.innerTransaction
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSwapBaseInInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      inputMint,
      amountIn,
      amountOutMin,
      priceLimit,
      remainingAccounts,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let sqrtPriceLimitX64;
      if (!priceLimit || priceLimit.equals(new decimal_default2(0))) {
        sqrtPriceLimitX64 = inputMint.equals(poolInfo.mintA.mint) ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
      } else {
        sqrtPriceLimitX64 = SqrtPriceMath.priceToSqrtPriceX64(
          priceLimit,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
      }
      const isInputMintA = poolInfo.mintA.mint.equals(inputMint);
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance || !isInputMintA ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: isInputMintA ? amountIn : 0,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance || isInputMintA ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: isInputMintA ? 0 : amountIn,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeSwapBaseInInstructions = this.makeSwapBaseInInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        },
        inputMint,
        amountIn,
        amountOutMin,
        sqrtPriceLimitX64,
        remainingAccounts
      });
      return {
        address: makeSwapBaseInInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeSwapBaseInInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSwapBaseOutInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      outputMint,
      amountOut,
      amountInMax,
      priceLimit,
      remainingAccounts,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      let sqrtPriceLimitX64;
      if (!priceLimit || priceLimit.equals(new decimal_default2(0))) {
        sqrtPriceLimitX64 = outputMint.equals(poolInfo.mintB.mint) ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
      } else {
        sqrtPriceLimitX64 = SqrtPriceMath.priceToSqrtPriceX64(
          priceLimit,
          poolInfo.mintA.decimals,
          poolInfo.mintB.decimals
        );
      }
      const isInputMintA = poolInfo.mintA.mint.equals(outputMint);
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountA = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintA.programId,
        mint: poolInfo.mintA.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance || !isInputMintA ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: isInputMintA ? amountInMax : 0,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountB = yield this._selectOrCreateTokenAccount({
        programId: poolInfo.mintB.programId,
        mint: poolInfo.mintB.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance || isInputMintA ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: isInputMintA ? 0 : amountInMax,
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(
        !!ownerTokenAccountA || !!ownerTokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        ownerInfo.tokenAccounts
      );
      const makeSwapBaseOutInstructions = this.makeSwapBaseOutInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccountA: ownerTokenAccountA,
          tokenAccountB: ownerTokenAccountB
        },
        outputMint,
        amountOut,
        amountInMax,
        sqrtPriceLimitX64,
        remainingAccounts
      });
      return {
        address: makeSwapBaseOutInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeSwapBaseOutInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCLosePositionInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      poolInfo,
      ownerPosition,
      ownerInfo,
      makeTxVersion,
      lookupTableCache,
      connection
    }) {
      const data = this.makeClosePositionInstructions({ poolInfo, ownerInfo, ownerPosition });
      return {
        address: data.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.feePayer,
          innerTransaction: [data.innerTransaction],
          lookupTableCache
        })
      };
    });
  }
  static makeInitRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardInfo,
      chainTime,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache
    }) {
      logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
      logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token.WSOL.mint);
      const _baseRewardAmount = rewardInfo.perSecond.mul(rewardInfo.endTime - rewardInfo.openTime);
      const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
        programId: rewardInfo.programId,
        mint: rewardInfo.mint,
        tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: rewardMintUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: new import_bn11.default(
            new decimal_default2(_baseRewardAmount.toFixed(0)).gte(_baseRewardAmount) ? _baseRewardAmount.toFixed(0) : _baseRewardAmount.add(1).toFixed(0)
          ),
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
      const makeInitRewardInstructions = this.makeInitRewardInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccount: ownerRewardAccount
        },
        rewardInfo: {
          programId: rewardInfo.programId,
          mint: rewardInfo.mint,
          openTime: rewardInfo.openTime,
          endTime: rewardInfo.endTime,
          emissionsPerSecondX64: MathUtil.decimalToX64(rewardInfo.perSecond)
        }
      });
      return {
        address: makeInitRewardInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeInitRewardInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeInitRewardsInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardInfos,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      for (const rewardInfo of rewardInfos)
        logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const makeInitRewardInstructions = [];
      const signers = [];
      for (const rewardInfo of rewardInfos) {
        const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token.WSOL.mint);
        const _baseRewardAmount = rewardInfo.perSecond.mul(rewardInfo.endTime - rewardInfo.openTime);
        const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
          programId: rewardInfo.programId,
          mint: rewardInfo.mint,
          tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: rewardMintUseSOLBalance ? {
            connection,
            payer: ownerInfo.feePayer,
            amount: new import_bn11.default(
              new decimal_default2(_baseRewardAmount.toFixed(0)).gte(_baseRewardAmount) ? _baseRewardAmount.toFixed(0) : _baseRewardAmount.add(1).toFixed(0)
            ),
            frontInstructions,
            endInstructions,
            frontInstructionsType,
            endInstructionsType,
            signers
          } : void 0,
          associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
        makeInitRewardInstructions.push(
          this.makeInitRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardInfo: {
              programId: rewardInfo.programId,
              mint: rewardInfo.mint,
              openTime: rewardInfo.openTime,
              endTime: rewardInfo.endTime,
              emissionsPerSecondX64: MathUtil.decimalToX64(rewardInfo.perSecond)
            }
          })
        );
      }
      let address = {};
      for (const item of makeInitRewardInstructions) {
        address = __spreadValues(__spreadValues({}, address), item.address);
      }
      return {
        address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...makeInitRewardInstructions.map((i) => i.innerTransaction),
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSetRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardInfo,
      chainTime,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache
    }) {
      logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
      logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token.WSOL.mint);
      const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
        programId: rewardInfo.programId,
        mint: rewardInfo.mint,
        tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: rewardMintUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: new import_bn11.default(
            new decimal_default2(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(
              rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)
            ) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)
          ),
          frontInstructions,
          endInstructions,
          frontInstructionsType,
          endInstructionsType,
          signers
        } : void 0,
        associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
      const makeSetRewardInstructions = this.makeSetRewardInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccount: ownerRewardAccount
        },
        rewardInfo: {
          mint: rewardInfo.mint,
          openTime: rewardInfo.openTime,
          endTime: rewardInfo.endTime,
          emissionsPerSecondX64: MathUtil.decimalToX64(rewardInfo.perSecond)
        }
      });
      return {
        address: makeSetRewardInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeSetRewardInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSetRewardsInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardInfos,
      chainTime,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const makeSetRewardInstructions = [];
      const signers = [];
      for (const rewardInfo of rewardInfos) {
        logger9.assertArgument(rewardInfo.endTime > rewardInfo.openTime, "reward time error", "rewardInfo", rewardInfo);
        logger9.assertArgument(rewardInfo.openTime > chainTime, "reward must be paid later", "rewardInfo", rewardInfo);
        const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardInfo.mint.equals(Token.WSOL.mint);
        const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
          programId: rewardInfo.programId,
          mint: rewardInfo.mint,
          tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: rewardMintUseSOLBalance ? {
            connection,
            payer: ownerInfo.feePayer,
            amount: new import_bn11.default(
              new decimal_default2(rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0)).gte(
                rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime)
              ) ? rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).toFixed(0) : rewardInfo.perSecond.sub(rewardInfo.endTime - rewardInfo.openTime).add(1).toFixed(0)
            ),
            frontInstructions,
            endInstructions,
            frontInstructionsType,
            endInstructionsType,
            signers
          } : void 0,
          associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
        makeSetRewardInstructions.push(
          this.makeSetRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardInfo: {
              mint: rewardInfo.mint,
              openTime: rewardInfo.openTime,
              endTime: rewardInfo.endTime,
              emissionsPerSecondX64: MathUtil.decimalToX64(rewardInfo.perSecond)
            }
          })
        );
      }
      let address = {};
      for (const item of makeSetRewardInstructions) {
        address = __spreadValues(__spreadValues({}, address), item.address);
      }
      return {
        address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...makeSetRewardInstructions.map((i) => i.innerTransaction),
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCollectRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardMint,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const rewardInfo = poolInfo.rewardInfos.find((i) => i.tokenMint.equals(rewardMint));
      logger9.assertArgument(rewardInfo !== void 0, "reward mint error", "not found reward mint", rewardMint);
      if (rewardInfo === void 0) throw Error("reward mint error");
      const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardMint.equals(Token.WSOL.mint);
      const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
        programId: rewardInfo.tokenProgramId,
        mint: rewardMint,
        tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: {
          connection,
          payer: ownerInfo.feePayer,
          amount: 0,
          frontInstructions,
          endInstructions: rewardMintUseSOLBalance ? endInstructions : [],
          frontInstructionsType,
          endInstructionsType,
          signers
        },
        associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
      const makeCollectRewardInstructions = this.makeCollectRewardInstructions({
        poolInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          tokenAccount: ownerRewardAccount
        },
        rewardMint
      });
      return {
        address: makeCollectRewardInstructions.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            makeCollectRewardInstructions.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCollectRewardsInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      rewardMints,
      associatedOnly = true,
      checkCreateATAOwner = false,
      computeBudgetConfig,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const makeCollectRewardInstructions = [];
      const signers = [];
      for (const rewardMint of rewardMints) {
        const rewardInfo = poolInfo.rewardInfos.find((i) => i.tokenMint.equals(rewardMint));
        logger9.assertArgument(rewardInfo !== void 0, "reward mint error", "not found reward mint", rewardMint);
        if (rewardInfo === void 0) throw Error("reward mint error");
        const rewardMintUseSOLBalance = ownerInfo.useSOLBalance && rewardMint.equals(Token.WSOL.mint);
        const ownerRewardAccount = yield this._selectOrCreateTokenAccount({
          programId: rewardInfo.tokenProgramId,
          mint: rewardMint,
          tokenAccounts: rewardMintUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            endInstructions: rewardMintUseSOLBalance ? endInstructions : [],
            signers,
            frontInstructionsType,
            endInstructionsType
          },
          associatedOnly: rewardMintUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        logger9.assertArgument(ownerRewardAccount, "no money", "ownerRewardAccount", ownerInfo.tokenAccounts);
        makeCollectRewardInstructions.push(
          this.makeCollectRewardInstructions({
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              tokenAccount: ownerRewardAccount
            },
            rewardMint
          })
        );
      }
      let address = {};
      for (const item of makeCollectRewardInstructions) {
        address = __spreadValues(__spreadValues({}, address), item.address);
      }
      return {
        address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...makeCollectRewardInstructions.map((i) => i.innerTransaction),
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeHarvestAllRewardInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      fetchPoolInfos,
      ownerInfo,
      associatedOnly = true,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache
    }) {
      var _a, _b, _c;
      const ownerMintToAccount = {};
      for (const item of ownerInfo.tokenAccounts) {
        if (associatedOnly) {
          const ata = getATAAddress(ownerInfo.wallet, item.accountInfo.mint, item.programId).publicKey;
          if (ata.equals(item.pubkey)) ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        } else {
          ownerMintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const makeDecreaseLiquidityInstructions = [];
      const signers = [];
      for (const itemInfo of Object.values(fetchPoolInfos)) {
        if (itemInfo.positionAccount === void 0) continue;
        if (!itemInfo.positionAccount.find(
          (i) => !i.tokenFeeAmountA.isZero() || !i.tokenFeeAmountB.isZero() || i.rewardInfos.find((ii) => !ii.pendingReward.isZero())
        ))
          continue;
        const poolInfo = itemInfo.state;
        const mintAUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintA.mint.equals(Token.WSOL.mint);
        const mintBUseSOLBalance = ownerInfo.useSOLBalance && poolInfo.mintB.mint.equals(Token.WSOL.mint);
        const ownerTokenAccountA = (_a = ownerMintToAccount[poolInfo.mintA.mint.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
          programId: poolInfo.mintA.programId,
          mint: poolInfo.mintA.mint,
          tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: mintAUseSOLBalance ? endInstructions : [],
            endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        const ownerTokenAccountB = (_b = ownerMintToAccount[poolInfo.mintB.mint.toString()]) != null ? _b : yield this._selectOrCreateTokenAccount({
          programId: poolInfo.mintB.programId,
          mint: poolInfo.mintB.mint,
          tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
          owner: ownerInfo.wallet,
          createInfo: {
            connection,
            payer: ownerInfo.feePayer,
            amount: 0,
            frontInstructions,
            frontInstructionsType,
            endInstructions: mintBUseSOLBalance ? endInstructions : [],
            endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
            signers
          },
          associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
          checkCreateATAOwner
        });
        ownerMintToAccount[poolInfo.mintA.mint.toString()] = ownerTokenAccountA;
        ownerMintToAccount[poolInfo.mintB.mint.toString()] = ownerTokenAccountB;
        const rewardAccounts = [];
        for (const itemReward of poolInfo.rewardInfos) {
          const rewardUseSOLBalance = ownerInfo.useSOLBalance && itemReward.tokenMint.equals(Token.WSOL.mint);
          const ownerRewardAccount = (_c = ownerMintToAccount[itemReward.tokenMint.toString()]) != null ? _c : yield this._selectOrCreateTokenAccount({
            programId: itemReward.tokenProgramId,
            mint: itemReward.tokenMint,
            tokenAccounts: rewardUseSOLBalance ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.feePayer,
              amount: 0,
              frontInstructions,
              endInstructions: rewardUseSOLBalance ? endInstructions : [],
              frontInstructionsType,
              endInstructionsType,
              signers
            },
            associatedOnly: rewardUseSOLBalance ? false : associatedOnly,
            checkCreateATAOwner
          });
          ownerMintToAccount[itemReward.tokenMint.toString()] = ownerRewardAccount;
          rewardAccounts.push(ownerRewardAccount);
        }
        for (const itemPosition of itemInfo.positionAccount) {
          makeDecreaseLiquidityInstructions.push(
            this.makeDecreaseLiquidityInstructions({
              poolInfo,
              ownerPosition: itemPosition,
              ownerInfo: {
                wallet: ownerInfo.wallet,
                tokenAccountA: ownerTokenAccountA,
                tokenAccountB: ownerTokenAccountB,
                rewardAccounts
              },
              liquidity: ZERO,
              amountMinA: ZERO,
              amountMinB: ZERO
            })
          );
        }
      }
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...makeDecreaseLiquidityInstructions.map((i) => i.innerTransaction),
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  // instrument
  static makeCreatePoolInstructions(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      owner,
      mintA,
      mintB,
      ammConfigId,
      initialPriceX64,
      startTime
    }) {
      const observationId = generatePubKey({ fromPublicKey: owner, programId });
      const poolId = getPdaPoolId(programId, ammConfigId, mintA.mint, mintB.mint).publicKey;
      const mintAVault = getPdaPoolVaultId(programId, poolId, mintA.mint).publicKey;
      const mintBVault = getPdaPoolVaultId(programId, poolId, mintB.mint).publicKey;
      const instructions = [
        SystemProgram.createAccountWithSeed({
          fromPubkey: owner,
          basePubkey: owner,
          seed: observationId.seed,
          newAccountPubkey: observationId.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption(ObservationInfoLayout.span),
          space: ObservationInfoLayout.span,
          programId
        }),
        createPoolInstruction(
          programId,
          poolId,
          owner,
          ammConfigId,
          observationId.publicKey,
          mintA.mint,
          mintAVault,
          mintA.programId,
          mintB.mint,
          mintBVault,
          mintB.programId,
          getPdaExBitmapAccount(programId, poolId).publicKey,
          initialPriceX64,
          startTime
        )
      ];
      return {
        address: {
          observationId: observationId.publicKey,
          poolId,
          mintAVault,
          mintBVault
        },
        innerTransaction: {
          instructions,
          signers: [],
          instructionTypes: [
            0,
            11
            /* clmmCreatePool */
          ],
          lookupTableAddress: []
        }
      };
    });
  }
  static makeOpenPositionFromLiquidityInstructions(_0) {
    return __async(this, arguments, function* ({
      poolInfo,
      ownerInfo,
      tickLower,
      tickUpper,
      liquidity,
      amountMaxA,
      amountMaxB,
      withMetadata,
      getEphemeralSigners
    }) {
      const signers = [];
      let nftMintAccount;
      if (getEphemeralSigners) {
        nftMintAccount = new PublicKey((yield getEphemeralSigners(1))[0]);
      } else {
        const _k = Keypair.generate();
        signers.push(_k);
        nftMintAccount = _k.publicKey;
      }
      const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(tickLower, poolInfo.ammConfig.tickSpacing);
      const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(tickUpper, poolInfo.ammConfig.tickSpacing);
      const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
        poolInfo.programId,
        poolInfo.id,
        tickArrayLowerStartIndex
      );
      const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
        poolInfo.programId,
        poolInfo.id,
        tickArrayUpperStartIndex
      );
      const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, nftMintAccount, TOKEN_PROGRAM_ID);
      const { publicKey: metadataAccount } = getPdaMetadataKey(nftMintAccount);
      const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, nftMintAccount);
      const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
        poolInfo.programId,
        poolInfo.id,
        tickLower,
        tickUpper
      );
      const ins = openPositionFromLiquidityInstruction(
        poolInfo.programId,
        ownerInfo.feePayer,
        poolInfo.id,
        ownerInfo.wallet,
        nftMintAccount,
        positionNftAccount,
        metadataAccount,
        protocolPosition,
        tickArrayLower,
        tickArrayUpper,
        personalPosition,
        ownerInfo.tokenAccountA,
        ownerInfo.tokenAccountB,
        poolInfo.mintA.vault,
        poolInfo.mintB.vault,
        poolInfo.mintA.mint,
        poolInfo.mintB.mint,
        tickLower,
        tickUpper,
        tickArrayLowerStartIndex,
        tickArrayUpperStartIndex,
        liquidity,
        amountMaxA,
        amountMaxB,
        withMetadata,
        PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
          tickArrayLowerStartIndex,
          tickArrayUpperStartIndex
        ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
      );
      return {
        address: {
          nftMint: nftMintAccount,
          tickArrayLower,
          tickArrayUpper,
          positionNftAccount,
          metadataAccount,
          personalPosition,
          protocolPosition
        },
        innerTransaction: {
          instructions: [ins],
          signers,
          instructionTypes: [
            12
            /* clmmOpenPosition */
          ],
          lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
        }
      };
    });
  }
  static makeOpenPositionFromBaseInstructions(_0) {
    return __async(this, arguments, function* ({
      poolInfo,
      ownerInfo,
      tickLower,
      tickUpper,
      base,
      baseAmount,
      otherAmountMax,
      withMetadata,
      getEphemeralSigners
    }) {
      const signers = [];
      let nftMintAccount;
      if (getEphemeralSigners) {
        nftMintAccount = new PublicKey((yield getEphemeralSigners(1))[0]);
      } else {
        const _k = Keypair.generate();
        signers.push(_k);
        nftMintAccount = _k.publicKey;
      }
      const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(tickLower, poolInfo.ammConfig.tickSpacing);
      const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(tickUpper, poolInfo.ammConfig.tickSpacing);
      const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
        poolInfo.programId,
        poolInfo.id,
        tickArrayLowerStartIndex
      );
      const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
        poolInfo.programId,
        poolInfo.id,
        tickArrayUpperStartIndex
      );
      const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, nftMintAccount, TOKEN_PROGRAM_ID);
      const { publicKey: metadataAccount } = getPdaMetadataKey(nftMintAccount);
      const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, nftMintAccount);
      const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
        poolInfo.programId,
        poolInfo.id,
        tickLower,
        tickUpper
      );
      const ins = openPositionFromBaseInstruction(
        poolInfo.programId,
        ownerInfo.feePayer,
        poolInfo.id,
        ownerInfo.wallet,
        nftMintAccount,
        positionNftAccount,
        metadataAccount,
        protocolPosition,
        tickArrayLower,
        tickArrayUpper,
        personalPosition,
        ownerInfo.tokenAccountA,
        ownerInfo.tokenAccountB,
        poolInfo.mintA.vault,
        poolInfo.mintB.vault,
        poolInfo.mintA.mint,
        poolInfo.mintB.mint,
        tickLower,
        tickUpper,
        tickArrayLowerStartIndex,
        tickArrayUpperStartIndex,
        withMetadata,
        base,
        baseAmount,
        otherAmountMax,
        PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
          tickArrayLowerStartIndex,
          tickArrayUpperStartIndex
        ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
      );
      return {
        address: {
          nftMint: nftMintAccount,
          tickArrayLower,
          tickArrayUpper,
          positionNftAccount,
          metadataAccount,
          personalPosition,
          protocolPosition
        },
        innerTransaction: {
          instructions: [ins],
          signers,
          instructionTypes: [
            12
            /* clmmOpenPosition */
          ],
          lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
        }
      };
    });
  }
  static makeIncreasePositionFromLiquidityInstructions({
    poolInfo,
    ownerPosition,
    ownerInfo,
    liquidity,
    amountMaxA,
    amountMaxB
  }) {
    const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickLower,
      poolInfo.ammConfig.tickSpacing
    );
    const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickUpper,
      poolInfo.ammConfig.tickSpacing
    );
    const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayLowerStartIndex
    );
    const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayUpperStartIndex
    );
    const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, ownerPosition.nftMint, TOKEN_PROGRAM_ID);
    const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, ownerPosition.nftMint);
    const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
      poolInfo.programId,
      poolInfo.id,
      ownerPosition.tickLower,
      ownerPosition.tickUpper
    );
    return {
      address: {
        tickArrayLower,
        tickArrayUpper,
        positionNftAccount,
        personalPosition,
        protocolPosition
      },
      innerTransaction: {
        instructions: [
          increasePositionFromLiquidityInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            positionNftAccount,
            personalPosition,
            poolInfo.id,
            protocolPosition,
            tickArrayLower,
            tickArrayUpper,
            ownerInfo.tokenAccountA,
            ownerInfo.tokenAccountB,
            poolInfo.mintA.vault,
            poolInfo.mintB.vault,
            poolInfo.mintA.mint,
            poolInfo.mintB.mint,
            liquidity,
            amountMaxA,
            amountMaxB,
            PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
              tickArrayLowerStartIndex,
              tickArrayUpperStartIndex
            ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
          )
        ],
        signers: [],
        instructionTypes: [
          13
          /* clmmIncreasePosition */
        ],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
      }
    };
  }
  static makeIncreasePositionFromBaseInstructions({
    poolInfo,
    ownerPosition,
    ownerInfo,
    base,
    baseAmount,
    otherAmountMax
  }) {
    const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickLower,
      poolInfo.ammConfig.tickSpacing
    );
    const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickUpper,
      poolInfo.ammConfig.tickSpacing
    );
    const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayLowerStartIndex
    );
    const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayUpperStartIndex
    );
    const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, ownerPosition.nftMint, TOKEN_PROGRAM_ID);
    const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, ownerPosition.nftMint);
    const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
      poolInfo.programId,
      poolInfo.id,
      ownerPosition.tickLower,
      ownerPosition.tickUpper
    );
    return {
      address: {
        tickArrayLower,
        tickArrayUpper,
        positionNftAccount,
        personalPosition,
        protocolPosition
      },
      innerTransaction: {
        instructions: [
          increasePositionFromBaseInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            positionNftAccount,
            personalPosition,
            poolInfo.id,
            protocolPosition,
            tickArrayLower,
            tickArrayUpper,
            ownerInfo.tokenAccountA,
            ownerInfo.tokenAccountB,
            poolInfo.mintA.vault,
            poolInfo.mintB.vault,
            poolInfo.mintA.mint,
            poolInfo.mintB.mint,
            base,
            baseAmount,
            otherAmountMax,
            PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
              tickArrayLowerStartIndex,
              tickArrayUpperStartIndex
            ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
          )
        ],
        signers: [],
        instructionTypes: [
          13
          /* clmmIncreasePosition */
        ],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
      }
    };
  }
  static makeDecreaseLiquidityInstructions({
    poolInfo,
    ownerPosition,
    ownerInfo,
    liquidity,
    amountMinA,
    amountMinB
  }) {
    const tickArrayLowerStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickLower,
      poolInfo.ammConfig.tickSpacing
    );
    const tickArrayUpperStartIndex = TickUtils.getTickArrayStartIndexByTick(
      ownerPosition.tickUpper,
      poolInfo.ammConfig.tickSpacing
    );
    const { publicKey: tickArrayLower } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayLowerStartIndex
    );
    const { publicKey: tickArrayUpper } = getPdaTickArrayAddress(
      poolInfo.programId,
      poolInfo.id,
      tickArrayUpperStartIndex
    );
    const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, ownerPosition.nftMint, TOKEN_PROGRAM_ID);
    const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, ownerPosition.nftMint);
    const { publicKey: protocolPosition } = getPdaProtocolPositionAddress(
      poolInfo.programId,
      poolInfo.id,
      ownerPosition.tickLower,
      ownerPosition.tickUpper
    );
    const rewardAccounts = [];
    for (let i = 0; i < poolInfo.rewardInfos.length; i++) {
      rewardAccounts.push({
        poolRewardVault: poolInfo.rewardInfos[i].tokenVault,
        ownerRewardVault: ownerInfo.rewardAccounts[i],
        rewardMint: poolInfo.rewardInfos[i].tokenMint
      });
    }
    return {
      address: {
        tickArrayLower,
        tickArrayUpper,
        positionNftAccount,
        personalPosition,
        protocolPosition
      },
      innerTransaction: {
        instructions: [
          decreaseLiquidityInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            positionNftAccount,
            personalPosition,
            poolInfo.id,
            protocolPosition,
            tickArrayLower,
            tickArrayUpper,
            ownerInfo.tokenAccountA,
            ownerInfo.tokenAccountB,
            poolInfo.mintA.vault,
            poolInfo.mintB.vault,
            poolInfo.mintA.mint,
            poolInfo.mintB.mint,
            rewardAccounts,
            liquidity,
            amountMinA,
            amountMinB,
            PoolUtils.isOverflowDefaultTickarrayBitmap(poolInfo.tickSpacing, [
              tickArrayLowerStartIndex,
              tickArrayUpperStartIndex
            ]) ? getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey : void 0
          )
        ],
        signers: [],
        instructionTypes: [
          14
          /* clmmDecreasePosition */
        ],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
      }
    };
  }
  static makeClosePositionInstructions({
    poolInfo,
    ownerInfo,
    ownerPosition
  }) {
    const { publicKey: positionNftAccount } = getATAAddress(ownerInfo.wallet, ownerPosition.nftMint, TOKEN_PROGRAM_ID);
    const { publicKey: personalPosition } = getPdaPersonalPositionAddress(poolInfo.programId, ownerPosition.nftMint);
    return {
      address: {
        positionNftAccount,
        personalPosition
      },
      innerTransaction: {
        instructions: [
          closePositionInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            ownerPosition.nftMint,
            positionNftAccount,
            personalPosition
          )
        ],
        signers: [],
        instructionTypes: [
          15
          /* clmmClosePosition */
        ],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
      }
    };
  }
  static makeSwapBaseInInstructions({
    poolInfo,
    ownerInfo,
    inputMint,
    amountIn,
    amountOutMin,
    sqrtPriceLimitX64,
    remainingAccounts
  }) {
    const isInputMintA = poolInfo.mintA.mint.equals(inputMint);
    return {
      address: {},
      innerTransaction: {
        instructions: [
          swapInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            poolInfo.ammConfig.id,
            isInputMintA ? ownerInfo.tokenAccountA : ownerInfo.tokenAccountB,
            isInputMintA ? ownerInfo.tokenAccountB : ownerInfo.tokenAccountA,
            isInputMintA ? poolInfo.mintA.vault : poolInfo.mintB.vault,
            isInputMintA ? poolInfo.mintB.vault : poolInfo.mintA.vault,
            isInputMintA ? poolInfo.mintA.mint : poolInfo.mintB.mint,
            isInputMintA ? poolInfo.mintB.mint : poolInfo.mintA.mint,
            remainingAccounts,
            poolInfo.observationId,
            amountIn,
            amountOutMin,
            sqrtPriceLimitX64,
            true,
            getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey
          )
        ],
        signers: [],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default)),
        instructionTypes: [
          16
          /* clmmSwapBaseIn */
        ]
      }
    };
  }
  static makeSwapBaseOutInstructions({
    poolInfo,
    ownerInfo,
    outputMint,
    amountOut,
    amountInMax,
    sqrtPriceLimitX64,
    remainingAccounts
  }) {
    const isInputMintA = poolInfo.mintA.mint.equals(outputMint);
    return {
      address: {},
      innerTransaction: {
        instructions: [
          swapInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            poolInfo.ammConfig.id,
            isInputMintA ? ownerInfo.tokenAccountB : ownerInfo.tokenAccountA,
            isInputMintA ? ownerInfo.tokenAccountA : ownerInfo.tokenAccountB,
            isInputMintA ? poolInfo.mintB.vault : poolInfo.mintA.vault,
            isInputMintA ? poolInfo.mintA.vault : poolInfo.mintB.vault,
            isInputMintA ? poolInfo.mintB.mint : poolInfo.mintA.mint,
            isInputMintA ? poolInfo.mintA.mint : poolInfo.mintB.mint,
            remainingAccounts,
            poolInfo.observationId,
            amountOut,
            amountInMax,
            sqrtPriceLimitX64,
            false,
            getPdaExBitmapAccount(poolInfo.programId, poolInfo.id).publicKey
          )
        ],
        signers: [],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default)),
        instructionTypes: [
          17
          /* clmmSwapBaseOut */
        ]
      }
    };
  }
  static makeInitRewardInstructions({
    poolInfo,
    ownerInfo,
    rewardInfo
  }) {
    const poolRewardVault = getPdaPoolRewardVaulId(poolInfo.programId, poolInfo.id, rewardInfo.mint).publicKey;
    const operationId = getPdaOperationAccount(poolInfo.programId).publicKey;
    return {
      address: { poolRewardVault, operationId },
      innerTransaction: {
        instructions: [
          initRewardInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            operationId,
            poolInfo.ammConfig.id,
            ownerInfo.tokenAccount,
            rewardInfo.programId,
            rewardInfo.mint,
            poolRewardVault,
            rewardInfo.openTime,
            rewardInfo.endTime,
            rewardInfo.emissionsPerSecondX64
          )
        ],
        signers: [],
        instructionTypes: [
          18
          /* clmmInitReward */
        ],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
      }
    };
  }
  static makeSetRewardInstructions({
    poolInfo,
    ownerInfo,
    rewardInfo
  }) {
    let rewardIndex;
    let rewardVault;
    let rewardMint;
    for (let index = 0; index < poolInfo.rewardInfos.length; index++)
      if (poolInfo.rewardInfos[index].tokenMint.equals(rewardInfo.mint)) {
        rewardIndex = index;
        rewardVault = poolInfo.rewardInfos[index].tokenVault;
        rewardMint = poolInfo.rewardInfos[index].tokenMint;
      }
    if (rewardIndex === void 0 || rewardVault === void 0 || rewardMint === void 0)
      throw Error("reward mint check error");
    const operationId = getPdaOperationAccount(poolInfo.programId).publicKey;
    return {
      address: { rewardVault, operationId },
      innerTransaction: {
        instructions: [
          setRewardInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            operationId,
            poolInfo.ammConfig.id,
            ownerInfo.tokenAccount,
            rewardVault,
            rewardMint,
            rewardIndex,
            rewardInfo.openTime,
            rewardInfo.endTime,
            rewardInfo.emissionsPerSecondX64
          )
        ],
        signers: [],
        instructionTypes: [
          18
          /* clmmInitReward */
        ],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
      }
    };
  }
  static makeCollectRewardInstructions({
    poolInfo,
    ownerInfo,
    rewardMint
  }) {
    let rewardIndex;
    let rewardVault;
    for (let index = 0; index < poolInfo.rewardInfos.length; index++)
      if (poolInfo.rewardInfos[index].tokenMint.equals(rewardMint)) {
        rewardIndex = index;
        rewardVault = poolInfo.rewardInfos[index].tokenVault;
      }
    if (rewardIndex === void 0 || rewardVault === void 0) throw Error("reward mint check error");
    return {
      address: { rewardVault },
      innerTransaction: {
        instructions: [
          collectRewardInstruction(
            poolInfo.programId,
            ownerInfo.wallet,
            poolInfo.id,
            ownerInfo.tokenAccount,
            rewardVault,
            rewardMint,
            rewardIndex
          )
        ],
        signers: [],
        instructionTypes: [
          18
          /* clmmInitReward */
        ],
        lookupTableAddress: [poolInfo.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default))
      }
    };
  }
  // calculate
  static getLiquidityAmountOutFromAmountIn({
    poolInfo,
    inputA,
    tickLower,
    tickUpper,
    amount,
    slippage,
    add: add2,
    token2022Infos,
    epochInfo,
    amountHasFee
  }) {
    var _a, _b;
    const sqrtPriceX64 = poolInfo.sqrtPriceX64;
    const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(tickLower);
    const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(tickUpper);
    const coefficient = add2 ? 1 - slippage : 1 + slippage;
    const addFeeAmount = getTransferAmountFee(
      amount,
      (_a = token2022Infos[inputA ? poolInfo.mintA.mint.toString() : poolInfo.mintB.mint.toString()]) == null ? void 0 : _a.feeConfig,
      epochInfo,
      !amountHasFee
    );
    const _amount = new import_bn11.default(
      new decimal_default2(addFeeAmount.amount.sub((_b = addFeeAmount.fee) != null ? _b : ZERO).toString()).mul(coefficient).toFixed(0)
    );
    let liquidity;
    if (sqrtPriceX64.lte(sqrtPriceX64A)) {
      liquidity = inputA ? LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64A, sqrtPriceX64B, _amount, !add2) : new import_bn11.default(0);
    } else if (sqrtPriceX64.lte(sqrtPriceX64B)) {
      const liquidity0 = LiquidityMath.getLiquidityFromTokenAmountA(sqrtPriceX64, sqrtPriceX64B, _amount, !add2);
      const liquidity1 = LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64, _amount);
      liquidity = inputA ? liquidity0 : liquidity1;
    } else {
      liquidity = inputA ? new import_bn11.default(0) : LiquidityMath.getLiquidityFromTokenAmountB(sqrtPriceX64A, sqrtPriceX64B, _amount);
    }
    return this.getAmountsFromLiquidity({
      poolInfo,
      tickLower,
      tickUpper,
      liquidity,
      slippage,
      add: add2,
      token2022Infos,
      epochInfo,
      amountAddFee: amountHasFee
    });
  }
  static getLiquidityFromAmounts({
    poolInfo,
    tickLower,
    tickUpper,
    amountA,
    amountB,
    slippage,
    add: add2,
    token2022Infos,
    epochInfo,
    amountHasFee
  }) {
    var _a, _b, _c, _d;
    const [_tickLower, _tickUpper, _amountA, _amountB] = tickLower < tickUpper ? [tickLower, tickUpper, amountA, amountB] : [tickUpper, tickLower, amountB, amountA];
    const sqrtPriceX64 = poolInfo.sqrtPriceX64;
    const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(_tickLower);
    const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(_tickUpper);
    const [amountFeeA, amountFeeB] = [
      getTransferAmountFee(
        _amountA,
        (_a = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _a.feeConfig,
        epochInfo,
        !amountHasFee
      ),
      getTransferAmountFee(
        _amountB,
        (_b = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _b.feeConfig,
        epochInfo,
        !amountHasFee
      )
    ];
    const liquidity = LiquidityMath.getLiquidityFromTokenAmounts(
      sqrtPriceX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      amountFeeA.amount.sub((_c = amountFeeA.fee) != null ? _c : ZERO),
      amountFeeB.amount.sub((_d = amountFeeB.fee) != null ? _d : ZERO)
    );
    return this.getAmountsFromLiquidity({
      poolInfo,
      tickLower,
      tickUpper,
      liquidity,
      slippage,
      add: add2,
      token2022Infos,
      epochInfo,
      amountAddFee: !amountHasFee
    });
  }
  static getAmountsFromLiquidity({
    poolInfo,
    tickLower,
    tickUpper,
    liquidity,
    slippage,
    add: add2,
    token2022Infos,
    epochInfo,
    amountAddFee
  }) {
    var _a, _b, _c, _d;
    const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(tickLower);
    const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(tickUpper);
    const coefficientRe = add2 ? 1 + slippage : 1 - slippage;
    const amounts = LiquidityMath.getAmountsFromLiquidity(
      poolInfo.sqrtPriceX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      liquidity,
      add2
    );
    const [amountA, amountB] = [
      getTransferAmountFee(
        amounts.amountA,
        (_a = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _a.feeConfig,
        epochInfo,
        amountAddFee
      ),
      getTransferAmountFee(
        amounts.amountB,
        (_b = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _b.feeConfig,
        epochInfo,
        amountAddFee
      )
    ];
    const [amountSlippageA, amountSlippageB] = [
      getTransferAmountFee(
        new import_bn11.default(new decimal_default2(amounts.amountA.toString()).mul(coefficientRe).toFixed(0)),
        (_c = token2022Infos[poolInfo.mintA.mint.toString()]) == null ? void 0 : _c.feeConfig,
        epochInfo,
        amountAddFee
      ),
      getTransferAmountFee(
        new import_bn11.default(new decimal_default2(amounts.amountB.toString()).mul(coefficientRe).toFixed(0)),
        (_d = token2022Infos[poolInfo.mintB.mint.toString()]) == null ? void 0 : _d.feeConfig,
        epochInfo,
        amountAddFee
      )
    ];
    return {
      liquidity,
      amountA,
      amountB,
      amountSlippageA,
      amountSlippageB,
      expirationTime: minExpirationTime(amountA.expirationTime, amountB.expirationTime)
    };
  }
  static getPriceAndTick({
    poolInfo,
    price,
    baseIn
  }) {
    const _price = baseIn ? price : new decimal_default2(1).div(price);
    const tick = TickMath.getTickWithPriceAndTickspacing(
      _price,
      poolInfo.ammConfig.tickSpacing,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    const tickSqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    const tickPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      tickSqrtPriceX64,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    return baseIn ? { tick, price: tickPrice } : { tick, price: new decimal_default2(1).div(tickPrice) };
  }
  static getTickPrice({
    poolInfo,
    tick,
    baseIn
  }) {
    const tickSqrtPriceX64 = SqrtPriceMath.getSqrtPriceX64FromTick(tick);
    const tickPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      tickSqrtPriceX64,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    return baseIn ? { tick, price: tickPrice, tickSqrtPriceX64 } : { tick, price: new decimal_default2(1).div(tickPrice), tickSqrtPriceX64 };
  }
  static computeAmountOutFormat({
    poolInfo,
    tickArrayCache,
    token2022Infos,
    epochInfo,
    amountIn,
    currencyOut,
    slippage,
    catchLiquidityInsufficient = false
  }) {
    const amountInIsTokenAmount = amountIn instanceof TokenAmount;
    const inputMint = (amountInIsTokenAmount ? amountIn.token : Token.WSOL).mint;
    const _amountIn = amountIn.raw;
    const _slippage = slippage.numerator.toNumber() / slippage.denominator.toNumber();
    const {
      allTrade,
      realAmountIn: _realAmountIn,
      amountOut: _amountOut,
      minAmountOut: _minAmountOut,
      expirationTime,
      currentPrice,
      executionPrice,
      priceImpact,
      fee,
      remainingAccounts,
      executionPriceX64
    } = this.computeAmountOut({
      poolInfo,
      tickArrayCache,
      baseMint: inputMint,
      amountIn: _amountIn,
      slippage: _slippage,
      token2022Infos,
      epochInfo,
      catchLiquidityInsufficient
    });
    const realAmountIn = __spreadProps(__spreadValues({}, _realAmountIn), {
      amount: amountInIsTokenAmount ? new TokenAmount(amountIn.token, _realAmountIn.amount) : new CurrencyAmount(Currency.SOL, _realAmountIn.amount),
      fee: _realAmountIn.fee === void 0 ? void 0 : amountInIsTokenAmount ? new TokenAmount(amountIn.token, _realAmountIn.fee) : new CurrencyAmount(Currency.SOL, _realAmountIn.fee)
    });
    const amountOut = __spreadProps(__spreadValues({}, _amountOut), {
      amount: currencyOut instanceof Token ? new TokenAmount(currencyOut, _amountOut.amount) : new CurrencyAmount(currencyOut, _amountOut.amount),
      fee: _amountOut.fee === void 0 ? void 0 : currencyOut instanceof Token ? new TokenAmount(currencyOut, _amountOut.fee) : new CurrencyAmount(currencyOut, _amountOut.fee)
    });
    const minAmountOut = __spreadProps(__spreadValues({}, _minAmountOut), {
      amount: currencyOut instanceof Token ? new TokenAmount(currencyOut, _minAmountOut.amount) : new CurrencyAmount(currencyOut, _minAmountOut.amount),
      fee: _minAmountOut.fee === void 0 ? void 0 : currencyOut instanceof Token ? new TokenAmount(currencyOut, _minAmountOut.fee) : new CurrencyAmount(currencyOut, _minAmountOut.fee)
    });
    const _currentPrice = new Price(
      amountInIsTokenAmount ? amountIn.token : amountIn.currency,
      new import_bn11.default(10).pow(new import_bn11.default(20 + (amountInIsTokenAmount ? amountIn.token : amountIn.currency).decimals)),
      currencyOut instanceof Token ? currencyOut : Token.WSOL,
      currentPrice.mul(new decimal_default2(__pow(10, 20 + (currencyOut instanceof Token ? currencyOut : Token.WSOL).decimals))).toFixed(0)
    );
    const _executionPrice = new Price(
      amountInIsTokenAmount ? amountIn.token : amountIn.currency,
      new import_bn11.default(10).pow(new import_bn11.default(20 + (amountInIsTokenAmount ? amountIn.token : amountIn.currency).decimals)),
      currencyOut instanceof Token ? currencyOut : Token.WSOL,
      executionPrice.mul(new decimal_default2(__pow(10, 20 + (currencyOut instanceof Token ? currencyOut : Token.WSOL).decimals))).toFixed(0)
    );
    const _fee = amountInIsTokenAmount ? new TokenAmount(amountIn.token, fee) : new CurrencyAmount(amountIn.currency, fee);
    return {
      allTrade,
      realAmountIn,
      amountOut,
      minAmountOut,
      expirationTime,
      currentPrice: _currentPrice,
      executionPrice: _executionPrice,
      priceImpact,
      fee: _fee,
      remainingAccounts,
      executionPriceX64
    };
  }
  static computeAmountOutAndCheckToken(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      tickArrayCache,
      baseMint,
      amountIn,
      slippage,
      priceLimit = new decimal_default2(0),
      catchLiquidityInsufficient = false
    }) {
      const epochInfo = yield connection.getEpochInfo();
      const token2022Infos = yield fetchMultipleMintInfos({
        connection,
        mints: [poolInfo.mintA, poolInfo.mintB].filter((i) => i.programId.equals(TOKEN_2022_PROGRAM_ID)).map((i) => i.mint)
      });
      return this.computeAmountOut({
        poolInfo,
        tickArrayCache,
        baseMint,
        amountIn,
        slippage,
        priceLimit,
        token2022Infos,
        epochInfo,
        catchLiquidityInsufficient
      });
    });
  }
  static computeAmountOut({
    poolInfo,
    tickArrayCache,
    baseMint,
    token2022Infos,
    epochInfo,
    amountIn,
    slippage,
    priceLimit = new decimal_default2(0),
    catchLiquidityInsufficient = false
  }) {
    var _a, _b, _c, _d, _e;
    let sqrtPriceLimitX64;
    if (priceLimit.equals(new decimal_default2(0))) {
      sqrtPriceLimitX64 = baseMint.equals(poolInfo.mintA.mint) ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
    } else {
      sqrtPriceLimitX64 = SqrtPriceMath.priceToSqrtPriceX64(
        priceLimit,
        poolInfo.mintA.decimals,
        poolInfo.mintB.decimals
      );
    }
    const _inputRealAmountIn = getTransferAmountFee(
      amountIn,
      (_a = token2022Infos[baseMint.toString()]) == null ? void 0 : _a.feeConfig,
      epochInfo,
      false
    );
    const {
      allTrade,
      realTradeAmountIn,
      expectedAmountOut: _expectedAmountOut,
      remainingAccounts,
      executionPrice: _executionPriceX64,
      feeAmount
    } = PoolUtils.getOutputAmountAndRemainAccounts(
      poolInfo,
      tickArrayCache,
      baseMint,
      _inputRealAmountIn.amount.sub((_b = _inputRealAmountIn.fee) != null ? _b : ZERO),
      sqrtPriceLimitX64,
      catchLiquidityInsufficient
    );
    const realAmountIn = getTransferAmountFee(
      realTradeAmountIn,
      (_c = token2022Infos[baseMint.toString()]) == null ? void 0 : _c.feeConfig,
      epochInfo,
      true
    );
    const outMint = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.mintB.mint : poolInfo.mintA.mint;
    const amountOut = getTransferAmountFee(
      _expectedAmountOut,
      (_d = token2022Infos[outMint.toString()]) == null ? void 0 : _d.feeConfig,
      epochInfo,
      false
    );
    const _executionPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      _executionPriceX64,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    const executionPrice = baseMint.equals(poolInfo.mintA.mint) ? _executionPrice : new decimal_default2(1).div(_executionPrice);
    const _minAmountOut = _expectedAmountOut.mul(new import_bn11.default(Math.floor((1 - slippage) * 1e10))).div(new import_bn11.default(1e10));
    const minAmountOut = getTransferAmountFee(
      _minAmountOut,
      (_e = token2022Infos[outMint.toString()]) == null ? void 0 : _e.feeConfig,
      epochInfo,
      false
    );
    const poolPrice = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.currentPrice : new decimal_default2(1).div(poolInfo.currentPrice);
    const _numerator = new decimal_default2(executionPrice).sub(poolPrice).abs();
    const _denominator = poolPrice;
    const priceImpact = new Percent(
      new decimal_default2(_numerator).mul(__pow(10, 15)).toFixed(0),
      new decimal_default2(_denominator).mul(__pow(10, 15)).toFixed(0)
    );
    return {
      allTrade,
      realAmountIn,
      amountOut,
      minAmountOut,
      expirationTime: minExpirationTime(realAmountIn.expirationTime, amountOut.expirationTime),
      currentPrice: poolInfo.currentPrice,
      executionPrice,
      priceImpact,
      fee: feeAmount,
      remainingAccounts,
      executionPriceX64: _executionPriceX64
    };
  }
  static computeAmountInAndCheckToken(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      tickArrayCache,
      baseMint,
      amountOut,
      slippage,
      priceLimit = new decimal_default2(0)
    }) {
      const epochInfo = yield connection.getEpochInfo();
      const token2022Infos = yield fetchMultipleMintInfos({
        connection,
        mints: [poolInfo.mintA, poolInfo.mintB].filter((i) => i.programId.equals(TOKEN_2022_PROGRAM_ID)).map((i) => i.mint)
      });
      return this.computeAmountIn({
        poolInfo,
        tickArrayCache,
        baseMint,
        amountOut,
        slippage,
        priceLimit,
        token2022Infos,
        epochInfo
      });
    });
  }
  static computeAmountIn({
    poolInfo,
    tickArrayCache,
    baseMint,
    token2022Infos,
    epochInfo,
    amountOut,
    slippage,
    priceLimit = new decimal_default2(0)
  }) {
    var _a, _b, _c, _d;
    let sqrtPriceLimitX64;
    if (priceLimit.equals(new decimal_default2(0))) {
      sqrtPriceLimitX64 = baseMint.equals(poolInfo.mintB.mint) ? MIN_SQRT_PRICE_X64.add(ONE) : MAX_SQRT_PRICE_X64.sub(ONE);
    } else {
      sqrtPriceLimitX64 = SqrtPriceMath.priceToSqrtPriceX64(
        priceLimit,
        poolInfo.mintA.decimals,
        poolInfo.mintB.decimals
      );
    }
    const realAmountOut = getTransferAmountFee(
      amountOut,
      (_a = token2022Infos[baseMint.toString()]) == null ? void 0 : _a.feeConfig,
      epochInfo,
      true
    );
    const {
      expectedAmountIn: _expectedAmountIn,
      remainingAccounts,
      executionPrice: _executionPriceX64,
      feeAmount
    } = PoolUtils.getInputAmountAndRemainAccounts(
      poolInfo,
      tickArrayCache,
      baseMint,
      realAmountOut.amount.sub((_b = realAmountOut.fee) != null ? _b : ZERO),
      sqrtPriceLimitX64
    );
    const inMint = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.mintB.mint : poolInfo.mintA.mint;
    const amountIn = getTransferAmountFee(
      _expectedAmountIn,
      (_c = token2022Infos[inMint.toString()]) == null ? void 0 : _c.feeConfig,
      epochInfo,
      true
    );
    const _executionPrice = SqrtPriceMath.sqrtPriceX64ToPrice(
      _executionPriceX64,
      poolInfo.mintA.decimals,
      poolInfo.mintB.decimals
    );
    const executionPrice = baseMint.equals(poolInfo.mintA.mint) ? _executionPrice : new decimal_default2(1).div(_executionPrice);
    const _maxAmountIn = _expectedAmountIn.mul(new import_bn11.default(Math.floor((1 + slippage) * 1e10))).div(new import_bn11.default(1e10));
    const maxAmountIn = getTransferAmountFee(
      _maxAmountIn,
      (_d = token2022Infos[inMint.toString()]) == null ? void 0 : _d.feeConfig,
      epochInfo,
      true
    );
    const poolPrice = poolInfo.mintA.mint.equals(baseMint) ? poolInfo.currentPrice : new decimal_default2(1).div(poolInfo.currentPrice);
    const _numerator = new decimal_default2(executionPrice).sub(poolPrice).abs();
    const _denominator = poolPrice;
    const priceImpact = new Percent(
      new decimal_default2(_numerator).mul(__pow(10, 15)).toFixed(0),
      new decimal_default2(_denominator).mul(__pow(10, 15)).toFixed(0)
    );
    return {
      amountIn,
      maxAmountIn,
      realAmountOut,
      expirationTime: minExpirationTime(amountIn.expirationTime, realAmountOut.expirationTime),
      currentPrice: poolInfo.currentPrice,
      executionPrice,
      priceImpact,
      fee: feeAmount,
      remainingAccounts
    };
  }
  static estimateAprsForPriceRangeMultiplier({
    poolInfo,
    aprType,
    positionTickLowerIndex,
    positionTickUpperIndex
  }) {
    const aprInfo = poolInfo[aprType];
    const priceLower = this.getTickPrice({ poolInfo, tick: positionTickLowerIndex, baseIn: true }).price.toNumber();
    const priceUpper = this.getTickPrice({ poolInfo, tick: positionTickUpperIndex, baseIn: true }).price.toNumber();
    const _minPrice = Math.max(priceLower, aprInfo.priceMin);
    const _maxPrice = Math.min(priceUpper, aprInfo.priceMax);
    const sub2 = _maxPrice - _minPrice;
    const userRange = priceUpper - priceLower;
    const tradeRange = aprInfo.priceMax - aprInfo.priceMin;
    let p;
    if (sub2 <= 0) p = 0;
    else if (userRange === sub2) p = tradeRange / sub2;
    else if (tradeRange === sub2) p = sub2 / userRange;
    else p = sub2 / tradeRange * (sub2 / userRange);
    return {
      feeApr: aprInfo.feeApr * p,
      rewardsApr: [aprInfo.rewardApr.A * p, aprInfo.rewardApr.B * p, aprInfo.rewardApr.C * p],
      apr: aprInfo.apr * p
    };
  }
  static estimateAprsForPriceRangeDelta({
    poolInfo,
    aprType,
    mintPrice,
    rewardMintDecimals,
    liquidity,
    positionTickLowerIndex,
    positionTickUpperIndex,
    chainTime
  }) {
    const aprTypeDay = aprType === "day" ? 1 : aprType === "week" ? 7 : aprType === "month" ? 30 : 0;
    const aprInfo = poolInfo[aprType];
    const mintPriceA = mintPrice[poolInfo.mintA.mint.toString()];
    const mintPriceB = mintPrice[poolInfo.mintB.mint.toString()];
    const mintDecimalsA = poolInfo.mintA.decimals;
    const mintDecimalsB = poolInfo.mintB.decimals;
    if (!aprInfo || !mintPriceA || !mintPriceB) return { feeApr: 0, rewardsApr: [0, 0, 0], apr: 0 };
    const sqrtPriceX64A = SqrtPriceMath.getSqrtPriceX64FromTick(positionTickLowerIndex);
    const sqrtPriceX64B = SqrtPriceMath.getSqrtPriceX64FromTick(positionTickUpperIndex);
    const { amountSlippageA: poolLiquidityA, amountSlippageB: poolLiquidityB } = LiquidityMath.getAmountsFromLiquidityWithSlippage(
      poolInfo.sqrtPriceX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      poolInfo.liquidity,
      false,
      false,
      0
    );
    const { amountSlippageA: userLiquidityA, amountSlippageB: userLiquidityB } = LiquidityMath.getAmountsFromLiquidityWithSlippage(
      poolInfo.sqrtPriceX64,
      sqrtPriceX64A,
      sqrtPriceX64B,
      liquidity,
      false,
      false,
      0
    );
    const poolTvl = new decimal_default2(poolLiquidityA.toString()).div(new decimal_default2(10).pow(mintDecimalsA)).mul(mintPriceA.toFixed(mintDecimalsA)).add(
      new decimal_default2(poolLiquidityB.toString()).div(new decimal_default2(10).pow(mintDecimalsB)).mul(mintPriceB.toFixed(mintDecimalsB))
    );
    const userTvl = new decimal_default2(userLiquidityA.toString()).div(new decimal_default2(10).pow(mintDecimalsA)).mul(mintPriceA.toFixed(mintDecimalsA)).add(
      new decimal_default2(userLiquidityB.toString()).div(new decimal_default2(10).pow(mintDecimalsB)).mul(mintPriceB.toFixed(mintDecimalsB))
    );
    const p = new decimal_default2(1).div(poolTvl.add(userTvl));
    const feesPerYear = new decimal_default2(aprInfo.volumeFee).mul(365).div(aprTypeDay);
    const feeApr = feesPerYear.mul(p).mul(100).toNumber();
    const SECONDS_PER_YEAR = 3600 * 24 * 365;
    const rewardsApr = poolInfo.rewardInfos.map((i) => {
      const iDecimal = rewardMintDecimals[i.tokenMint.toString()];
      const iPrice = mintPrice[i.tokenMint.toString()];
      if (chainTime < i.openTime.toNumber() || chainTime > i.endTime.toNumber() || i.perSecond.equals(0) || !iPrice || iDecimal === void 0)
        return 0;
      return new decimal_default2(iPrice.toFixed(iDecimal)).mul(i.perSecond.mul(SECONDS_PER_YEAR)).div(new decimal_default2(10).pow(iDecimal)).mul(p).mul(100).toNumber();
    });
    return {
      feeApr,
      rewardsApr,
      apr: feeApr + rewardsApr.reduce((a, b) => a + b, 0)
    };
  }
  // fetch data
  static fetchMultiplePoolInfos(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      ownerInfo,
      chainTime,
      batchRequest = false,
      updateOwnerRewardAndFee = true
    }) {
      var _a;
      const poolAccountInfos = yield getMultipleAccountsInfo(
        connection,
        poolKeys.map((i) => new PublicKey(i.id)),
        { batchRequest }
      );
      const exBitmapAddress = {};
      for (let index = 0; index < poolKeys.length; index++) {
        const apiPoolInfo = poolKeys[index];
        const accountInfo = poolAccountInfos[index];
        if (accountInfo === null) continue;
        exBitmapAddress[apiPoolInfo.id] = getPdaExBitmapAccount(
          accountInfo.owner,
          new PublicKey(apiPoolInfo.id)
        ).publicKey;
      }
      const exBitmapAccountInfos = yield this.fetchExBitmaps({
        connection,
        exBitmapAddress: Object.values(exBitmapAddress),
        batchRequest
      });
      const programIds = [];
      const poolsInfo = {};
      const updateRewardInfos = [];
      for (let index = 0; index < poolKeys.length; index++) {
        const apiPoolInfo = poolKeys[index];
        const accountInfo = poolAccountInfos[index];
        const exBitmapInfo = exBitmapAccountInfos[exBitmapAddress[apiPoolInfo.id].toString()];
        if (accountInfo === null) continue;
        const layoutAccountInfo = PoolInfoLayout.decode(accountInfo.data);
        poolsInfo[apiPoolInfo.id] = {
          state: {
            id: new PublicKey(apiPoolInfo.id),
            mintA: {
              programId: new PublicKey(apiPoolInfo.mintProgramIdA),
              mint: layoutAccountInfo.mintA,
              vault: layoutAccountInfo.vaultA,
              decimals: layoutAccountInfo.mintDecimalsA
            },
            mintB: {
              programId: new PublicKey(apiPoolInfo.mintProgramIdB),
              mint: layoutAccountInfo.mintB,
              vault: layoutAccountInfo.vaultB,
              decimals: layoutAccountInfo.mintDecimalsB
            },
            observationId: layoutAccountInfo.observationId,
            ammConfig: __spreadProps(__spreadValues({}, apiPoolInfo.ammConfig), {
              id: new PublicKey(apiPoolInfo.ammConfig.id)
            }),
            creator: layoutAccountInfo.creator,
            programId: accountInfo.owner,
            version: 6,
            tickSpacing: layoutAccountInfo.tickSpacing,
            liquidity: layoutAccountInfo.liquidity,
            sqrtPriceX64: layoutAccountInfo.sqrtPriceX64,
            currentPrice: SqrtPriceMath.sqrtPriceX64ToPrice(
              layoutAccountInfo.sqrtPriceX64,
              layoutAccountInfo.mintDecimalsA,
              layoutAccountInfo.mintDecimalsB
            ),
            tickCurrent: layoutAccountInfo.tickCurrent,
            observationIndex: layoutAccountInfo.observationIndex,
            observationUpdateDuration: layoutAccountInfo.observationUpdateDuration,
            feeGrowthGlobalX64A: layoutAccountInfo.feeGrowthGlobalX64A,
            feeGrowthGlobalX64B: layoutAccountInfo.feeGrowthGlobalX64B,
            protocolFeesTokenA: layoutAccountInfo.protocolFeesTokenA,
            protocolFeesTokenB: layoutAccountInfo.protocolFeesTokenB,
            swapInAmountTokenA: layoutAccountInfo.swapInAmountTokenA,
            swapOutAmountTokenB: layoutAccountInfo.swapOutAmountTokenB,
            swapInAmountTokenB: layoutAccountInfo.swapInAmountTokenB,
            swapOutAmountTokenA: layoutAccountInfo.swapOutAmountTokenA,
            tickArrayBitmap: layoutAccountInfo.tickArrayBitmap,
            rewardInfos: yield PoolUtils.updatePoolRewardInfos({
              connection,
              apiPoolInfo,
              chainTime,
              poolLiquidity: layoutAccountInfo.liquidity,
              rewardInfos: layoutAccountInfo.rewardInfos.filter((i) => !i.tokenMint.equals(PublicKey.default))
            }),
            day: apiPoolInfo.day,
            week: apiPoolInfo.week,
            month: apiPoolInfo.month,
            tvl: apiPoolInfo.tvl,
            lookupTableAccount: apiPoolInfo.lookupTableAccount ? new PublicKey(apiPoolInfo.lookupTableAccount) : PublicKey.default,
            startTime: layoutAccountInfo.startTime.toNumber(),
            exBitmapInfo
          }
        };
        if (ownerInfo) {
          updateRewardInfos.push(
            ...poolsInfo[apiPoolInfo.id].state.rewardInfos.filter((i) => i.creator.equals(ownerInfo.wallet))
          );
        }
        if (!programIds.find((i) => i.equals(accountInfo.owner))) programIds.push(accountInfo.owner);
      }
      if (ownerInfo) {
        const allMint = ownerInfo.tokenAccounts.filter((i) => i.accountInfo.amount.eq(new import_bn11.default(1))).map((i) => i.accountInfo.mint);
        const allPositionKey = [];
        for (const itemMint of allMint) {
          for (const itemProgramId of programIds) {
            allPositionKey.push(getPdaPersonalPositionAddress(itemProgramId, itemMint).publicKey);
          }
        }
        const positionAccountInfos = yield getMultipleAccountsInfo(connection, allPositionKey, { batchRequest });
        const keyToTickArrayAddress = {};
        for (const itemAccountInfo of positionAccountInfos) {
          if (itemAccountInfo === null) continue;
          const position = PositionInfoLayout.decode(itemAccountInfo.data);
          const itemPoolId = position.poolId.toString();
          const poolInfoA = poolsInfo[itemPoolId];
          if (poolInfoA === void 0) continue;
          const poolInfo = poolInfoA.state;
          const priceLower = this.getTickPrice({
            poolInfo,
            tick: position.tickLower,
            baseIn: true
          });
          const priceUpper = this.getTickPrice({
            poolInfo,
            tick: position.tickUpper,
            baseIn: true
          });
          const { amountA, amountB } = LiquidityMath.getAmountsFromLiquidity(
            poolInfo.sqrtPriceX64,
            priceLower.tickSqrtPriceX64,
            priceUpper.tickSqrtPriceX64,
            position.liquidity,
            false
          );
          const leverage = 1 / (1 - Math.sqrt(Math.sqrt(priceLower.price.div(priceUpper.price).toNumber())));
          poolsInfo[itemPoolId].positionAccount = [
            ...(_a = poolsInfo[itemPoolId].positionAccount) != null ? _a : [],
            {
              poolId: position.poolId,
              nftMint: position.nftMint,
              priceLower: priceLower.price,
              priceUpper: priceUpper.price,
              amountA,
              amountB,
              tickLower: position.tickLower,
              tickUpper: position.tickUpper,
              liquidity: position.liquidity,
              feeGrowthInsideLastX64A: position.feeGrowthInsideLastX64A,
              feeGrowthInsideLastX64B: position.feeGrowthInsideLastX64B,
              tokenFeesOwedA: position.tokenFeesOwedA,
              tokenFeesOwedB: position.tokenFeesOwedB,
              rewardInfos: position.rewardInfos.map((i) => __spreadProps(__spreadValues({}, i), {
                pendingReward: new import_bn11.default(0)
              })),
              leverage,
              tokenFeeAmountA: new import_bn11.default(0),
              tokenFeeAmountB: new import_bn11.default(0)
            }
          ];
          const tickArrayLowerAddress = TickUtils.getTickArrayAddressByTick(
            poolsInfo[itemPoolId].state.programId,
            position.poolId,
            position.tickLower,
            poolsInfo[itemPoolId].state.tickSpacing
          );
          const tickArrayUpperAddress = TickUtils.getTickArrayAddressByTick(
            poolsInfo[itemPoolId].state.programId,
            position.poolId,
            position.tickUpper,
            poolsInfo[itemPoolId].state.tickSpacing
          );
          keyToTickArrayAddress[`${poolsInfo[itemPoolId].state.programId.toString()}-${position.poolId.toString()}-${position.tickLower}`] = tickArrayLowerAddress;
          keyToTickArrayAddress[`${poolsInfo[itemPoolId].state.programId.toString()}-${position.poolId.toString()}-${position.tickUpper}`] = tickArrayUpperAddress;
        }
        if (updateOwnerRewardAndFee) {
          const tickArrayKeys = Object.values(keyToTickArrayAddress);
          const tickArrayDatas = yield getMultipleAccountsInfo(connection, tickArrayKeys, { batchRequest });
          const tickArrayLayout = {};
          for (let index = 0; index < tickArrayKeys.length; index++) {
            const tickArrayData = tickArrayDatas[index];
            if (tickArrayData === null) continue;
            const key = tickArrayKeys[index];
            tickArrayLayout[key.toString()] = __spreadValues({
              address: key
            }, TickArrayLayout.decode(tickArrayData.data));
          }
          for (const { state, positionAccount } of Object.values(poolsInfo)) {
            if (!positionAccount) continue;
            for (const itemPA of positionAccount) {
              const keyLower = `${state.programId.toString()}-${state.id.toString()}-${itemPA.tickLower}`;
              const keyUpper = `${state.programId.toString()}-${state.id.toString()}-${itemPA.tickUpper}`;
              const tickArrayLower = tickArrayLayout[keyToTickArrayAddress[keyLower].toString()];
              const tickArrayUpper = tickArrayLayout[keyToTickArrayAddress[keyUpper].toString()];
              const tickLowerState = tickArrayLower.ticks[TickUtils.getTickOffsetInArray(itemPA.tickLower, state.tickSpacing)];
              const tickUpperState = tickArrayUpper.ticks[TickUtils.getTickOffsetInArray(itemPA.tickUpper, state.tickSpacing)];
              const { tokenFeeAmountA, tokenFeeAmountB } = PositionUtils.GetPositionFees(
                state,
                itemPA,
                tickLowerState,
                tickUpperState
              );
              const rewardInfos = PositionUtils.GetPositionRewards(state, itemPA, tickLowerState, tickUpperState);
              itemPA.tokenFeeAmountA = tokenFeeAmountA.gte(ZERO) && tokenFeeAmountA.lt(U64_IGNORE_RANGE) ? tokenFeeAmountA : ZERO;
              itemPA.tokenFeeAmountB = tokenFeeAmountB.gte(ZERO) && tokenFeeAmountA.lt(U64_IGNORE_RANGE) ? tokenFeeAmountB : ZERO;
              for (let i = 0; i < rewardInfos.length; i++) {
                itemPA.rewardInfos[i].pendingReward = rewardInfos[i].gte(ZERO) && rewardInfos[i].lt(U64_IGNORE_RANGE) ? rewardInfos[i] : ZERO;
              }
            }
          }
        }
      }
      if (updateRewardInfos.length > 0) {
        const vaults = updateRewardInfos.map((i) => i.tokenVault);
        const rewardVaultInfos = yield getMultipleAccountsInfo(connection, vaults, { batchRequest });
        const rewardVaultAmount = {};
        for (let index = 0; index < vaults.length; index++) {
          const valutKey = vaults[index].toString();
          const itemRewardVaultInfo = rewardVaultInfos[index];
          if (itemRewardVaultInfo === null) continue;
          const info = SPL_ACCOUNT_LAYOUT.decode(itemRewardVaultInfo.data);
          rewardVaultAmount[valutKey] = info.amount;
        }
        for (const item of updateRewardInfos) {
          const vaultAmount = rewardVaultAmount[item.tokenVault.toString()];
          item.remainingRewards = vaultAmount !== void 0 ? vaultAmount.sub(item.rewardTotalEmissioned.sub(item.rewardClaimed)) : ZERO;
        }
      }
      return poolsInfo;
    });
  }
  static fetchMultiplePoolTickArrays(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      batchRequest
    }) {
      const tickArraysToPoolId = {};
      const tickArrays = [];
      for (const itemPoolInfo of poolKeys) {
        const currentTickArrayStartIndex = TickUtils.getTickArrayStartIndexByTick(
          itemPoolInfo.tickCurrent,
          itemPoolInfo.tickSpacing
        );
        const startIndexArray = TickUtils.getInitializedTickArrayInRange(
          itemPoolInfo.tickArrayBitmap,
          itemPoolInfo.exBitmapInfo,
          itemPoolInfo.tickSpacing,
          currentTickArrayStartIndex,
          7
        );
        for (const itemIndex of startIndexArray) {
          const { publicKey: tickArrayAddress } = getPdaTickArrayAddress(
            itemPoolInfo.programId,
            itemPoolInfo.id,
            itemIndex
          );
          tickArrays.push({ pubkey: tickArrayAddress });
          tickArraysToPoolId[tickArrayAddress.toString()] = itemPoolInfo.id;
        }
      }
      const fetchedTickArrays = yield getMultipleAccountsInfoWithCustomFlags(connection, tickArrays, { batchRequest });
      const tickArrayCache = {};
      for (const itemAccountInfo of fetchedTickArrays) {
        if (!itemAccountInfo.accountInfo) continue;
        const poolId = tickArraysToPoolId[itemAccountInfo.pubkey.toString()];
        if (!poolId) continue;
        if (tickArrayCache[poolId.toString()] === void 0) tickArrayCache[poolId.toString()] = {};
        const accountLayoutData = TickArrayLayout.decode(itemAccountInfo.accountInfo.data);
        tickArrayCache[poolId.toString()][accountLayoutData.startTickIndex] = __spreadProps(__spreadValues({}, accountLayoutData), {
          address: itemAccountInfo.pubkey
        });
      }
      return tickArrayCache;
    });
  }
  static fetchExBitmaps(_0) {
    return __async(this, arguments, function* ({
      connection,
      exBitmapAddress,
      batchRequest
    }) {
      const fetchedBitmapAccount = yield getMultipleAccountsInfoWithCustomFlags(
        connection,
        exBitmapAddress.map((i) => ({ pubkey: i })),
        { batchRequest }
      );
      const returnTypeFetchExBitmaps = {};
      for (const item of fetchedBitmapAccount) {
        if (item.accountInfo === null) continue;
        returnTypeFetchExBitmaps[item.pubkey.toString()] = TickArrayBitmapExtensionLayout.decode(item.accountInfo.data);
      }
      return returnTypeFetchExBitmaps;
    });
  }
  static getWhiteListMint(_0) {
    return __async(this, arguments, function* ({ connection, programId }) {
      const accountInfo = yield connection.getAccountInfo(getPdaOperationAccount(programId).publicKey);
      if (!accountInfo) return [];
      const whitelistMintsInfo = OperationLayout.decode(accountInfo.data);
      return whitelistMintsInfo.whitelistMints.filter((i) => !i.equals(PublicKey.default));
    });
  }
};
var _SERUM_PROGRAM_ID_V3 = "9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin";
var SERUM_PROGRAM_ID_V3 = new PublicKey(_SERUM_PROGRAM_ID_V3);
var SERUM_PROGRAMID_TO_VERSION = {
  [_SERUM_PROGRAM_ID_V3]: 3
};
var SERUM_VERSION_TO_PROGRAMID = {
  3: SERUM_PROGRAM_ID_V3
};
var MARKET_STATE_LAYOUT_V3 = struct50([
  blob3(5),
  blob3(8),
  // accountFlagsLayout('accountFlags'),
  publicKey2("ownAddress"),
  u642("vaultSignerNonce"),
  publicKey2("baseMint"),
  publicKey2("quoteMint"),
  publicKey2("baseVault"),
  u642("baseDepositsTotal"),
  u642("baseFeesAccrued"),
  publicKey2("quoteVault"),
  u642("quoteDepositsTotal"),
  u642("quoteFeesAccrued"),
  u642("quoteDustThreshold"),
  publicKey2("requestQueue"),
  publicKey2("eventQueue"),
  publicKey2("bids"),
  publicKey2("asks"),
  u642("baseLotSize"),
  u642("quoteLotSize"),
  u642("feeRateBps"),
  u642("referrerRebatesAccrued"),
  blob3(7)
]);
var MARKET_VERSION_TO_STATE_LAYOUT = {
  3: MARKET_STATE_LAYOUT_V3
};
var logger10 = Logger.from("Serum");
var Market = class {
  /* ================= get version and program id ================= */
  static getProgramId(version2) {
    const programId = SERUM_VERSION_TO_PROGRAMID[version2];
    logger10.assertArgument(!!programId, "invalid version", "version", version2);
    return programId;
  }
  static getVersion(programId) {
    const programIdString = programId.toBase58();
    const version2 = SERUM_PROGRAMID_TO_VERSION[programIdString];
    logger10.assertArgument(!!version2, "invalid program id", "programId", programIdString);
    return version2;
  }
  /* ================= get layout ================= */
  static getStateLayout(version2) {
    const STATE_LAYOUT = MARKET_VERSION_TO_STATE_LAYOUT[version2];
    logger10.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
    return STATE_LAYOUT;
  }
  static getLayouts(version2) {
    return { state: this.getStateLayout(version2) };
  }
  /* ================= get key ================= */
  static getAssociatedAuthority({ programId, marketId }) {
    const seeds = [marketId.toBuffer()];
    let nonce = 0;
    let publicKey22;
    while (nonce < 100) {
      try {
        const seedsWithNonce = seeds.concat(Buffer.from([nonce]), Buffer.alloc(7));
        publicKey22 = PublicKey.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce++;
        continue;
      }
      return { publicKey: publicKey22, nonce };
    }
    return logger10.throwArgumentError("unable to find a viable program address nonce", "params", {
      programId,
      marketId
    });
  }
};
var ModelDataPubkey = new PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo");
var ELEMENT_SIZE = 5e4;
var DataElement = struct50([u642("x"), u642("y"), u642("price")]);
var ModelDataInfo = struct50([
  u642("accountType"),
  u642("status"),
  u642("multiplier"),
  u642("validDataCount"),
  seq22(DataElement, ELEMENT_SIZE, "DataElement")
]);
function estimateRangeByXyReal(_xReal, _yReal) {
  return [0, ELEMENT_SIZE - 2];
}
function estimateRangeByX(_x) {
  return [0, ELEMENT_SIZE - 2];
}
function estimateRangeByY(_y) {
  return [0, ELEMENT_SIZE - 2];
}
function getMininumRangeByXyReal(layoutData, xReal, yReal) {
  const [min2, max2] = estimateRangeByXyReal(xReal, yReal);
  let minRangeIdx = min2;
  let maxRangeIdx = max2;
  let mid = 0;
  const target = xReal * layoutData.multiplier / yReal;
  while (minRangeIdx <= maxRangeIdx) {
    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
    if (mid === 0 || mid >= ELEMENT_SIZE - 2) {
      return [mid, mid, false];
    }
    const cur = layoutData.DataElement[mid].x * layoutData.multiplier / layoutData.DataElement[mid].y;
    const left = layoutData.DataElement[mid - 1].x * layoutData.multiplier / layoutData.DataElement[mid - 1].y;
    const right = layoutData.DataElement[mid + 1].x * layoutData.multiplier / layoutData.DataElement[mid + 1].y;
    if (target === cur) {
      return [mid, mid, true];
    } else if (target === left) {
      return [mid - 1, mid - 1, true];
    } else if (target === right) {
      return [mid + 1, mid + 1, true];
    } else if (target < left) {
      maxRangeIdx = mid - 1;
    } else if (target > left && target < cur) {
      return [mid - 1, mid, true];
    } else if (target > cur && target < right) {
      return [mid, mid + 1, true];
    } else {
      minRangeIdx = mid + 1;
    }
  }
  return [mid, mid, false];
}
function getRatio(layoutData, xReal, yReal) {
  const [minRangeIdx, maxRangeIdx, find] = getMininumRangeByXyReal(layoutData, xReal, yReal);
  if (!find) {
    return 0;
  }
  if (minRangeIdx === maxRangeIdx) {
    const x = layoutData.DataElement[minRangeIdx].x;
    const ratio = xReal * layoutData.multiplier / x;
    return ratio;
  } else {
    const x1 = layoutData.DataElement[minRangeIdx].x;
    const y1 = layoutData.DataElement[minRangeIdx].y;
    const x2 = layoutData.DataElement[maxRangeIdx].x;
    const y2 = layoutData.DataElement[maxRangeIdx].y;
    const xDenominator = yReal * (x2 * y1 - x1 * y2);
    const xNumerator1 = x1 * xDenominator;
    const xNumerator2 = (x2 - x1) * (xReal * y1 - x1 * yReal) * y2;
    const xNumerator = xNumerator1 + xNumerator2;
    const ratio = xReal * layoutData.multiplier * xDenominator / xNumerator;
    return ratio;
  }
}
function realToTable(layoutData, realValue, ratio) {
  return realValue * layoutData.multiplier / ratio;
}
function tableToReal(layoutData, tableValue, ratio) {
  return tableValue * ratio / layoutData.multiplier;
}
function getMinimumRangeByX(layoutData, x) {
  const [min2, max2] = estimateRangeByX(x);
  let minRangeIdx = min2;
  let maxRangeIdx = max2;
  let mid = 0;
  const target = x;
  while (minRangeIdx < maxRangeIdx) {
    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
    if (mid <= 0 || mid > ELEMENT_SIZE - 2) {
      return [mid, mid, false];
    }
    const cur = layoutData.DataElement[mid].x;
    const left = layoutData.DataElement[mid - 1].x;
    const right = layoutData.DataElement[mid + 1].x;
    if (target === cur) return [mid, mid, true];
    else if (target === left) return [mid - 1, mid - 1, true];
    else if (target === right) return [mid + 1, mid + 1, true];
    else if (target < left) maxRangeIdx = mid - 1;
    else if (target > left && target < cur) return [mid - 1, mid, true];
    else if (target > cur && target < right) return [mid, mid + 1, true];
    else minRangeIdx = mid + 1;
  }
  return [mid, mid, false];
}
function getMinimumRangeByY(layoutData, y) {
  const [min2, max2] = estimateRangeByY(y);
  let minRangeIdx = min2;
  let maxRangeIdx = max2;
  let mid = 0;
  const target = y;
  while (minRangeIdx <= maxRangeIdx) {
    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);
    if (mid <= 0 || mid >= ELEMENT_SIZE - 2) {
      return [mid, mid, false];
    }
    const cur = layoutData.DataElement[mid].y;
    const left = layoutData.DataElement[mid - 1].y;
    const right = layoutData.DataElement[mid + 1].y;
    if (target === cur) return [mid, mid, true];
    else if (target === left) return [mid - 1, mid - 1, true];
    else if (target === right) return [mid + 1, mid + 1, true];
    else if (target < right) {
      minRangeIdx = mid + 1;
    } else if (target < left && target > cur) return [mid - 1, mid, true];
    else if (target < cur && target > right) return [mid, mid + 1, true];
    else maxRangeIdx = mid - 1;
  }
  return [mid, mid, false];
}
function getDataByX(layoutData, x, dx, priceUp) {
  const xWithDx = priceUp ? x + dx : x - dx;
  const [minIdx, maxIdx, find] = getMinimumRangeByX(layoutData, xWithDx);
  if (!find) return [0, 0, false, find];
  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].y, false, find];
  else {
    const x1 = layoutData.DataElement[minIdx].x;
    const x2 = layoutData.DataElement[maxIdx].x;
    const p1 = layoutData.DataElement[minIdx].price;
    const p2 = layoutData.DataElement[maxIdx].price;
    const y1 = layoutData.DataElement[minIdx].y;
    const y2 = layoutData.DataElement[maxIdx].y;
    if (x >= x1 && x <= x2) {
      if (priceUp) return [p2, y2, true, find];
      else return [p1, y1, true, find];
    } else {
      let p, y;
      if (priceUp) {
        p = p1 + (p2 - p1) * (x - x1) / (x2 - x1);
        y = y1 - (xWithDx - x1) * layoutData.multiplier / p2;
      } else {
        p = p1 + (p2 - p1) * (x - x1) / (x2 - x1);
        y = y2 + (x2 - xWithDx) * layoutData.multiplier / p1;
      }
      return [p, y, false, find];
    }
  }
}
function getDataByY(layoutData, y, dy, priceUp) {
  const yWithDy = priceUp ? y - dy : y + dy;
  const [minIdx, maxIdx, find] = getMinimumRangeByY(layoutData, yWithDy);
  if (!find) return [0, 0, false, find];
  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].x, false, find];
  else {
    const x1 = layoutData.DataElement[minIdx].x;
    const x2 = layoutData.DataElement[maxIdx].x;
    const p1 = layoutData.DataElement[minIdx].price;
    const p2 = layoutData.DataElement[maxIdx].price;
    const y1 = layoutData.DataElement[minIdx].y;
    const y2 = layoutData.DataElement[maxIdx].y;
    if (y >= y2 && y <= y1) {
      return priceUp ? [p2, x2, true, find] : [p1, x1, true, find];
    } else {
      let p, x;
      if (priceUp) {
        p = p1 + (p2 - p1) * (y1 - y) / (y1 - y2);
        x = x1 + p2 * (y1 - yWithDy) / layoutData.multiplier;
      } else {
        p = p1 + (p2 - p1) * (y1 - y) / (y1 - y2);
        x = x2 - p1 * (yWithDy - y2) / layoutData.multiplier;
      }
      return [p, x, false, find];
    }
  }
}
function getMidPrice(layoutData, x) {
  const ret = getDataByX(layoutData, x, 0, false);
  if (ret[3]) return ret[0];
  else return 0;
}
function getDyByDxBaseIn(layoutData, xReal, yReal, dxReal) {
  const ratio = getRatio(layoutData, xReal, yReal);
  const x = realToTable(layoutData, xReal, ratio);
  const y = realToTable(layoutData, yReal, ratio);
  const dx = realToTable(layoutData, dxReal, ratio);
  const priceUp = true;
  const [p, y2, lessTrade, find] = getDataByX(layoutData, x, dx, priceUp);
  if (!find) return 0;
  if (lessTrade) {
    const dyReal = dxReal * layoutData.multiplier / p;
    return dyReal;
  } else {
    const dy = y - y2;
    const dyReal = tableToReal(layoutData, dy, ratio);
    return dyReal;
  }
}
function getDxByDyBaseIn(layoutData, xReal, yReal, dyReal) {
  const ratio = getRatio(layoutData, xReal, yReal);
  const x = realToTable(layoutData, xReal, ratio);
  const y = realToTable(layoutData, yReal, ratio);
  const dy = realToTable(layoutData, dyReal, ratio);
  const priceUp = false;
  const [p, x2, lessTrade, find] = getDataByY(layoutData, y, dy, priceUp);
  if (!find) return 0;
  if (lessTrade) {
    const dxReal = dyReal * p / layoutData.multiplier;
    return dxReal;
  } else {
    const dx = x - x2;
    const dxReal = tableToReal(layoutData, dx, ratio);
    return dxReal;
  }
}
function formatLayout(buffer) {
  const layoutInfo = ModelDataInfo.decode(buffer);
  return {
    accountType: layoutInfo.accountType.toNumber(),
    status: layoutInfo.status.toNumber(),
    multiplier: layoutInfo.multiplier.toNumber(),
    validDataCount: layoutInfo.validDataCount.toNumber(),
    DataElement: layoutInfo.DataElement.map((item) => ({
      x: item.x.toNumber(),
      y: item.y.toNumber(),
      price: item.price.toNumber()
    }))
  };
}
function getStablePrice(layoutData, coinReal, pcReal, baseCoin) {
  const price = getMidPrice(layoutData, realToTable(layoutData, coinReal, getRatio(layoutData, coinReal, pcReal))) / layoutData.multiplier;
  return baseCoin ? price : 1 / price;
}
var logger11 = Logger.from("Liquidity");
var modelData = {
  accountType: 0,
  status: 0,
  multiplier: 0,
  validDataCount: 0,
  DataElement: []
};
function initStableModelLayout(connection) {
  return __async(this, null, function* () {
    if (modelData.validDataCount === 0) {
      if (connection) {
        const acc = yield connection.getAccountInfo(ModelDataPubkey);
        if (acc) modelData = formatLayout(acc == null ? void 0 : acc.data);
      }
    }
  });
}
var LiquidityPoolStatus = ((LiquidityPoolStatus2) => {
  LiquidityPoolStatus2[LiquidityPoolStatus2["Uninitialized"] = 0] = "Uninitialized";
  LiquidityPoolStatus2[LiquidityPoolStatus2["Initialized"] = 1] = "Initialized";
  LiquidityPoolStatus2[LiquidityPoolStatus2["Disabled"] = 2] = "Disabled";
  LiquidityPoolStatus2[LiquidityPoolStatus2["RemoveLiquidityOnly"] = 3] = "RemoveLiquidityOnly";
  LiquidityPoolStatus2[LiquidityPoolStatus2["LiquidityOnly"] = 4] = "LiquidityOnly";
  LiquidityPoolStatus2[LiquidityPoolStatus2["OrderBook"] = 5] = "OrderBook";
  LiquidityPoolStatus2[LiquidityPoolStatus2["Swap"] = 6] = "Swap";
  LiquidityPoolStatus2[LiquidityPoolStatus2["WaitingForStart"] = 7] = "WaitingForStart";
  return LiquidityPoolStatus2;
})(LiquidityPoolStatus || {});
var LIQUIDITY_FEES_NUMERATOR = new import_bn10.default(25);
var LIQUIDITY_FEES_DENOMINATOR = new import_bn10.default(1e4);
var _Liquidity = class _Liquidity2 extends Base {
  // public connection: Connection;
  // public poolKeys: LiquidityPoolKeys;
  // public poolInfo: LiquidityPoolInfo;
  // constructor({ connection, poolKeys, poolInfo }: LiquidityConstructParams) {
  //   this.connection = connection;
  //   this.poolKeys = poolKeys;
  //   this.poolInfo = poolInfo;
  // }
  // static async load({ connection, poolKeys, poolInfo }: LiquidityLoadParams) {
  //   const _poolInfo = poolInfo || (await this.fetchInfo({ connection, poolKeys }));
  //   return new Liquidity({ connection, poolKeys, poolInfo: _poolInfo });
  // }
  /* ================= get version and program id ================= */
  // static getProgramId(version: number) {
  //   const programId = LIQUIDITY_VERSION_TO_PROGRAMID[version];
  //   logger.assertArgument(!!programId, "invalid version", "version", version);
  //   return programId;
  // }
  // static getVersion(programId: PublicKey) {
  //   const programIdString = programId.toBase58();
  //   const version = LIQUIDITY_PROGRAMID_TO_VERSION[programIdString];
  //   logger.assertArgument(!!version, "invalid program id", "programId", programIdString);
  //   return version;
  // }
  // static getSerumVersion(version: number) {
  //   const serumVersion = LIQUIDITY_VERSION_TO_SERUM_VERSION[version];
  //   logger.assertArgument(!!serumVersion, "invalid version", "version", version);
  //   return serumVersion;
  // }
  /* ================= get layout ================= */
  static getStateLayout(version2) {
    const STATE_LAYOUT = LIQUIDITY_VERSION_TO_STATE_LAYOUT[version2];
    logger11.assertArgument(!!STATE_LAYOUT, "invalid version", "version", version2);
    return STATE_LAYOUT;
  }
  static getLayouts(version2) {
    return { state: this.getStateLayout(version2) };
  }
  /* ================= get key ================= */
  static getAssociatedId({ programId, marketId }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("amm_associated_seed", "utf-8")],
      programId
    );
    return publicKey22;
  }
  static getAssociatedAuthority({ programId }) {
    return findProgramAddress(
      // new Uint8Array(Buffer.from('amm authority'.replace('\u00A0', ' '), 'utf-8'))
      [Buffer.from([97, 109, 109, 32, 97, 117, 116, 104, 111, 114, 105, 116, 121])],
      programId
    );
  }
  static getAssociatedBaseVault({ programId, marketId }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("coin_vault_associated_seed", "utf-8")],
      programId
    );
    return publicKey22;
  }
  static getAssociatedQuoteVault({ programId, marketId }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("pc_vault_associated_seed", "utf-8")],
      programId
    );
    return publicKey22;
  }
  static getAssociatedLpMint({ programId, marketId }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("lp_mint_associated_seed", "utf-8")],
      programId
    );
    return publicKey22;
  }
  static getAssociatedLpVault({ programId, marketId }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("temp_lp_token_associated_seed", "utf-8")],
      programId
    );
    return publicKey22;
  }
  static getAssociatedTargetOrders({ programId, marketId }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("target_associated_seed", "utf-8")],
      programId
    );
    return publicKey22;
  }
  static getAssociatedWithdrawQueue({ programId, marketId }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("withdraw_associated_seed", "utf-8")],
      programId
    );
    return publicKey22;
  }
  static getAssociatedOpenOrders({ programId, marketId }) {
    const { publicKey: publicKey22 } = findProgramAddress(
      [programId.toBuffer(), marketId.toBuffer(), Buffer.from("open_order_associated_seed", "utf-8")],
      programId
    );
    return publicKey22;
  }
  static getAssociatedConfigId({ programId }) {
    const { publicKey: publicKey22 } = findProgramAddress([Buffer.from("amm_config_account_seed", "utf-8")], programId);
    return publicKey22;
  }
  static getAssociatedPoolKeys({
    version: version2,
    marketVersion,
    marketId,
    baseMint,
    quoteMint,
    baseDecimals,
    quoteDecimals,
    programId,
    marketProgramId
  }) {
    const id = this.getAssociatedId({ programId, marketId });
    const lpMint = this.getAssociatedLpMint({ programId, marketId });
    const { publicKey: authority, nonce } = this.getAssociatedAuthority({ programId });
    const baseVault = this.getAssociatedBaseVault({ programId, marketId });
    const quoteVault = this.getAssociatedQuoteVault({ programId, marketId });
    const lpVault = this.getAssociatedLpVault({ programId, marketId });
    const openOrders = this.getAssociatedOpenOrders({ programId, marketId });
    const targetOrders = this.getAssociatedTargetOrders({ programId, marketId });
    const withdrawQueue = this.getAssociatedWithdrawQueue({ programId, marketId });
    const { publicKey: marketAuthority } = Market.getAssociatedAuthority({
      programId: marketProgramId,
      marketId
    });
    return {
      // base
      id,
      baseMint,
      quoteMint,
      lpMint,
      baseDecimals,
      quoteDecimals,
      lpDecimals: baseDecimals,
      // version
      version: version2,
      programId,
      // keys
      authority,
      nonce,
      baseVault,
      quoteVault,
      lpVault,
      openOrders,
      targetOrders,
      withdrawQueue,
      // market version
      marketVersion,
      marketProgramId,
      // market keys
      marketId,
      marketAuthority,
      lookupTableAccount: PublicKey.default,
      configId: this.getAssociatedConfigId({ programId })
    };
  }
  static getCreatePoolFee(_0) {
    return __async(this, arguments, function* ({ connection, programId }) {
      const configId = this.getAssociatedConfigId({ programId });
      const layout = struct50([u642("fee")]);
      const account = yield connection.getAccountInfo(configId, { dataSlice: { offset: 536, length: 8 } });
      if (account === null) throw Error("get config account error");
      return layout.decode(account.data).fee;
    });
  }
  /* ================= make instruction and transaction ================= */
  static makeAddLiquidityInstruction(params) {
    const { poolKeys, userKeys, baseAmountIn, quoteAmountIn, fixedSide } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 4 || version2 === 5) {
      const LAYOUT = struct50([u8210("instruction"), u642("baseAmountIn"), u642("quoteAmountIn"), u642("fixedSide")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 3,
          baseAmountIn: parseBigNumberish(baseAmountIn),
          quoteAmountIn: parseBigNumberish(quoteAmountIn),
          fixedSide: parseBigNumberish(fixedSide === "base" ? 0 : 1)
        },
        data
      );
      const keys = [
        // system
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        // amm
        AccountMeta(poolKeys.id, false),
        AccountMetaReadonly(poolKeys.authority, false),
        AccountMetaReadonly(poolKeys.openOrders, false),
        AccountMeta(poolKeys.targetOrders, false),
        AccountMeta(poolKeys.lpMint, false),
        AccountMeta(poolKeys.baseVault, false),
        AccountMeta(poolKeys.quoteVault, false)
      ];
      if (version2 === 5) {
        keys.push(AccountMeta(ModelDataPubkey, false));
      }
      keys.push(
        // serum
        AccountMetaReadonly(poolKeys.marketId, false),
        // user
        AccountMeta(userKeys.baseTokenAccount, false),
        AccountMeta(userKeys.quoteTokenAccount, false),
        AccountMeta(userKeys.lpTokenAccount, false),
        AccountMetaReadonly(userKeys.owner, true),
        AccountMetaReadonly(poolKeys.marketEventQueue, false)
      );
      return {
        address: {},
        innerTransaction: {
          instructions: [
            new TransactionInstruction({
              programId: poolKeys.programId,
              keys,
              data
            })
          ],
          signers: [],
          lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default)),
          instructionTypes: [
            version2 === 4 ? 22 : 30
            /* ammV5AddLiquidity */
          ]
        }
      };
    }
    return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeAddLiquidityInstructionSimple(params) {
    return __async(this, null, function* () {
      const {
        connection,
        poolKeys,
        userKeys,
        amountInA,
        amountInB,
        fixedSide,
        config: config2,
        makeTxVersion,
        lookupTableCache,
        computeBudgetConfig
      } = params;
      const { lpMint } = poolKeys;
      const { tokenAccounts, owner, payer = owner } = userKeys;
      logger11.debug("amountInA:", amountInA);
      logger11.debug("amountInB:", amountInB);
      logger11.assertArgument(
        !amountInA.isZero() && !amountInB.isZero(),
        "amounts must greater than zero",
        "amountInA & amountInB",
        {
          amountInA: amountInA.toFixed(),
          amountInB: amountInB.toFixed()
        }
      );
      const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config2);
      const tokenA = amountInA instanceof TokenAmount ? amountInA.token : Token.WSOL;
      const tokenB = amountInB instanceof TokenAmount ? amountInB.token : Token.WSOL;
      const tokenAccountA = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: tokenA.mint,
        owner,
        config: { associatedOnly: false }
      });
      const tokenAccountB = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: tokenB.mint,
        owner,
        config: { associatedOnly: false }
      });
      logger11.assertArgument(
        !!tokenAccountA || !!tokenAccountB,
        "cannot found target token accounts",
        "tokenAccounts",
        tokenAccounts
      );
      const lpTokenAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: lpMint,
        owner
      });
      const tokens = [tokenA, tokenB];
      const _tokenAccounts = [tokenAccountA, tokenAccountB];
      const rawAmounts = [amountInA.raw, amountInB.raw];
      const [sideA] = this._getAmountsSide(amountInA, amountInB, poolKeys);
      let _fixedSide = "base";
      if (sideA === "quote") {
        tokens.reverse();
        _tokenAccounts.reverse();
        rawAmounts.reverse();
        if (fixedSide === "a") _fixedSide = "quote";
        else if (fixedSide === "b") _fixedSide = "base";
        else return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
      } else if (sideA === "base") {
        if (fixedSide === "a") _fixedSide = "base";
        else if (fixedSide === "b") _fixedSide = "quote";
        else return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
      } else return logger11.throwArgumentError("invalid fixedSide", "fixedSide", fixedSide);
      const [baseToken, quoteToken] = tokens;
      const [baseTokenAccount, quoteTokenAccount] = _tokenAccounts;
      const [baseAmountRaw, quoteAmountRaw] = rawAmounts;
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const _baseTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "in",
        amount: baseAmountRaw,
        mint: baseToken.mint,
        tokenAccount: baseTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        endInstructionsType,
        checkCreateATAOwner
      });
      const _quoteTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "in",
        amount: quoteAmountRaw,
        mint: quoteToken.mint,
        tokenAccount: quoteTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        endInstructionsType,
        checkCreateATAOwner
      });
      const _lpTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "out",
        amount: 0,
        mint: lpMint,
        tokenAccount: lpTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        endInstructionsType,
        checkCreateATAOwner
      });
      const ins = this.makeAddLiquidityInstruction({
        poolKeys,
        userKeys: {
          baseTokenAccount: _baseTokenAccount,
          quoteTokenAccount: _quoteTokenAccount,
          lpTokenAccount: _lpTokenAccount,
          owner
        },
        baseAmountIn: baseAmountRaw,
        quoteAmountIn: quoteAmountRaw,
        fixedSide: _fixedSide
      });
      return {
        address: {
          lpTokenAccount: _lpTokenAccount
        },
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeRemoveLiquidityInstruction(params) {
    const { poolKeys, userKeys, amountIn } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 4 || version2 === 5) {
      const LAYOUT = struct50([u8210("instruction"), u642("amountIn")]);
      const data = Buffer.alloc(LAYOUT.span);
      LAYOUT.encode(
        {
          instruction: 4,
          amountIn: parseBigNumberish(amountIn)
        },
        data
      );
      const keys = [
        // system
        AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
        // amm
        AccountMeta(poolKeys.id, false),
        AccountMetaReadonly(poolKeys.authority, false),
        AccountMeta(poolKeys.openOrders, false),
        AccountMeta(poolKeys.targetOrders, false),
        AccountMeta(poolKeys.lpMint, false),
        AccountMeta(poolKeys.baseVault, false),
        AccountMeta(poolKeys.quoteVault, false)
      ];
      if (version2 === 5) {
        keys.push(AccountMeta(ModelDataPubkey, false));
      } else {
        keys.push(AccountMeta(poolKeys.withdrawQueue, false));
        keys.push(AccountMeta(poolKeys.lpVault, false));
      }
      keys.push(
        // serum
        AccountMetaReadonly(poolKeys.marketProgramId, false),
        AccountMeta(poolKeys.marketId, false),
        AccountMeta(poolKeys.marketBaseVault, false),
        AccountMeta(poolKeys.marketQuoteVault, false),
        AccountMetaReadonly(poolKeys.marketAuthority, false),
        // user
        AccountMeta(userKeys.lpTokenAccount, false),
        AccountMeta(userKeys.baseTokenAccount, false),
        AccountMeta(userKeys.quoteTokenAccount, false),
        AccountMetaReadonly(userKeys.owner, true),
        // serum orderbook
        AccountMeta(poolKeys.marketEventQueue, false),
        AccountMeta(poolKeys.marketBids, false),
        AccountMeta(poolKeys.marketAsks, false)
      );
      return {
        address: {},
        innerTransaction: {
          instructions: [
            new TransactionInstruction({
              programId: poolKeys.programId,
              keys,
              data
            })
          ],
          signers: [],
          lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default)),
          instructionTypes: [
            version2 === 4 ? 23 : 31
            /* ammV5RemoveLiquidity */
          ]
        }
      };
    }
    return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeRemoveLiquidityInstructionSimple(params) {
    return __async(this, null, function* () {
      const { connection, poolKeys, userKeys, amountIn, config: config2, makeTxVersion, lookupTableCache, computeBudgetConfig } = params;
      const { baseMint, quoteMint, lpMint } = poolKeys;
      const { tokenAccounts, owner, payer = owner } = userKeys;
      logger11.debug("amountIn:", amountIn);
      logger11.assertArgument(!amountIn.isZero(), "amount must greater than zero", "amountIn", amountIn.toFixed());
      logger11.assertArgument(
        amountIn instanceof TokenAmount && amountIn.token.mint.equals(lpMint),
        "amountIn's token not match lpMint",
        "amountIn",
        amountIn
      );
      const lpTokenAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: lpMint,
        owner,
        config: { associatedOnly: false }
      });
      if (!lpTokenAccount) return logger11.throwArgumentError("cannot found lpTokenAccount", "tokenAccounts", tokenAccounts);
      const baseTokenAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: baseMint,
        owner
      });
      const quoteTokenAccount = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: quoteMint,
        owner
      });
      const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config2);
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const _lpTokenAccount = lpTokenAccount;
      const _baseTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "out",
        amount: 0,
        mint: baseMint,
        tokenAccount: baseTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        checkCreateATAOwner
      });
      const _quoteTokenAccount = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "out",
        amount: 0,
        mint: quoteMint,
        tokenAccount: quoteTokenAccount,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        checkCreateATAOwner
      });
      const ins = this.makeRemoveLiquidityInstruction({
        poolKeys,
        userKeys: {
          lpTokenAccount: _lpTokenAccount,
          baseTokenAccount: _baseTokenAccount,
          quoteTokenAccount: _quoteTokenAccount,
          owner
        },
        amountIn: amountIn.raw
      });
      return {
        address: {
          lpTokenAccount: _lpTokenAccount
        },
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSwapInstruction(params) {
    const { poolKeys, userKeys, amountIn, amountOut, fixedSide } = params;
    const { version: version2 } = poolKeys;
    if (version2 === 4 || version2 === 5) {
      if (fixedSide === "in") {
        return this.makeSwapFixedInInstruction(
          {
            poolKeys,
            userKeys,
            amountIn,
            minAmountOut: amountOut
          },
          version2
        );
      } else if (fixedSide === "out") {
        return this.makeSwapFixedOutInstruction(
          {
            poolKeys,
            userKeys,
            maxAmountIn: amountIn,
            amountOut
          },
          version2
        );
      }
      return logger11.throwArgumentError("invalid params", "params", params);
    }
    return logger11.throwArgumentError("invalid version", "poolKeys.version", version2);
  }
  static makeSwapFixedInInstruction({ poolKeys, userKeys, amountIn, minAmountOut }, version2) {
    const LAYOUT = struct50([u8210("instruction"), u642("amountIn"), u642("minAmountOut")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 9,
        amountIn: parseBigNumberish(amountIn),
        minAmountOut: parseBigNumberish(minAmountOut)
      },
      data
    );
    const keys = [
      // system
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      // amm
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(poolKeys.openOrders, false)
    ];
    if (version2 === 4) {
      keys.push(AccountMeta(poolKeys.targetOrders, false));
    }
    keys.push(AccountMeta(poolKeys.baseVault, false), AccountMeta(poolKeys.quoteVault, false));
    if (version2 === 5) {
      keys.push(AccountMeta(ModelDataPubkey, false));
    }
    keys.push(
      // serum
      AccountMetaReadonly(poolKeys.marketProgramId, false),
      AccountMeta(poolKeys.marketId, false),
      AccountMeta(poolKeys.marketBids, false),
      AccountMeta(poolKeys.marketAsks, false),
      AccountMeta(poolKeys.marketEventQueue, false),
      AccountMeta(poolKeys.marketBaseVault, false),
      AccountMeta(poolKeys.marketQuoteVault, false),
      AccountMetaReadonly(poolKeys.marketAuthority, false),
      // user
      AccountMeta(userKeys.tokenAccountIn, false),
      AccountMeta(userKeys.tokenAccountOut, false),
      AccountMetaReadonly(userKeys.owner, true)
    );
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default)),
        instructionTypes: [
          version2 === 4 ? 25 : 33
          /* ammV5SwapBaseIn */
        ]
      }
    };
  }
  static makeSwapFixedOutInstruction({ poolKeys, userKeys, maxAmountIn, amountOut }, version2) {
    const LAYOUT = struct50([u8210("instruction"), u642("maxAmountIn"), u642("amountOut")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 11,
        maxAmountIn: parseBigNumberish(maxAmountIn),
        amountOut: parseBigNumberish(amountOut)
      },
      data
    );
    const keys = [
      // system
      AccountMetaReadonly(TOKEN_PROGRAM_ID, false),
      // amm
      AccountMeta(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMeta(poolKeys.openOrders, false),
      AccountMeta(poolKeys.targetOrders, false),
      AccountMeta(poolKeys.baseVault, false),
      AccountMeta(poolKeys.quoteVault, false)
    ];
    if (version2 === 5) {
      keys.push(AccountMeta(ModelDataPubkey, false));
    }
    keys.push(
      // serum
      AccountMetaReadonly(poolKeys.marketProgramId, false),
      AccountMeta(poolKeys.marketId, false),
      AccountMeta(poolKeys.marketBids, false),
      AccountMeta(poolKeys.marketAsks, false),
      AccountMeta(poolKeys.marketEventQueue, false),
      AccountMeta(poolKeys.marketBaseVault, false),
      AccountMeta(poolKeys.marketQuoteVault, false),
      AccountMetaReadonly(poolKeys.marketAuthority, false),
      // user
      AccountMeta(userKeys.tokenAccountIn, false),
      AccountMeta(userKeys.tokenAccountOut, false),
      AccountMetaReadonly(userKeys.owner, true)
    );
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default)),
        instructionTypes: [
          version2 === 4 ? 26 : 34
          /* ammV5SwapBaseOut */
        ]
      }
    };
  }
  static makeSwapInstructionSimple(params) {
    return __async(this, null, function* () {
      const {
        connection,
        poolKeys,
        userKeys,
        amountIn,
        amountOut,
        fixedSide,
        config: config2,
        makeTxVersion,
        lookupTableCache,
        computeBudgetConfig
      } = params;
      const { tokenAccounts, owner, payer = owner } = userKeys;
      logger11.debug("amountIn:", amountIn);
      logger11.debug("amountOut:", amountOut);
      logger11.assertArgument(
        !amountIn.isZero() && !amountOut.isZero(),
        "amounts must greater than zero",
        "currencyAmounts",
        {
          amountIn: amountIn.toFixed(),
          amountOut: amountOut.toFixed()
        }
      );
      const { bypassAssociatedCheck, checkCreateATAOwner } = __spreadValues(__spreadValues({}, { bypassAssociatedCheck: false, checkCreateATAOwner: false }), config2);
      const tokenIn = amountIn instanceof TokenAmount ? amountIn.token : Token.WSOL;
      const tokenOut = amountOut instanceof TokenAmount ? amountOut.token : Token.WSOL;
      const tokenAccountIn = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: tokenIn.mint,
        owner,
        config: { associatedOnly: false }
      });
      const tokenAccountOut = this._selectTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        tokenAccounts,
        mint: tokenOut.mint,
        owner
      });
      const [amountInRaw, amountOutRaw] = [amountIn.raw, amountOut.raw];
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const _tokenAccountIn = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "in",
        amount: amountInRaw,
        mint: tokenIn.mint,
        tokenAccount: tokenAccountIn,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        checkCreateATAOwner
      });
      const _tokenAccountOut = yield this._handleTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        connection,
        side: "out",
        amount: 0,
        mint: tokenOut.mint,
        tokenAccount: tokenAccountOut,
        owner,
        payer,
        frontInstructions,
        endInstructions,
        signers,
        bypassAssociatedCheck,
        frontInstructionsType,
        checkCreateATAOwner
      });
      const ins = this.makeSwapInstruction({
        poolKeys,
        userKeys: {
          tokenAccountIn: _tokenAccountIn,
          tokenAccountOut: _tokenAccountOut,
          owner
        },
        amountIn: amountInRaw,
        amountOut: amountOutRaw,
        fixedSide
      });
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeSimulatePoolInfoInstruction({ poolKeys }) {
    const LAYOUT = struct50([u8210("instruction"), u8210("simulateType")]);
    const data = Buffer.alloc(LAYOUT.span);
    LAYOUT.encode(
      {
        instruction: 12,
        simulateType: 0
      },
      data
    );
    const keys = [
      // amm
      AccountMetaReadonly(poolKeys.id, false),
      AccountMetaReadonly(poolKeys.authority, false),
      AccountMetaReadonly(poolKeys.openOrders, false),
      AccountMetaReadonly(poolKeys.baseVault, false),
      AccountMetaReadonly(poolKeys.quoteVault, false),
      AccountMetaReadonly(poolKeys.lpMint, false),
      // serum
      AccountMetaReadonly(poolKeys.marketId, false),
      AccountMetaReadonly(poolKeys.marketEventQueue, false)
    ];
    return {
      address: {},
      innerTransaction: {
        instructions: [
          new TransactionInstruction({
            programId: poolKeys.programId,
            keys,
            data
          })
        ],
        signers: [],
        lookupTableAddress: [poolKeys.lookupTableAccount].filter((i) => i && !i.equals(PublicKey.default)),
        instructionTypes: [
          poolKeys.version === 4 ? 24 : 32
          /* ammV5SimulatePoolInfo */
        ]
      }
    };
  }
  static isV4(lsl) {
    return lsl.withdrawQueue !== void 0;
  }
  static makeCreatePoolV4InstructionV2Simple(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      marketInfo,
      baseMintInfo,
      quoteMintInfo,
      baseAmount,
      quoteAmount,
      startTime,
      ownerInfo,
      associatedOnly = false,
      computeBudgetConfig,
      checkCreateATAOwner = false,
      makeTxVersion,
      lookupTableCache,
      feeDestinationId
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintAUseSOLBalance = ownerInfo.useSOLBalance && baseMintInfo.mint.equals(Token.WSOL.mint);
      const mintBUseSOLBalance = ownerInfo.useSOLBalance && quoteMintInfo.mint.equals(Token.WSOL.mint);
      const ownerTokenAccountBase = yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: baseMintInfo.mint,
        tokenAccounts: mintAUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintAUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: baseAmount,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintAUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintAUseSOLBalance ? endInstructionsType : [],
          signers
        } : void 0,
        associatedOnly: mintAUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      const ownerTokenAccountQuote = yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: quoteMintInfo.mint,
        tokenAccounts: mintBUseSOLBalance ? [] : ownerInfo.tokenAccounts,
        owner: ownerInfo.wallet,
        createInfo: mintBUseSOLBalance ? {
          connection,
          payer: ownerInfo.feePayer,
          amount: quoteAmount,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintBUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintBUseSOLBalance ? endInstructionsType : [],
          signers
        } : void 0,
        associatedOnly: mintBUseSOLBalance ? false : associatedOnly,
        checkCreateATAOwner
      });
      if (ownerTokenAccountBase === void 0 || ownerTokenAccountQuote === void 0)
        throw Error("you don't has some token account");
      const poolInfo = _Liquidity2.getAssociatedPoolKeys({
        version: 4,
        marketVersion: 3,
        marketId: marketInfo.marketId,
        baseMint: baseMintInfo.mint,
        quoteMint: quoteMintInfo.mint,
        baseDecimals: baseMintInfo.decimals,
        quoteDecimals: quoteMintInfo.decimals,
        programId,
        marketProgramId: marketInfo.programId
      });
      const ins = this.makeCreatePoolV4InstructionV2({
        programId,
        ammId: poolInfo.id,
        ammAuthority: poolInfo.authority,
        ammOpenOrders: poolInfo.openOrders,
        lpMint: poolInfo.lpMint,
        coinMint: poolInfo.baseMint,
        pcMint: poolInfo.quoteMint,
        coinVault: poolInfo.baseVault,
        pcVault: poolInfo.quoteVault,
        ammTargetOrders: poolInfo.targetOrders,
        marketProgramId: poolInfo.marketProgramId,
        marketId: poolInfo.marketId,
        userWallet: ownerInfo.wallet,
        userCoinVault: ownerTokenAccountBase,
        userPcVault: ownerTokenAccountQuote,
        userLpVault: getATAAddress(ownerInfo.wallet, poolInfo.lpMint, TOKEN_PROGRAM_ID).publicKey,
        ammConfigId: poolInfo.configId,
        feeDestinationId,
        nonce: poolInfo.nonce,
        openTime: startTime,
        coinAmount: baseAmount,
        pcAmount: quoteAmount
      }).innerTransaction;
      return {
        address: {
          programId,
          ammId: poolInfo.id,
          ammAuthority: poolInfo.authority,
          ammOpenOrders: poolInfo.openOrders,
          lpMint: poolInfo.lpMint,
          coinMint: poolInfo.baseMint,
          pcMint: poolInfo.quoteMint,
          coinVault: poolInfo.baseVault,
          pcVault: poolInfo.quoteVault,
          withdrawQueue: poolInfo.withdrawQueue,
          ammTargetOrders: poolInfo.targetOrders,
          poolTempLp: poolInfo.lpVault,
          marketProgramId: poolInfo.marketProgramId,
          marketId: poolInfo.marketId
        },
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.feePayer,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ins,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeCreatePoolV4InstructionV2({
    programId,
    ammId,
    ammAuthority,
    ammOpenOrders,
    lpMint,
    coinMint,
    pcMint,
    coinVault,
    pcVault,
    ammTargetOrders,
    marketProgramId,
    marketId,
    userWallet,
    userCoinVault,
    userPcVault,
    userLpVault,
    nonce,
    openTime,
    coinAmount,
    pcAmount,
    lookupTableAddress,
    ammConfigId,
    feeDestinationId
  }) {
    const dataLayout = struct50([u8210("instruction"), u8210("nonce"), u642("openTime"), u642("pcAmount"), u642("coinAmount")]);
    const keys = [
      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: RENT_PROGRAM_ID, isSigner: false, isWritable: false },
      { pubkey: ammId, isSigner: false, isWritable: true },
      { pubkey: ammAuthority, isSigner: false, isWritable: false },
      { pubkey: ammOpenOrders, isSigner: false, isWritable: true },
      { pubkey: lpMint, isSigner: false, isWritable: true },
      { pubkey: coinMint, isSigner: false, isWritable: false },
      { pubkey: pcMint, isSigner: false, isWritable: false },
      { pubkey: coinVault, isSigner: false, isWritable: true },
      { pubkey: pcVault, isSigner: false, isWritable: true },
      { pubkey: ammTargetOrders, isSigner: false, isWritable: true },
      { pubkey: ammConfigId, isSigner: false, isWritable: false },
      { pubkey: feeDestinationId, isSigner: false, isWritable: true },
      { pubkey: marketProgramId, isSigner: false, isWritable: false },
      { pubkey: marketId, isSigner: false, isWritable: false },
      { pubkey: userWallet, isSigner: true, isWritable: true },
      { pubkey: userCoinVault, isSigner: false, isWritable: true },
      { pubkey: userPcVault, isSigner: false, isWritable: true },
      { pubkey: userLpVault, isSigner: false, isWritable: true }
    ];
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({ instruction: 1, nonce, openTime, coinAmount, pcAmount }, data);
    const ins = new TransactionInstruction({
      keys,
      programId,
      data
    });
    return {
      address: {},
      innerTransaction: {
        instructions: [ins],
        signers: [],
        lookupTableAddress: lookupTableAddress ? [lookupTableAddress] : void 0,
        instructionTypes: [
          29
          /* ammV4CreatePoolV2 */
        ]
      }
    };
  }
  static makeRemoveAllLpAndCreateClmmPosition(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolKeys,
      removeLpAmount,
      userKeys,
      clmmPoolKeys,
      createPositionInfo,
      farmInfo,
      computeBudgetConfig,
      checkCreateATAOwner = false,
      getEphemeralSigners,
      makeTxVersion,
      lookupTableCache
    }) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!(poolKeys.baseMint.equals(clmmPoolKeys.mintA.mint) || poolKeys.baseMint.equals(clmmPoolKeys.mintB.mint)))
        throw Error("mint check error");
      if (!(poolKeys.quoteMint.equals(clmmPoolKeys.mintA.mint) || poolKeys.quoteMint.equals(clmmPoolKeys.mintB.mint)))
        throw Error("mint check error");
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const mintToAccount = {};
      for (const item of userKeys.tokenAccounts) {
        if (mintToAccount[item.accountInfo.mint.toString()] === void 0 || getATAAddress(userKeys.owner, item.accountInfo.mint, TOKEN_PROGRAM_ID).publicKey.equals(item.pubkey)) {
          mintToAccount[item.accountInfo.mint.toString()] = item.pubkey;
        }
      }
      const lpTokenAccount = mintToAccount[poolKeys.lpMint.toString()];
      if (lpTokenAccount === void 0) throw Error("find lp account error in trade accounts");
      const amountIn = removeLpAmount.add((_a = farmInfo == null ? void 0 : farmInfo.amount) != null ? _a : new import_bn10.default(0));
      const mintBaseUseSOLBalance = poolKeys.baseMint.equals(Token.WSOL.mint);
      const mintQuoteUseSOLBalance = poolKeys.quoteMint.equals(Token.WSOL.mint);
      const baseTokenAccount = yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: poolKeys.baseMint,
        tokenAccounts: userKeys.tokenAccounts,
        owner: userKeys.owner,
        createInfo: {
          connection,
          payer: (_b = userKeys.payer) != null ? _b : userKeys.owner,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintBaseUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintBaseUseSOLBalance ? endInstructionsType : [],
          signers
        },
        associatedOnly: true,
        checkCreateATAOwner
      });
      const quoteTokenAccount = yield this._selectOrCreateTokenAccount({
        programId: TOKEN_PROGRAM_ID,
        mint: poolKeys.quoteMint,
        tokenAccounts: userKeys.tokenAccounts,
        owner: userKeys.owner,
        createInfo: {
          connection,
          payer: (_c = userKeys.payer) != null ? _c : userKeys.owner,
          amount: 0,
          frontInstructions,
          frontInstructionsType,
          endInstructions: mintQuoteUseSOLBalance ? endInstructions : [],
          endInstructionsType: mintQuoteUseSOLBalance ? endInstructionsType : [],
          signers
        },
        associatedOnly: true,
        checkCreateATAOwner
      });
      mintToAccount[poolKeys.baseMint.toString()] = baseTokenAccount;
      mintToAccount[poolKeys.quoteMint.toString()] = quoteTokenAccount;
      const removeIns = this.makeRemoveLiquidityInstruction({
        poolKeys,
        userKeys: {
          lpTokenAccount,
          baseTokenAccount,
          quoteTokenAccount,
          owner: userKeys.owner
        },
        amountIn
      });
      const [tokenAccountA, tokenAccountB] = poolKeys.baseMint.equals(clmmPoolKeys.mintA.mint) ? [baseTokenAccount, quoteTokenAccount] : [quoteTokenAccount, baseTokenAccount];
      const createPositionIns = yield Clmm.makeOpenPositionFromLiquidityInstructions(__spreadProps(__spreadValues({
        poolInfo: clmmPoolKeys,
        ownerInfo: {
          feePayer: (_d = userKeys.payer) != null ? _d : userKeys.owner,
          wallet: userKeys.owner,
          tokenAccountA,
          tokenAccountB
        },
        withMetadata: "create"
      }, createPositionInfo), {
        getEphemeralSigners
      }));
      let withdrawFarmIns = {
        instructions: [],
        signers: [],
        instructionTypes: []
      };
      if (farmInfo !== void 0) {
        const rewardTokenAccounts = [];
        for (const item of farmInfo.poolKeys.rewardInfos) {
          const rewardIsWsol = item.rewardMint.equals(Token.WSOL.mint);
          rewardTokenAccounts.push(
            (_f = mintToAccount[item.rewardMint.toString()]) != null ? _f : yield this._selectOrCreateTokenAccount({
              programId: TOKEN_PROGRAM_ID,
              mint: item.rewardMint,
              tokenAccounts: userKeys.tokenAccounts,
              owner: userKeys.owner,
              createInfo: {
                connection,
                payer: (_e = userKeys.payer) != null ? _e : userKeys.owner,
                frontInstructions,
                frontInstructionsType,
                endInstructions: rewardIsWsol ? endInstructions : [],
                endInstructionsType: rewardIsWsol ? endInstructionsType : [],
                signers
              },
              associatedOnly: true,
              checkCreateATAOwner
            })
          );
        }
        withdrawFarmIns = Farm.makeWithdrawInstruction({
          poolKeys: farmInfo.poolKeys,
          amount: farmInfo.amount,
          userKeys: {
            ledger: Farm.getAssociatedLedgerAccount({
              programId: farmInfo.poolKeys.programId,
              poolId: farmInfo.poolKeys.id,
              owner: userKeys.owner,
              version: farmInfo.poolKeys.version
            }),
            lpTokenAccount,
            rewardTokenAccounts,
            owner: userKeys.owner
          }
        }).innerTransaction;
      }
      return {
        address: __spreadValues(__spreadValues({}, removeIns.address), createPositionIns.address),
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: (_g = userKeys.payer) != null ? _g : userKeys.owner,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            withdrawFarmIns,
            removeIns.innerTransaction,
            createPositionIns.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  /* ================= fetch data ================= */
  /**
   * Fetch all pools keys from on-chain data
   */
  static fetchAllPoolKeys(connection, programId, config2) {
    return __async(this, null, function* () {
      const allPools = (yield Promise.all(
        Object.entries(LIQUIDITY_VERSION_TO_STATE_LAYOUT).map(([version2, layout]) => {
          try {
            return connection.getProgramAccounts(programId[Number(version2)], {
              filters: [{ dataSize: layout.span }]
            }).then((accounts) => {
              return accounts.map((info) => {
                return __spreadValues({
                  id: info.pubkey,
                  version: Number(version2),
                  programId: programId[Number(version2)]
                }, layout.decode(info.account.data));
              });
            });
          } catch (error) {
            if (error instanceof Error) {
              return logger11.throwError("failed to fetch pool info", Logger.errors.RPC_ERROR, {
                message: error.message
              });
            }
          }
        })
      )).flat();
      const allMarketIds = allPools.map((i) => i.marketId);
      const marketsInfo = {};
      try {
        const _marketsInfo = yield getMultipleAccountsInfo(connection, allMarketIds, config2);
        for (const item of _marketsInfo) {
          if (item === null) continue;
          const _i = __spreadValues({ programId: item.owner }, MARKET_STATE_LAYOUT_V3.decode(item.data));
          marketsInfo[_i.ownAddress.toString()] = _i;
        }
      } catch (error) {
        if (error instanceof Error) {
          return logger11.throwError("failed to fetch markets", Logger.errors.RPC_ERROR, {
            message: error.message
          });
        }
      }
      const authority = {};
      for (const [version2, _programId] of Object.entries(programId))
        authority[version2] = this.getAssociatedAuthority({ programId: _programId }).publicKey;
      const formatPoolInfos = [];
      for (const pool of allPools) {
        if (pool === void 0) continue;
        if (pool.baseMint.equals(PublicKey.default)) continue;
        const market = marketsInfo[pool.marketId.toString()];
        const marketProgramId = market.programId;
        formatPoolInfos.push(__spreadProps(__spreadValues({
          id: pool.id,
          baseMint: pool.baseMint,
          quoteMint: pool.quoteMint,
          lpMint: pool.lpMint,
          baseDecimals: pool.baseDecimal.toNumber(),
          quoteDecimals: pool.quoteDecimal.toNumber(),
          lpDecimals: pool.id.toString() === "6kmMMacvoCKBkBrqssLEdFuEZu2wqtLdNQxh9VjtzfwT" ? 5 : pool.baseDecimal.toNumber(),
          version: pool.version,
          programId: pool.programId,
          authority: authority[pool.version],
          openOrders: pool.openOrders,
          targetOrders: pool.targetOrders,
          baseVault: pool.baseVault,
          quoteVault: pool.quoteVault,
          marketVersion: 3,
          marketProgramId,
          marketId: market.ownAddress,
          marketAuthority: Market.getAssociatedAuthority({
            programId: marketProgramId,
            marketId: market.ownAddress
          }).publicKey,
          marketBaseVault: market.baseVault,
          marketQuoteVault: market.quoteVault,
          marketBids: market.bids,
          marketAsks: market.asks,
          marketEventQueue: market.eventQueue
        }, pool.version === 5 ? {
          modelDataAccount: pool.modelDataAccount,
          withdrawQueue: PublicKey.default,
          lpVault: PublicKey.default
        } : {
          withdrawQueue: pool.withdrawQueue,
          lpVault: pool.lpVault
        }), {
          lookupTableAccount: PublicKey.default
        }));
      }
      return formatPoolInfos;
    });
  }
  /**
   * Fetch liquidity pool's info
   */
  static fetchInfo(_0) {
    return __async(this, arguments, function* ({ connection, poolKeys }) {
      const info = yield this.fetchMultipleInfo({ connection, pools: [poolKeys] });
      logger11.assertArgument(info.length === 1, `fetchInfo failed, ${info.length} pools found`, "poolKeys.id", poolKeys.id);
      return info[0];
    });
  }
  /**
   * Fetch multiple info of liquidity pools
   */
  static fetchMultipleInfo(_0) {
    return __async(this, arguments, function* ({
      connection,
      pools,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      config: config2
    }) {
      yield initStableModelLayout(connection);
      const instructions = pools.map((pool) => this.makeSimulatePoolInfoInstruction({ poolKeys: pool }));
      const logs = yield simulateMultipleInstruction(
        connection,
        instructions.map((i) => i.innerTransaction.instructions).flat(),
        "GetPoolData"
      );
      const poolsInfo = logs.map((log3) => {
        const json = parseSimulateLogToJson(log3, "GetPoolData");
        const status = new import_bn10.default(parseSimulateValue(json, "status"));
        const baseDecimals = Number(parseSimulateValue(json, "coin_decimals"));
        const quoteDecimals = Number(parseSimulateValue(json, "pc_decimals"));
        const lpDecimals = Number(parseSimulateValue(json, "lp_decimals"));
        const baseReserve = new import_bn10.default(parseSimulateValue(json, "pool_coin_amount"));
        const quoteReserve = new import_bn10.default(parseSimulateValue(json, "pool_pc_amount"));
        const lpSupply = new import_bn10.default(parseSimulateValue(json, "pool_lp_supply"));
        let startTime = "0";
        try {
          startTime = parseSimulateValue(json, "pool_open_time");
        } catch (error) {
        }
        return {
          status,
          baseDecimals,
          quoteDecimals,
          lpDecimals,
          baseReserve,
          quoteReserve,
          lpSupply,
          startTime: new import_bn10.default(startTime)
        };
      });
      return poolsInfo;
    });
  }
  /* ================= compute data ================= */
  static getEnabledFeatures(poolInfo) {
    const { status } = poolInfo;
    const _status = status.toNumber();
    if (_status === 0)
      return {
        swap: false,
        addLiquidity: false,
        removeLiquidity: false
      };
    else if (_status === 1)
      return {
        swap: true,
        addLiquidity: true,
        removeLiquidity: true
      };
    else if (_status === 2)
      return {
        swap: false,
        addLiquidity: false,
        removeLiquidity: false
      };
    else if (_status === 3)
      return {
        swap: false,
        addLiquidity: false,
        removeLiquidity: true
      };
    else if (_status === 4)
      return {
        swap: false,
        addLiquidity: true,
        removeLiquidity: true
      };
    else if (_status === 5)
      return {
        swap: false,
        addLiquidity: true,
        removeLiquidity: true
      };
    else if (_status === 6)
      return {
        swap: true,
        addLiquidity: true,
        removeLiquidity: true
      };
    else if (_status === 7) {
      const { startTime } = poolInfo;
      if (Date.now() / 1e3 < startTime.toNumber())
        return {
          swap: false,
          addLiquidity: true,
          removeLiquidity: true
        };
      return {
        swap: true,
        addLiquidity: true,
        removeLiquidity: true
      };
    } else
      return {
        swap: false,
        addLiquidity: false,
        removeLiquidity: false
      };
  }
  static includesToken(token, poolKeys) {
    const { baseMint, quoteMint } = poolKeys;
    return token.mint.equals(baseMint) || token.mint.equals(quoteMint);
  }
  /**
   * Get token side of liquidity pool
   * @param token - the token provided
   * @param poolKeys - the pool keys
   * @returns token side is `base` or `quote`
   */
  static _getTokenSide(token, poolKeys) {
    const { baseMint, quoteMint } = poolKeys;
    if (token.mint.equals(baseMint)) return "base";
    else if (token.mint.equals(quoteMint)) return "quote";
    else
      return logger11.throwArgumentError("token not match with pool", "params", {
        token: token.mint,
        baseMint,
        quoteMint
      });
  }
  /**
   * Get tokens side of liquidity pool
   * @param tokenA - the token provided
   * @param tokenB - the token provided
   * @param poolKeys - the pool keys
   * @returns tokens side array
   */
  static _getTokensSide(tokenA, tokenB, poolKeys) {
    const { baseMint, quoteMint } = poolKeys;
    const sideA = this._getTokenSide(tokenA, poolKeys);
    const sideB = this._getTokenSide(tokenB, poolKeys);
    logger11.assertArgument(sideA !== sideB, "tokens not match with pool", "params", {
      tokenA: tokenA.mint,
      tokenB: tokenB.mint,
      baseMint,
      quoteMint
    });
    return [sideA, sideB];
  }
  /**
   * Get currency amount side of liquidity pool
   * @param amount - the currency amount provided
   * @param poolKeys - the pool keys
   * @returns currency amount side is `base` or `quote`
   */
  static _getAmountSide(amount, poolKeys) {
    const token = amount instanceof TokenAmount ? amount.token : Token.WSOL;
    return this._getTokenSide(token, poolKeys);
  }
  /**
   * Get currencies amount side of liquidity pool
   * @param amountA - the currency amount provided
   * @param amountB - the currency amount provided
   * @param poolKeys - the pool keys
   * @returns currencies amount side array
   */
  static _getAmountsSide(amountA, amountB, poolKeys) {
    const tokenA = amountA instanceof TokenAmount ? amountA.token : Token.WSOL;
    const tokenB = amountB instanceof TokenAmount ? amountB.token : Token.WSOL;
    return this._getTokensSide(tokenA, tokenB, poolKeys);
  }
  /**
   * Compute the another currency amount of add liquidity
   *
   * @param params - {@link LiquidityComputeAnotherAmountParams}
   *
   * @returns
   * anotherCurrencyAmount - currency amount without slippage
   * @returns
   * maxAnotherCurrencyAmount - currency amount with slippage
   *
   * @returns {@link CurrencyAmount}
   *
   * @example
   * ```
   * Liquidity.computeAnotherAmount({
   *   // 1%
   *   slippage: new Percent(1, 100)
   * })
   * ```
   */
  static computeAnotherAmount({
    poolKeys,
    poolInfo,
    amount,
    anotherCurrency,
    slippage
  }) {
    const { baseReserve, quoteReserve } = poolInfo;
    logger11.debug("baseReserve:", baseReserve.toString());
    logger11.debug("quoteReserve:", quoteReserve.toString());
    const currencyIn = amount instanceof TokenAmount ? amount.token : amount.currency;
    logger11.debug("currencyIn:", currencyIn);
    logger11.debug("amount:", amount.toFixed());
    logger11.debug("anotherCurrency:", anotherCurrency);
    logger11.debug("slippage:", `${slippage.toSignificant()}%`);
    const input = this._getAmountSide(amount, poolKeys);
    logger11.debug("input side:", input);
    let amountRaw = ZERO;
    if (!amount.isZero()) {
      amountRaw = input === "base" ? divCeil(amount.raw.mul(quoteReserve), baseReserve) : divCeil(amount.raw.mul(baseReserve), quoteReserve);
    }
    const liquidity = divCeil(
      amount.raw.mul(poolInfo.lpSupply),
      input === "base" ? poolInfo.baseReserve : poolInfo.quoteReserve
    );
    const _slippage = new Percent(ONE).add(slippage);
    const slippageAdjustedAmount = _slippage.mul(amountRaw).quotient;
    const _anotherAmount = anotherCurrency instanceof Token ? new TokenAmount(anotherCurrency, amountRaw) : new CurrencyAmount(anotherCurrency, amountRaw);
    const _maxAnotherAmount = anotherCurrency instanceof Token ? new TokenAmount(anotherCurrency, slippageAdjustedAmount) : new CurrencyAmount(anotherCurrency, slippageAdjustedAmount);
    logger11.debug("anotheAmount:", _anotherAmount.toFixed());
    logger11.debug("maxAnotheAmount:", _maxAnotherAmount.toFixed());
    return {
      anotherAmount: _anotherAmount,
      maxAnotherAmount: _maxAnotherAmount,
      liquidity
    };
  }
  static _computePriceImpact(currentPrice, amountIn, amountOut) {
    const exactQuote = currentPrice.raw.mul(amountIn);
    const slippage = exactQuote.sub(amountOut).div(exactQuote);
    return new Percent(slippage.numerator, slippage.denominator);
  }
  static getRate(poolInfo) {
    const { baseReserve, quoteReserve, baseDecimals, quoteDecimals } = poolInfo;
    const price = new Price(new Currency(baseDecimals), baseReserve, new Currency(quoteDecimals), quoteReserve);
    return price;
  }
  /**
   * Compute input currency amount of swap
   *
   * @param params - {@link ComputeCurrencyAmountInParams}
   *
   * @returns
   * amountIn - currency amount without slippage
   * @returns
   * maxAmountIn - currency amount with slippage
   */
  static computeAmountIn({ poolKeys, poolInfo, amountOut, currencyIn, slippage }) {
    const { baseReserve, quoteReserve } = poolInfo;
    logger11.debug("baseReserve:", baseReserve.toString());
    logger11.debug("quoteReserve:", quoteReserve.toString());
    const currencyOut = amountOut instanceof TokenAmount ? amountOut.token : amountOut.currency;
    logger11.debug("currencyOut:", currencyOut);
    logger11.debug("amountOut:", amountOut.toFixed());
    logger11.debug("currencyIn:", currencyIn);
    logger11.debug("slippage:", `${slippage.toSignificant()}%`);
    const reserves = [baseReserve, quoteReserve];
    const output2 = this._getAmountSide(amountOut, poolKeys);
    if (output2 === "base") {
      reserves.reverse();
    }
    logger11.debug("output side:", output2);
    const [reserveIn, reserveOut] = reserves;
    const currentPrice = new Price(currencyIn, reserveIn, currencyOut, reserveOut);
    logger11.debug("currentPrice:", `1 ${currencyIn.symbol}  ${currentPrice.toFixed()} ${currencyOut.symbol}`);
    logger11.debug(
      "currentPrice invert:",
      `1 ${currencyOut.symbol}  ${currentPrice.invert().toFixed()} ${currencyIn.symbol}`
    );
    let amountInRaw = ZERO;
    let amountOutRaw = amountOut.raw;
    if (!amountOutRaw.isZero()) {
      if (amountOutRaw.gt(reserveOut)) {
        amountOutRaw = reserveOut.sub(ONE);
      }
      const denominator = reserveOut.sub(amountOutRaw);
      const amountInWithoutFee = reserveIn.mul(amountOutRaw).div(denominator);
      amountInRaw = amountInWithoutFee.mul(LIQUIDITY_FEES_DENOMINATOR).div(LIQUIDITY_FEES_DENOMINATOR.sub(LIQUIDITY_FEES_NUMERATOR));
    }
    const _slippage = new Percent(ONE).add(slippage);
    const maxAmountInRaw = _slippage.mul(amountInRaw).quotient;
    const amountIn = currencyIn instanceof Token ? new TokenAmount(currencyIn, amountInRaw) : new CurrencyAmount(currencyIn, amountInRaw);
    const maxAmountIn = currencyIn instanceof Token ? new TokenAmount(currencyIn, maxAmountInRaw) : new CurrencyAmount(currencyIn, maxAmountInRaw);
    logger11.debug("amountIn:", amountIn.toFixed());
    logger11.debug("maxAmountIn:", maxAmountIn.toFixed());
    let executionPrice = null;
    if (!amountInRaw.isZero() && !amountOutRaw.isZero()) {
      executionPrice = new Price(currencyIn, amountInRaw, currencyOut, amountOutRaw);
      logger11.debug("executionPrice:", `1 ${currencyIn.symbol}  ${executionPrice.toFixed()} ${currencyOut.symbol}`);
      logger11.debug(
        "executionPrice invert:",
        `1 ${currencyOut.symbol}  ${executionPrice.invert().toFixed()} ${currencyIn.symbol}`
      );
    }
    const priceImpact = this._computePriceImpact(currentPrice, amountInRaw, amountOutRaw);
    logger11.debug("priceImpact:", `${priceImpact.toSignificant()}%`);
    return {
      amountIn,
      maxAmountIn,
      currentPrice,
      executionPrice,
      priceImpact
    };
  }
};
_Liquidity.computeAmountOut = ({
  poolKeys,
  poolInfo,
  amountIn,
  currencyOut,
  slippage
}) => {
  const tokenIn = amountIn instanceof TokenAmount ? amountIn.token : Token.WSOL;
  const tokenOut = currencyOut instanceof Token ? currencyOut : Token.WSOL;
  logger11.assertArgument(
    _Liquidity.includesToken(tokenIn, poolKeys) && _Liquidity.includesToken(tokenOut, poolKeys),
    "token not match with pool",
    "poolKeys",
    { poolKeys, tokenIn, tokenOut }
  );
  const { baseReserve, quoteReserve } = poolInfo;
  logger11.debug("baseReserve:", baseReserve.toString());
  logger11.debug("quoteReserve:", quoteReserve.toString());
  const currencyIn = amountIn instanceof TokenAmount ? amountIn.token : amountIn.currency;
  logger11.debug("currencyIn:", currencyIn);
  logger11.debug("amountIn:", amountIn.toFixed());
  logger11.debug("currencyOut:", currencyOut);
  logger11.debug("slippage:", `${slippage.toSignificant()}%`);
  const reserves = [baseReserve, quoteReserve];
  const input = _Liquidity._getAmountSide(amountIn, poolKeys);
  if (input === "quote") {
    reserves.reverse();
  }
  logger11.debug("input side:", input);
  const [reserveIn, reserveOut] = reserves;
  let currentPrice;
  if (poolKeys.version === 4) {
    currentPrice = new Price(currencyIn, reserveIn, currencyOut, reserveOut);
  } else {
    const p = getStablePrice(modelData, baseReserve.toNumber(), quoteReserve.toNumber(), false);
    if (input === "quote") currentPrice = new Price(currencyIn, new import_bn10.default(p * 1e6), currencyOut, new import_bn10.default(1e6));
    else currentPrice = new Price(currencyIn, new import_bn10.default(1e6), currencyOut, new import_bn10.default(p * 1e6));
  }
  logger11.debug("currentPrice:", `1 ${currencyIn.symbol}  ${currentPrice.toFixed()} ${currencyOut.symbol}`);
  logger11.debug(
    "currentPrice invert:",
    `1 ${currencyOut.symbol}  ${currentPrice.invert().toFixed()} ${currencyIn.symbol}`
  );
  const amountInRaw = amountIn.raw;
  let amountOutRaw = ZERO;
  let feeRaw = ZERO;
  if (!amountInRaw.isZero()) {
    if (poolKeys.version === 4) {
      feeRaw = BNDivCeil(amountInRaw.mul(LIQUIDITY_FEES_NUMERATOR), LIQUIDITY_FEES_DENOMINATOR);
      const amountInWithFee = amountInRaw.sub(feeRaw);
      const denominator = reserveIn.add(amountInWithFee);
      amountOutRaw = reserveOut.mul(amountInWithFee).div(denominator);
    } else {
      feeRaw = amountInRaw.mul(new import_bn10.default(2)).div(new import_bn10.default(1e4));
      const amountInWithFee = amountInRaw.sub(feeRaw);
      if (input === "quote")
        amountOutRaw = new import_bn10.default(
          getDyByDxBaseIn(modelData, quoteReserve.toNumber(), baseReserve.toNumber(), amountInWithFee.toNumber())
        );
      else {
        amountOutRaw = new import_bn10.default(
          getDxByDyBaseIn(modelData, quoteReserve.toNumber(), baseReserve.toNumber(), amountInWithFee.toNumber())
        );
      }
    }
  }
  const _slippage = new Percent(ONE).add(slippage);
  const minAmountOutRaw = _slippage.invert().mul(amountOutRaw).quotient;
  const amountOut = currencyOut instanceof Token ? new TokenAmount(currencyOut, amountOutRaw) : new CurrencyAmount(currencyOut, amountOutRaw);
  const minAmountOut = currencyOut instanceof Token ? new TokenAmount(currencyOut, minAmountOutRaw) : new CurrencyAmount(currencyOut, minAmountOutRaw);
  logger11.debug("amountOut:", amountOut.toFixed());
  logger11.debug("minAmountOut:", minAmountOut.toFixed());
  let executionPrice = new Price(currencyIn, amountInRaw.sub(feeRaw), currencyOut, amountOutRaw);
  if (!amountInRaw.isZero() && !amountOutRaw.isZero()) {
    executionPrice = new Price(currencyIn, amountInRaw.sub(feeRaw), currencyOut, amountOutRaw);
    logger11.debug("executionPrice:", `1 ${currencyIn.symbol}  ${executionPrice.toFixed()} ${currencyOut.symbol}`);
    logger11.debug(
      "executionPrice invert:",
      `1 ${currencyOut.symbol}  ${executionPrice.invert().toFixed()} ${currencyIn.symbol}`
    );
  }
  const priceImpactDenominator = executionPrice.denominator.mul(currentPrice.numerator);
  const priceImpactNumerator = executionPrice.numerator.mul(currentPrice.denominator).sub(priceImpactDenominator).abs();
  const priceImpact = new Percent(priceImpactNumerator, priceImpactDenominator);
  logger11.debug("priceImpact:", `${priceImpact.toSignificant()}%`);
  const fee = currencyIn instanceof Token ? new TokenAmount(currencyIn, feeRaw) : new CurrencyAmount(currencyIn, feeRaw);
  return {
    amountOut,
    minAmountOut,
    currentPrice,
    executionPrice,
    priceImpact,
    fee
  };
};
var Liquidity = _Liquidity;
var MAINNET_OFFICIAL_LIQUIDITY_POOLS = [
  /* ================= v4 ================= */
  // FIDA-RAY
  "2dRNngAm729NzLbb1pzgHtfHvPqR4XHFmFyYK78EfEeX",
  // OXY-RAY
  "B5ZguAWAGC3GXVtJZVfoMtzvEvDnDKBPCevsUKMy4DTZ",
  // MAPS-RAY
  "5VyLSjUvaRxsubirbvbfJMbrKZRx1b7JZzuCAfyqgimf",
  // KIN-RAY
  "6kmMMacvoCKBkBrqssLEdFuEZu2wqtLdNQxh9VjtzfwT",
  // RAY-USDT
  "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut",
  // SOL-USDC
  "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
  // YFI-USDC
  "83xxjVczDseaCzd7D61BRo7LcP7cMXut5n7thhB4rL4d",
  // SRM-USDC
  "8tzS7SkUZyHPQY7gLqsMCXZ5EDCgjESUHcB17tiR1h3Z",
  // FTT-USDC
  "4C2Mz1bVqe42QDDTyJ4HFCFFGsH5YDzo91Cen5w5NGun",
  // BTC-USDC
  "6kbC5epG18DF2DwPEW34tBy5pGFS7pEGALR3v5MGxgc5",
  // SUSHI-USDC
  "5dHEPTgvscKkAc54R77xUeGdgShdG9Mf6gJ9bwBqyb3V",
  // TOMO-USDC
  "8mBJC9qdPNDyrpAbrdwGbBpEAjPqwtvZQVmbnKFXXY2P",
  // LINK-USDC
  "Hr8i6MAm4W5Lwb2fB2CD44A2t3Ag3gGc1rmd6amrWsWC",
  // ETH-USDC
  "AoPebtuJC4f2RweZSxcVCcdeTgaEXY64Uho8b5HdPxAR",
  // xCOPE-USDC
  "3mYsmBQLB8EZSjRwtWjPbbE8LiM1oCCtNZZKiVBKsePa",
  // SOL-USDT
  "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX",
  // YFI-USDT
  "81PmLJ8j2P8CC5EJAAhWGYA4HgJvoKs4Y94ALZF2uKKG",
  // SRM-USDT
  "af8HJg2ffWoKJ6vKvkWJUJ9iWbRR83WgXs8HPs26WGr",
  // FTT-USDT
  "4fgubfZVL6L8tc5x1j65S14P2Tnxr1YayKtKavQV5MBo",
  // BTC-USDT
  "AMMwkf57c7ZsbbDCXvBit9zFehMr1xRn8ZzaT1iDF18o",
  // SUSHI-USDT
  "DWvhPYVogsEKEsehHApUtjhP1UFtApkAPFJqFh2HPmWz",
  // TOMO-USDT
  "GjrXcSvwzGrz1RwKYGVWdbZyXzyotgichSHB95moDmf8",
  // LINK-USDT
  "E9EvurfzdSQaqCFBUaD4MgV93htuRQ93sghm922Pik88",
  // ETH-USDT
  "He3iAEV5rYjv6Xf7PxKro19eVrC3QAcdic5CF2D2obPt",
  // YFI-SRM
  "GDVhJmDTdSExwHeMT5RvUBUNKLwwXNKhH8ndm1tpTv6B",
  // FTT-SRM
  "21r2zeCacmm5YvbGoPZh9ZoGREuodhcbQHaP5tZmzY14",
  // BTC-SRM
  "DvxLb4NnQUYq1gErk35HVt9g8kxjNbviJfiZX1wqraMv",
  // SUSHI-SRM
  "BLVjPTgzyfiKSgDujTNKKNzW2GXx7HhdMxgr2LQ2g83s",
  // TOMO-SRM
  "DkMAuUCQHC6BNgVnjtM5ZTKm1T8MsriQ6bL3Umi6NBtG",
  // LINK-SRM
  "796pvggjoDCPUtUSVFSCLqPRyes5YPvRiu4zFWX582wf",
  // ETH-SRM
  "3XwxHcbyqcd1xkdczaPv3TNCZsevELD4Zux3pu4sF2D8",
  // SRM-SOL
  "EvWJC2mnmu9C9aQrsJLXw8FhUcwBzFEUQsP1E5Y6a5N7",
  // STEP-USDC
  "4Sx1NLrQiK4b9FdLKe2DhQ9FHvRzJhzKN3LoD6BrEPnf",
  // MEDIA-USDC
  "94CQopiGxxUXf2avyMZhAFaBdNatd62ttYGoTVQBRGdi",
  // ROPE-USDC
  "BuS4ScFcZjEBixF1ceCTiXs4rqt4WDfXLoth7VcM2Eoj",
  // MER-USDC
  "BkfGDk676QFtTiGxn7TtEpHayJZRr6LgNk9uTV2MH4bR",
  // COPE-USDC
  "DiWxV1SPXPNJRCt5Ao1mJRAxjw97hJVyj8qGzZwFbAFb",
  // ALEPH-USDC
  "GDHXjn9wF2zxW35DBkCegWQdoTfFBC9LXt7D5ovJxQ5B",
  // TULIP-USDC
  "96hPvuJ3SRT82m7BAc7G1AUVPVcoj8DABAa5gT7wjgzX",
  // WOO-USDC
  "DSkXJYPZqJ3yHQECyVyh3xiE3HBrt7ARmepwNDA9rREn",
  // SNY-USDC
  "5TgJXpv6H3KJhHCuP7KoDLSCmi8sM8nABizP7CmYAKm1",
  // BOP-RAY
  "SJmR8rJgzzCi4sPjGnrNsqY4akQb3jn5nsxZBhyEifC",
  // SLRS-USDC
  "7XXKU8oGDbeGrkPyK5yHKzdsrMJtB7J2TMugjbrXEhB5",
  // SAMO-RAY
  "EyDgEU9BdG7m6ZK4bYERxbN4NCJ129WzPtv23dBkfsLg",
  // renBTC-USDC
  "61JtCkTQKSeBU8ztEScByZiBhS6KAHSXfQduVyA4s1h7",
  // renDOGE-USDC
  "34oD4akb2DeNcCw1smKHPsD3iqQQQWmNy3cY81nz7HP8",
  // RAY-USDC
  "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg",
  // RAY-SRM
  "GaqgfieVmnmY4ZsZHHA6L5RSVzCGL3sKx4UgHBaYNy8m",
  // RAY-ETH
  "8iQFhWyceGREsWnLM8NkG9GC8DvZunGZyMzuyUScgkMK",
  // RAY-SOL
  "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA",
  // DXL-USDC
  "asdEJnE7osjgnSyQkSZJ3e5YezbmXuDQPiyeyiBxoUm",
  // LIKE-USDC
  "GmaDNMWsTYWjaXVBjJTHNmCWAKU6cn5hhtWWYEZt4odo",
  // mSOL-USDC
  "ZfvDXXUhZDzDVsapffUyXHj9ByCoPjP4thL6YXcZ9ix",
  // mSOL-SOL
  "EGyhb2uLAsRUbRx9dNFBjMVYnFaASWMvD6RE1aEf2LxL",
  // MER-PAI
  "6GUF8Qb5FWmifzYpRdKomFNbSQAsLShhT45GbTGg34VJ",
  // PORT-USDC
  "6nJes56KF999Q8VtQTrgWEHJGAfGMuJktGb8x2uWff2u",
  // MNGO-USDC
  "34tFULRrRwh4bMcBLPtJaNqqe5pVgGZACi5sR8Xz95KC",
  // ATLAS-USDC
  "2bnZ1edbvK3CK3LTNZ5jH9anvXYCmzPR4W2HQ6Ngsv5K",
  // POLIS-USDC
  "9xyCzsHi1wUWva7t5Z8eAvZDRmUCVhRrbaFfm3VbU4Mf",
  // ATLAS-RAY
  "F73euqPynBwrgcZn3fNSEneSnYasDQohPM5aZazW9hp2",
  // POLIS-RAY
  "5tho4By9RsqTF1rbm9Akiepik3kZBT7ffUzGg8bL1mD",
  // ALEPH-RAY
  "8Fr3wxZXLtiSozqms5nF4XXGHNSNqcMC6K6MvRqEfk4a",
  // TULIP-RAY
  "Dm1Q15216uRARmQTbo6VfnyEGVzRvLTm4TfCWWX4MF3F",
  // SLRS-RAY
  "J3CoGcJqHquUdSgS7qAwdGbp3so4EpLX8eVDdGuauvi",
  // MER-RAY
  "BKLCqnuk4qc5iHWuJuewMxuvsNZXuTBSUyRT5ftnRb6H",
  // MEDIA-RAY
  "5ZPBHzMr19iQjBaDgFDYGAx2bxaQ3TzWmSS7zAGrHtQJ",
  // SNY-RAY
  "Am9FpX73ctZ3HzohcRdyCCv84iT7nugevqLjY5yTSUQP",
  // LIKE-RAY
  "DGSnfcE1kw4uDC6jgrsZ3s5CMfsWKN7JNjDNasHdvKfq",
  // COPE-RAY
  "8hvVAhShYLPThcxrxwMNAWmgRCSjtxygj11EGHp2WHz8",
  // ETH-SOL
  "9Hm8QX7ZhE9uB8L2arChmmagZZBtBmnzBbpfxzkQp85D",
  // stSOL-USDC
  "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj",
  // GRAPE-USDC
  "vVXfY15WdPsCmLvbiP4hWWECPFeAvPTuPNq3Q4BXfhy",
  // LARIX-USDC
  "A21ui9aYTSs3CbkscaY6irEMQx3Z59dLrRuZQTt2hJwQ",
  // RIN-USDC
  "7qZJTK5NatxQJRTxZvHi3gRu4cZZsKr8ZPzs7BA5JMTC",
  // APEX-USDC
  "43UHp4TuwQ7BYsaULN1qfpktmg7GWs9GpR8TDb8ovu9c",
  // mSOL-RAY
  "6gpZ9JkLoYvpA5cwdyPZFsDw6tkbPyyXM5FqRqHxMCny",
  // MNDE-mSOL
  "2kPA9XUuHUifcCYTnjSuN7ZrC3ma8EKPrtzUhC86zj3m",
  // LARIX-RAY
  "EBqQdu9rGe6j3WGJQSyTvDjUMWcRd6uLcxSS4TbFT31t",
  // LIQ-USDC
  "33dWwj33J3NUzoTmkMAUq1VdXZL89qezxkdaHdN88vK2",
  // WAG-USDC
  "FEFzBbbEK8yDigqyJPgJKMR5X1xZARC25QTCskvudjuK",
  // ETH-mSOL
  "Ghj3v2qYbSp6XqmH4NV4KRu4Rrgqoh2Ra7L9jEdsbNzF",
  // mSOL-USDT
  "BhuMVCzwFVZMSuc1kBbdcAnXwFg9p4HJp7A9ddwYjsaF",
  // BTC-mSOL
  "ynV2H2b7FcRBho2TvE25Zc4gDeuu2N45rUw9DuJYjJ9",
  // SLIM-SOL
  "8idN93ZBpdtMp4672aS4GGMDy7LdVWCCXH7FKFdMw9P4",
  // AURY-USDC
  "Ek8uoHjADzbNk2yr2HysybwFk1h2j9XXDsWAjAJN38n1",
  // PRT-SOL
  "7rVAbPFzqaBmydukTDFAuBiuyBrTVhpa5LpfDRrjX9mr",
  // LIQ-RAY
  "HuMDhYhW1BmBjXoJZBdjqaqoD3ehQeCUMbDSiZsaXSDU",
  // SYP-SOL
  "D95EzH4ZsGLikvYzp7kmz1RM1xNMo1MXXiXaedQesA2m",
  // SYP-RAY
  "3hhSfFhbk7Kd8XrRYKCcGAyUVYRaW9MLhcqAaU9kx6SA",
  // SYP-USDC
  "2Tv6eMih3iqxHrLAWn372Nba4A8FT8AxFSbowBmmTuAd",
  // FAB-USDC
  "7eM9KWYiJmNfDfeztMoEZE1KPyWD54LRxM9GmRY9ske6",
  // WOOF-RAY
  "3HYhQC6ne6SAPVT5sPTKawRUxv9ZpYyLuk1ifrw8baov",
  // WOOF-USDC
  "EZRHhpvAP4zEX1wZtTQcf6NP4FLWjs9c6tMRBqfrXgFD",
  // SLND-USDC
  "GRM4jGMtx64sEocBFz6ZgdogF2fyTWiixht8thZoHjkK",
  // FRKT-SOL
  "H3dhkXcC5MRN7VRXNbWVSvogH8mUQPzpn8PYQL7HfBVg",
  // weWETH-SOL
  "4yrHms7ekgTBgJg77zJ33TsWrraqHsCXDtuSZqUsuGHb",
  // weWETH-USDC
  "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb",
  // weUNI-USDC
  "8J5fa8WBGaDSv8AUpgtqdh9HM5AZuSf2ijvSkKoaCXCi",
  // weSUSHI-USDC
  "9SWy6nbSVZ44XuixEvHpona663pZPpVgzXQ3N7muG4ou",
  // CYS-USDC
  "661trVCzDWp114gy4PEK4etbjb3u3RNaP4aENa5uN8Vp",
  // SAMO-USDC
  "7oYaghDwJ6ZbZwzdzcPqQtW6r4cojSLJDKB6U7tqAK1x",
  // ABR-USDC
  "GQJjrG6f8HbxkE3ZVSRpzoyWhQ2RiivT68BybVK9DxME",
  // IN-USDC
  "5DECiJuqwmeCptoBEpyJtXKrVfiUrG9nBbBGkxGkPYyF",
  // weDYDX-USDC
  "CbGQojcizFEHn3woL7NPu3P9BLL1SWz5a8zkL9gks24q",
  // STARS-USDC
  "CWQVga1qUbpZXjrWQRj6U6tmL3HhrFiAT11VYnB8d3CF",
  // weAXS-USDC
  "HopVRTvFvRe1ED3dRCQrt1h5onkMvY3tKUHRVQMc7MMH",
  // weSHIB-USDC
  "SU7vPveBjEuR5tgQwidRqqTxn1WwraHpydHHBpM2W96",
  // SBR-USDC
  "5cmAS6Mj4pG2Vp9hhyu3kpK9yvC7P6ejh9HiobpTE6Jc",
  // OXS-USDC
  "8ekXiGjEjtWzd2us3rAsusKv7kKEhPENV7nvzS7RGRYY",
  // CWAR-USDC
  "13uCPybNakXHGVd2DDVB7o2uwXuf9GqPFkvJMVgKy6UJ",
  // UPS-USDC
  "FSSRqrGrDjDXnojhSDrDBknJeQ83pyACemnaMLaZDD1U",
  // weSAND-USDC
  "3cmPpX8kKzEra2umtLCDxMfjma82ELtAMaSYVmdaNLxi",
  // weMANA-USDC
  "7Z1c6GHutf3q2MNheyFE8KMNVEALuiPaqoEMyjbCbuku",
  // CAVE-USDC
  "2PfKnjEfoUoVDbDS1YwvZ8HuPGBCpN831mnTuqTAJZjH",
  // GENE-USDC
  "Enq8vJucRbkzKA1i1PahJNhMyUTzoVL5Cs8n5rC3NLGn",
  // GENE-RAY
  "8FrCybrh7UFznP1hVHg8kXZ8bhii37c7BGzmjkdcsGJp",
  // APT-USDC
  "4crhN3D8R5rnZd66q9b32P7K649e5XdzCfPMPiTzBceH",
  // GOFX-USDC
  "zoouer92idprkptX76yvhp4stK2keTzJpMNkeLqtxAx",
  // SONAR-USDC
  "CrWbfKwyAaUfYctXWF9iaDUP4AH5t6k6bbaWnXBL8nHm",
  // JSOL-SOL
  "D8pasgJWjP9wy39fzeD8BUjQMvYCZxABzPcnuoDSLHBB",
  // JSOL-USDC
  "7e8GrkwsRm5sS5UaKobLJUNu9esmrzg37dqX6aQyuver",
  // SHILL-USDC
  "FTyJCLwQ3YvVfanJp8mtC2eqmvZPpzSpmNLqWpaPaXbC",
  // DFL-USDC
  "8GJdzPuEBPP3BHJpcspBcfpRZV4moZMFwhTAuXebaPL8",
  // BOKU-USDC
  "FsERtRjCEQNyND3ccnMGrd61ntPmJ3tbZs4vvcCzMr1L",
  // MIMO-SOL
  "DqYSvijBXydSx9GfvVDjEzUg5StLLrkqZVPzsU2FeVZ2",
  // wbWBNB-USDC
  "Fb1WR1kYvG1tHu4pwAxXQpdKT8Grh9i7ES9rZusLg7D6",
  // wePEOPLE-USDC
  "GfvqUB36CPfqZDz5ntQ2YsoKRwg1MCewmurhc7jw3P5s",
  // XTAG-USDC
  "Hv1BFhyADPjYXTqEeMgwzoybnNwYrHXNv7U2VjcAuEDr",
  // KKO-USDC
  "FvN7dJz7GX1XB1BTk6jD5rEKRxQc3ZwNkWJKai5sBJWS",
  // VI-USDC
  "MphbxYtji1FSkm7G2FNGpUUz5AWn7iRPNFAvEqD4mzE",
  // SOLC-USDT
  "783kPvwHwDXaU32kV8NK5dB4JVeMWQwe8a3WUNZFpupr",
  // STR-USDC
  "E9Z2JeEKS2WGGyA18mGU33rnQskK9moPhM4tdzrv24fh",
  // SPWN-USDC
  "Bhw7DbVwWMcTBXoKaWgsCaofL6QqmQQ65FCSGfgCEawm",
  // ISOLA-USDT
  "69Mo81rUPDgru4UbigPQovx7cYBxpEm44qQok8wcut4M",
  // TTT-USDC
  "HcqHvH27wk42L1ND5YPhLDJu7oGsU7HGSreMiXdq5LNK",
  // RUN-USDC
  "zuivKkgkNFFkV9jfNpsU1p5tWNbDWUEx5XX16m4k2Ej",
  // CRWNY-USDC
  "4ELBQuq3ivhLamfCT36As5sXLkQDWRJw1pJ9JVFLp6gK",
  // CRWNY-RAY
  "HARRXESCwid3xMi2qThag1PXzmp6rDhAzMR9THhFRQGf",
  // BLOCK-USDC
  "CfBSfVTcYFJsD8vZ2fTiMGkUYFim2rv8weAoqHxUU2pn",
  // REAL-USDC
  "A7ZxDrK9LSkVXhfRTu2pRCinwYfdxW2kK6DaJk12jRWw",
  // PRISM-USDC
  "4ZYiiVakejxGyJ3tuBzYWoHyEV1rk7Hm7viydG6DNaUN",
  // MBS-USDC
  "6eRECBcCVP82AvAd6Di4rZApa2btLf8RDUqrTigt4hS4"
];
var TESTNET_OFFICIAL_LIQUIDITY_POOLS = [];
var DEVNET_OFFICIAL_LIQUIDITY_POOLS = [];
var ENDPOINT = "https://api.raydium.io";
var RAYDIUM_MAINNET = {
  time: "/v2/main/chain/time",
  info: "/v2/main/info",
  pairs: "/v2/main/pairs",
  price: "/v2/main/price",
  rpcs: "/v2/main/rpcs",
  version: "/v2/main/version",
  farmApr: "/v2/main/farm/info",
  farmAprLine: "/v2/main/farm-apr-tv",
  tokenInfo: "/v2/sdk/token/raydium.mainnet.json",
  poolInfo: "/v2/sdk/liquidity/mainnet.json",
  dailyPoolInfo: "/v2/sdk/liquidity/date",
  uiPoolInfo: "/v2/sdk/liquidity/mainnet.ui.json",
  searchPool: "/v2/sdk/liquidity/mint/",
  farmInfo: "/v2/sdk/farm-v2/mainnet.json",
  idoInfo: "/v2/main/ido/pools",
  idoProjectInfo: "/v2/main/ido/project/<id>",
  // CLMM
  clmmPools: "/v2/ammV3/ammPools",
  clmmConfigs: "/v2/ammV3/ammConfigs",
  clmmPositionLine: "/v2/ammV3/positionLine/<poolId>"
};
var MAINNET_PROGRAM_ID = {
  SERUM_MARKET: new PublicKey("9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin"),
  OPENBOOK_MARKET: new PublicKey("srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX"),
  UTIL1216: new PublicKey("CLaimxFqjHzgTJtAGHU47NPhg6qrc5sCnpC4tBLyABQS"),
  FarmV3: new PublicKey("EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q"),
  FarmV5: new PublicKey("9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z"),
  FarmV6: new PublicKey("FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG"),
  AmmV4: new PublicKey("675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"),
  AmmStable: new PublicKey("5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h"),
  CLMM: new PublicKey("CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK"),
  Router: new PublicKey("routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS")
};
var DEVNET_PROGRAM_ID = {
  SERUM_MARKET: PublicKey.default,
  OPENBOOK_MARKET: new PublicKey("EoTcMgcDRTJVZDMZWBoU6rhYHZfkNTVEAfz3uUJRcYGj"),
  UTIL1216: PublicKey.default,
  FarmV3: new PublicKey("85BFyr98MbCUU9MVTEgzx1nbhWACbJqLzho6zd6DZcWL"),
  FarmV5: new PublicKey("EcLzTrNg9V7qhcdyXDe2qjtPkiGzDM2UbdRaeaadU5r2"),
  FarmV6: new PublicKey("Farm2hJLcqPtPg8M4rR6DMrsRNc5TPm5Cs4bVQrMe2T7"),
  AmmV4: new PublicKey("HWy1jotHpo6UqeQxx49dpYYdQB8wj9Qk9MdxwjLvDHB8"),
  AmmStable: new PublicKey("DDg4VmQaJV9ogWce7LpcjBA9bv22wRp5uaTPa5pGjijF"),
  CLMM: new PublicKey("devi51mZmdwUJGU9hjN27vEz64Gps7uUefqxg27EAtH"),
  Router: new PublicKey("BVChZ3XFEwTMUk1o9i3HAf91H6mFxSwa5X2wFAWhYPhU")
};
function routeInstruction(programId, wallet, userSourceToken, userRouteToken, userDestinationToken, inputMint, routeMint, poolKeyA, poolKeyB, amountIn, amountOut, remainingAccounts) {
  const dataLayout = struct50([u8210("instruction"), u642("amountIn"), u642("amountOut")]);
  const keys = [
    { pubkey: wallet, isSigner: true, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
  ];
  keys.push(...makeInnerInsKey(poolKeyA, inputMint, userSourceToken, userRouteToken, remainingAccounts[0]));
  keys.push(...makeInnerInsKey(poolKeyB, routeMint, userRouteToken, userDestinationToken, remainingAccounts[1]));
  const data = Buffer.alloc(dataLayout.span);
  dataLayout.encode(
    {
      instruction: 8,
      amountIn,
      amountOut
    },
    data
  );
  return new TransactionInstruction({
    keys,
    programId,
    data
  });
}
function makeInnerInsKey(itemPool, inMint, userInAccount, userOutAccount, remainingAccount) {
  if (itemPool.version === 4) {
    const poolKey = jsonInfo2PoolKeys(itemPool);
    return [
      { pubkey: poolKey.programId, isSigner: false, isWritable: false },
      { pubkey: userInAccount, isSigner: false, isWritable: true },
      { pubkey: userOutAccount, isSigner: false, isWritable: true },
      { pubkey: poolKey.id, isSigner: false, isWritable: true },
      { pubkey: poolKey.authority, isSigner: false, isWritable: false },
      { pubkey: poolKey.marketProgramId, isSigner: false, isWritable: false },
      { pubkey: poolKey.marketAuthority, isSigner: false, isWritable: false },
      { pubkey: poolKey.openOrders, isSigner: false, isWritable: true },
      { pubkey: poolKey.baseVault, isSigner: false, isWritable: true },
      { pubkey: poolKey.quoteVault, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketId, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketBids, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketAsks, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketEventQueue, isSigner: false, isWritable: true },
      ...poolKey.marketProgramId.toString() === "srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX" ? [
        { pubkey: poolKey.marketBaseVault, isSigner: false, isWritable: true },
        { pubkey: poolKey.marketQuoteVault, isSigner: false, isWritable: true }
      ] : [
        { pubkey: poolKey.id, isSigner: false, isWritable: true },
        { pubkey: poolKey.id, isSigner: false, isWritable: true }
      ]
    ];
  } else if (itemPool.version === 5) {
    const poolKey = jsonInfo2PoolKeys(itemPool);
    return [
      { pubkey: poolKey.programId, isSigner: false, isWritable: false },
      { pubkey: userInAccount, isSigner: false, isWritable: true },
      { pubkey: userOutAccount, isSigner: false, isWritable: true },
      { pubkey: poolKey.id, isSigner: false, isWritable: true },
      { pubkey: poolKey.authority, isSigner: false, isWritable: false },
      { pubkey: poolKey.marketProgramId, isSigner: false, isWritable: false },
      { pubkey: poolKey.id, isSigner: false, isWritable: true },
      { pubkey: new PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"), isSigner: false, isWritable: false },
      { pubkey: poolKey.openOrders, isSigner: false, isWritable: true },
      { pubkey: poolKey.baseVault, isSigner: false, isWritable: true },
      { pubkey: poolKey.quoteVault, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketId, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketBids, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketAsks, isSigner: false, isWritable: true },
      { pubkey: poolKey.marketEventQueue, isSigner: false, isWritable: true },
      { pubkey: poolKey.id, isSigner: false, isWritable: true },
      { pubkey: poolKey.id, isSigner: false, isWritable: true }
    ];
  } else if (itemPool.version === 6) {
    const baseIn = itemPool.mintA.mint.toString() === inMint;
    return [
      { pubkey: new PublicKey(String(itemPool.programId)), isSigner: false, isWritable: false },
      { pubkey: userInAccount, isSigner: false, isWritable: true },
      { pubkey: userOutAccount, isSigner: false, isWritable: true },
      { pubkey: itemPool.ammConfig.id, isSigner: false, isWritable: false },
      { pubkey: itemPool.id, isSigner: false, isWritable: true },
      { pubkey: baseIn ? itemPool.mintA.vault : itemPool.mintB.vault, isSigner: false, isWritable: true },
      { pubkey: baseIn ? itemPool.mintB.vault : itemPool.mintA.vault, isSigner: false, isWritable: true },
      { pubkey: itemPool.observationId, isSigner: false, isWritable: true },
      ...itemPool.mintA.programId.equals(TOKEN_2022_PROGRAM_ID) || itemPool.mintB.programId.equals(TOKEN_2022_PROGRAM_ID) ? [
        { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: MEMO_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: baseIn ? itemPool.mintA.mint : itemPool.mintB.mint, isSigner: false, isWritable: false },
        { pubkey: baseIn ? itemPool.mintB.mint : itemPool.mintA.mint, isSigner: false, isWritable: false }
      ] : [],
      ...(remainingAccount != null ? remainingAccount : []).map((i) => ({ pubkey: i, isSigner: false, isWritable: true })),
      {
        pubkey: getPdaExBitmapAccount(new PublicKey(String(itemPool.programId)), itemPool.id).publicKey,
        isSigner: false,
        isWritable: true
      }
    ];
  } else {
    throw Error("make swap ins error");
  }
}
var TradeV2 = class extends Base {
  static getAllRoute({
    inputMint,
    outputMint,
    apiPoolList,
    clmmList,
    allowedRouteToken2022 = false
  }) {
    var _a, _b;
    inputMint = inputMint.toString() === PublicKey.default.toString() ? new PublicKey(WSOL.mint) : inputMint;
    outputMint = outputMint.toString() === PublicKey.default.toString() ? new PublicKey(WSOL.mint) : outputMint;
    const needSimulate = {};
    const needTickArray = {};
    const needCheckToken = /* @__PURE__ */ new Set();
    const directPath = [];
    const routePathDict = {};
    for (const itemAmmPool of clmmList != null ? clmmList : []) {
      if (itemAmmPool.mintA.mint.equals(inputMint) && itemAmmPool.mintB.mint.equals(outputMint) || itemAmmPool.mintA.mint.equals(outputMint) && itemAmmPool.mintB.mint.equals(inputMint)) {
        directPath.push(itemAmmPool);
        needTickArray[itemAmmPool.id.toString()] = itemAmmPool;
      }
      if (itemAmmPool.mintA.mint.equals(inputMint) && (itemAmmPool.mintB.programId.equals(TOKEN_PROGRAM_ID) || allowedRouteToken2022)) {
        const t = itemAmmPool.mintB.mint.toString();
        if (routePathDict[t] === void 0)
          routePathDict[t] = {
            mintProgram: itemAmmPool.mintB.programId,
            in: [],
            out: [],
            mDecimals: itemAmmPool.mintB.decimals
          };
        routePathDict[t].in.push(itemAmmPool);
      }
      if (itemAmmPool.mintB.mint.equals(inputMint) && (itemAmmPool.mintA.programId.equals(TOKEN_PROGRAM_ID) || allowedRouteToken2022)) {
        const t = itemAmmPool.mintA.mint.toString();
        if (routePathDict[t] === void 0)
          routePathDict[t] = {
            mintProgram: itemAmmPool.mintA.programId,
            in: [],
            out: [],
            mDecimals: itemAmmPool.mintA.decimals
          };
        routePathDict[t].in.push(itemAmmPool);
      }
      if (itemAmmPool.mintA.mint.equals(outputMint) && (itemAmmPool.mintB.programId.equals(TOKEN_PROGRAM_ID) || allowedRouteToken2022)) {
        const t = itemAmmPool.mintB.mint.toString();
        if (routePathDict[t] === void 0)
          routePathDict[t] = {
            mintProgram: itemAmmPool.mintB.programId,
            in: [],
            out: [],
            mDecimals: itemAmmPool.mintB.decimals
          };
        routePathDict[t].out.push(itemAmmPool);
      }
      if (itemAmmPool.mintB.mint.equals(outputMint) && (itemAmmPool.mintA.programId.equals(TOKEN_PROGRAM_ID) || allowedRouteToken2022)) {
        const t = itemAmmPool.mintA.mint.toString();
        if (routePathDict[t] === void 0)
          routePathDict[t] = {
            mintProgram: itemAmmPool.mintA.programId,
            in: [],
            out: [],
            mDecimals: itemAmmPool.mintA.decimals
          };
        routePathDict[t].out.push(itemAmmPool);
      }
    }
    const addLiquidityPools = [];
    const _inputMint = inputMint.toString();
    const _outputMint = outputMint.toString();
    for (const itemAmmPool of (_a = (apiPoolList != null ? apiPoolList : {}).official) != null ? _a : []) {
      if (itemAmmPool.baseMint === _inputMint && itemAmmPool.quoteMint === _outputMint || itemAmmPool.baseMint === _outputMint && itemAmmPool.quoteMint === _inputMint) {
        directPath.push(itemAmmPool);
        needSimulate[itemAmmPool.id] = itemAmmPool;
        addLiquidityPools.push(itemAmmPool);
      }
      if (itemAmmPool.baseMint === _inputMint) {
        if (routePathDict[itemAmmPool.quoteMint] === void 0)
          routePathDict[itemAmmPool.quoteMint] = {
            mintProgram: TOKEN_PROGRAM_ID,
            in: [],
            out: [],
            mDecimals: itemAmmPool.quoteDecimals
          };
        routePathDict[itemAmmPool.quoteMint].in.push(itemAmmPool);
      }
      if (itemAmmPool.quoteMint === _inputMint) {
        if (routePathDict[itemAmmPool.baseMint] === void 0)
          routePathDict[itemAmmPool.baseMint] = {
            mintProgram: TOKEN_PROGRAM_ID,
            in: [],
            out: [],
            mDecimals: itemAmmPool.baseDecimals
          };
        routePathDict[itemAmmPool.baseMint].in.push(itemAmmPool);
      }
      if (itemAmmPool.baseMint === _outputMint) {
        if (routePathDict[itemAmmPool.quoteMint] === void 0)
          routePathDict[itemAmmPool.quoteMint] = {
            mintProgram: TOKEN_PROGRAM_ID,
            in: [],
            out: [],
            mDecimals: itemAmmPool.quoteDecimals
          };
        routePathDict[itemAmmPool.quoteMint].out.push(itemAmmPool);
      }
      if (itemAmmPool.quoteMint === _outputMint) {
        if (routePathDict[itemAmmPool.baseMint] === void 0)
          routePathDict[itemAmmPool.baseMint] = {
            mintProgram: TOKEN_PROGRAM_ID,
            in: [],
            out: [],
            mDecimals: itemAmmPool.baseDecimals
          };
        routePathDict[itemAmmPool.baseMint].out.push(itemAmmPool);
      }
    }
    const _insertAddLiquidityPool = addLiquidityPools.length === 0;
    for (const itemAmmPool of (_b = (apiPoolList != null ? apiPoolList : {}).unOfficial) != null ? _b : []) {
      if (itemAmmPool.baseMint === _inputMint && itemAmmPool.quoteMint === _outputMint || itemAmmPool.baseMint === _outputMint && itemAmmPool.quoteMint === _inputMint) {
        directPath.push(itemAmmPool);
        needSimulate[itemAmmPool.id] = itemAmmPool;
        if (_insertAddLiquidityPool) addLiquidityPools.push(itemAmmPool);
      }
      if (itemAmmPool.baseMint === _inputMint) {
        if (routePathDict[itemAmmPool.quoteMint] === void 0)
          routePathDict[itemAmmPool.quoteMint] = {
            mintProgram: TOKEN_PROGRAM_ID,
            in: [],
            out: [],
            mDecimals: itemAmmPool.quoteDecimals
          };
        routePathDict[itemAmmPool.quoteMint].in.push(itemAmmPool);
      }
      if (itemAmmPool.quoteMint === _inputMint) {
        if (routePathDict[itemAmmPool.baseMint] === void 0)
          routePathDict[itemAmmPool.baseMint] = {
            mintProgram: TOKEN_PROGRAM_ID,
            in: [],
            out: [],
            mDecimals: itemAmmPool.baseDecimals
          };
        routePathDict[itemAmmPool.baseMint].in.push(itemAmmPool);
      }
      if (itemAmmPool.baseMint === _outputMint) {
        if (routePathDict[itemAmmPool.quoteMint] === void 0)
          routePathDict[itemAmmPool.quoteMint] = {
            mintProgram: TOKEN_PROGRAM_ID,
            in: [],
            out: [],
            mDecimals: itemAmmPool.quoteDecimals
          };
        routePathDict[itemAmmPool.quoteMint].out.push(itemAmmPool);
      }
      if (itemAmmPool.quoteMint === _outputMint) {
        if (routePathDict[itemAmmPool.baseMint] === void 0)
          routePathDict[itemAmmPool.baseMint] = {
            mintProgram: TOKEN_PROGRAM_ID,
            in: [],
            out: [],
            mDecimals: itemAmmPool.baseDecimals
          };
        routePathDict[itemAmmPool.baseMint].out.push(itemAmmPool);
      }
    }
    for (const t of Object.keys(routePathDict)) {
      if (routePathDict[t].in.length === 1 && routePathDict[t].out.length === 1 && String(routePathDict[t].in[0].id) === String(routePathDict[t].out[0].id)) {
        delete routePathDict[t];
        continue;
      }
      if (routePathDict[t].in.length === 0 || routePathDict[t].out.length === 0) {
        delete routePathDict[t];
        continue;
      }
      const info = routePathDict[t];
      for (const infoIn of info.in) {
        for (const infoOut of info.out) {
          if (infoIn.version === 6 && needTickArray[infoIn.id.toString()] === void 0) {
            needTickArray[infoIn.id.toString()] = infoIn;
            if (infoIn.mintA.programId.equals(TOKEN_2022_PROGRAM_ID)) needCheckToken.add(infoIn.mintA.mint.toString());
            if (infoIn.mintB.programId.equals(TOKEN_2022_PROGRAM_ID)) needCheckToken.add(infoIn.mintB.mint.toString());
          } else if (infoIn.version !== 6 && needSimulate[infoIn.id] === void 0) {
            needSimulate[infoIn.id] = infoIn;
          }
          if (infoOut.version === 6 && needTickArray[infoOut.id.toString()] === void 0) {
            needTickArray[infoOut.id.toString()] = infoOut;
            if (infoOut.mintA.programId.equals(TOKEN_2022_PROGRAM_ID)) needCheckToken.add(infoOut.mintA.mint.toString());
            if (infoOut.mintB.programId.equals(TOKEN_2022_PROGRAM_ID)) needCheckToken.add(infoOut.mintB.mint.toString());
          } else if (infoOut.version !== 6 && needSimulate[infoOut.id] === void 0) {
            needSimulate[infoOut.id] = infoOut;
          }
        }
      }
    }
    for (const item of directPath) {
      if (item.version === 6) {
        if (item.mintA.programId.equals(TOKEN_2022_PROGRAM_ID)) needCheckToken.add(item.mintA.mint.toString());
        if (item.mintB.programId.equals(TOKEN_2022_PROGRAM_ID)) needCheckToken.add(item.mintB.mint.toString());
      }
    }
    return {
      directPath,
      addLiquidityPools,
      routePathDict,
      needSimulate: Object.values(needSimulate),
      needTickArray: Object.values(needTickArray),
      needCheckToken: [...needCheckToken]
    };
  }
  static fetchMultipleInfo(_0) {
    return __async(this, arguments, function* ({
      connection,
      pools,
      batchRequest = true
    }) {
      if (pools.find((i) => i.version === 5)) yield initStableModelLayout(connection);
      const instructions = pools.map(
        (pool) => Liquidity.makeSimulatePoolInfoInstruction({ poolKeys: jsonInfo2PoolKeys(pool) })
      );
      const logs = yield simulateMultipleInstruction(
        connection,
        instructions.map((i) => i.innerTransaction.instructions).flat(),
        "GetPoolData",
        batchRequest
      );
      const poolsInfo = {};
      for (const log3 of logs) {
        const json = parseSimulateLogToJson(log3, "GetPoolData");
        const ammId = JSON.parse(json)["amm_id"];
        const status = new import_bn17.default(parseSimulateValue(json, "status"));
        const baseDecimals = Number(parseSimulateValue(json, "coin_decimals"));
        const quoteDecimals = Number(parseSimulateValue(json, "pc_decimals"));
        const lpDecimals = Number(parseSimulateValue(json, "lp_decimals"));
        const baseReserve = new import_bn17.default(parseSimulateValue(json, "pool_coin_amount"));
        const quoteReserve = new import_bn17.default(parseSimulateValue(json, "pool_pc_amount"));
        const lpSupply = new import_bn17.default(parseSimulateValue(json, "pool_lp_supply"));
        let startTime = "0";
        try {
          startTime = parseSimulateValue(json, "pool_open_time");
        } catch (error) {
        }
        poolsInfo[ammId] = {
          ammId,
          status,
          baseDecimals,
          quoteDecimals,
          lpDecimals,
          baseReserve,
          quoteReserve,
          lpSupply,
          startTime: new import_bn17.default(startTime)
        };
      }
      return poolsInfo;
    });
  }
  static getAddLiquidityDefaultPool({
    addLiquidityPools,
    poolInfosCache
  }) {
    if (addLiquidityPools.length === 0) return void 0;
    if (addLiquidityPools.length === 1) return addLiquidityPools[0];
    addLiquidityPools.sort((a, b) => b.version - a.version);
    if (addLiquidityPools[0].version !== addLiquidityPools[1].version) return addLiquidityPools[0];
    const _addLiquidityPools = addLiquidityPools.filter((i) => i.version === addLiquidityPools[0].version);
    _addLiquidityPools.sort((a, b) => this.ComparePoolSize(a, b, poolInfosCache));
    return _addLiquidityPools[0];
  }
  static ComparePoolSize(a, b, ammIdToPoolInfo) {
    const aInfo = ammIdToPoolInfo[a.id];
    const bInfo = ammIdToPoolInfo[b.id];
    if (aInfo === void 0) return 1;
    if (bInfo === void 0) return -1;
    if (a.baseMint === b.baseMint) {
      const sub2 = aInfo.baseReserve.sub(bInfo.baseReserve);
      return sub2.gte(ZERO) ? -1 : 1;
    } else {
      const sub2 = aInfo.baseReserve.sub(bInfo.quoteReserve);
      return sub2.gte(ZERO) ? -1 : 1;
    }
  }
  static getAllRouteComputeAmountOut({
    inputTokenAmount,
    outputToken,
    directPath,
    routePathDict,
    simulateCache,
    tickCache,
    mintInfos,
    slippage,
    chainTime,
    epochInfo,
    feeConfig
  }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const _amountInFee = feeConfig === void 0 ? new import_bn17.default(0) : inputTokenAmount.raw.mul(new import_bn17.default(feeConfig.feeBps.toNumber())).div(new import_bn17.default(1e4));
    const _amoutIn = inputTokenAmount.raw.sub(_amountInFee);
    const amountIn = inputTokenAmount instanceof TokenAmount ? new TokenAmount(inputTokenAmount.token, _amoutIn) : new CurrencyAmount(inputTokenAmount.currency, _amoutIn);
    const _inFeeConfig = feeConfig === void 0 ? void 0 : {
      feeAmount: _amountInFee,
      feeAccount: feeConfig.feeAccount
    };
    const outRoute = [];
    for (const itemPool of directPath) {
      try {
        outRoute.push(__spreadProps(__spreadValues({}, this.computeAmountOut({
          itemPool,
          tickCache,
          simulateCache,
          chainTime,
          epochInfo,
          mintInfos,
          slippage,
          outputToken,
          amountIn
        })), {
          feeConfig: _inFeeConfig
        }));
      } catch (e) {
      }
    }
    for (const [routeMint, info] of Object.entries(routePathDict)) {
      const routeToken = new Token(info.mintProgram, routeMint, info.mDecimals);
      const maxFirstIn = info.in.map((i) => {
        try {
          return {
            pool: i,
            data: this.computeAmountOut({
              itemPool: i,
              tickCache,
              simulateCache,
              chainTime,
              epochInfo,
              mintInfos,
              slippage,
              outputToken: routeToken,
              amountIn
            })
          };
        } catch (e) {
          return void 0;
        }
      }).sort((_a2, _b2) => {
        var _a3, _b3, _c2, _d2;
        const a = _a2 === void 0 ? ZERO : _a2.data.amountOut.amount.raw.sub((_b3 = (_a3 = _a2.data.amountOut.fee) == null ? void 0 : _a3.raw) != null ? _b3 : ZERO);
        const b = _b2 === void 0 ? ZERO : _b2.data.amountOut.amount.raw.sub((_d2 = (_c2 = _b2.data.amountOut.fee) == null ? void 0 : _c2.raw) != null ? _d2 : ZERO);
        return a.lt(b) ? 1 : -1;
      })[0];
      if (maxFirstIn === void 0) continue;
      const routeAmountIn = new TokenAmount(
        routeToken,
        maxFirstIn.data.amountOut.amount.raw.sub((_b = (_a = maxFirstIn.data.amountOut.fee) == null ? void 0 : _a.raw) != null ? _b : ZERO)
      );
      for (const iOutPool of info.out) {
        try {
          const outC = this.computeAmountOut({
            itemPool: iOutPool,
            tickCache,
            simulateCache,
            chainTime,
            epochInfo,
            mintInfos,
            slippage,
            outputToken,
            amountIn: routeAmountIn
          });
          outRoute.push({
            allTrade: maxFirstIn.data.allTrade && outC.allTrade ? true : false,
            amountIn: maxFirstIn.data.amountIn,
            amountOut: outC.amountOut,
            minAmountOut: outC.minAmountOut,
            currentPrice: void 0,
            executionPrice: new Price(
              (_c = maxFirstIn.data.amountIn.amount.token) != null ? _c : maxFirstIn.data.amountIn.amount.currency,
              maxFirstIn.data.amountIn.amount.raw,
              (_d = outC.amountOut.amount.token) != null ? _d : outC.amountOut.amount.currency,
              outC.amountOut.amount.raw.sub((_f = (_e = outC.amountOut.fee) == null ? void 0 : _e.raw) != null ? _f : ZERO)
            ),
            priceImpact: maxFirstIn.data.priceImpact.add(outC.priceImpact),
            fee: [maxFirstIn.data.fee[0], outC.fee[0]],
            routeType: "route",
            poolKey: [maxFirstIn.pool, iOutPool],
            remainingAccounts: [maxFirstIn.data.remainingAccounts[0], outC.remainingAccounts[0]],
            minMiddleAmountFee: ((_g = outC.amountOut.fee) == null ? void 0 : _g.raw) ? new TokenAmount(
              (_h = maxFirstIn.data.amountOut.amount.token) != null ? _h : maxFirstIn.data.amountOut.amount.currency,
              ((_j = (_i = maxFirstIn.data.amountOut.fee) == null ? void 0 : _i.raw) != null ? _j : ZERO).add((_l = (_k = outC.amountOut.fee) == null ? void 0 : _k.raw) != null ? _l : ZERO)
            ) : void 0,
            middleToken: maxFirstIn.data.amountOut.amount.token,
            poolReady: maxFirstIn.data.poolReady && outC.poolReady,
            poolType: [maxFirstIn.data.poolType, outC.poolType],
            feeConfig: _inFeeConfig,
            expirationTime: minExpirationTime(maxFirstIn.data.expirationTime, outC.expirationTime),
            slippage: outC.slippage,
            clmmExPriceX64: [maxFirstIn.data.clmmExPriceX64[0], outC.clmmExPriceX64[0]]
          });
        } catch (e) {
        }
      }
    }
    return outRoute.filter((i) => i.allTrade).sort((a, b) => a.amountOut.amount.raw.sub(b.amountOut.amount.raw).gt(ZERO) ? -1 : 1);
  }
  static computeAmountOut({
    itemPool,
    tickCache,
    simulateCache,
    chainTime,
    epochInfo,
    mintInfos,
    slippage,
    outputToken,
    amountIn
  }) {
    if (itemPool.version === 6) {
      const {
        allTrade,
        realAmountIn,
        amountOut,
        minAmountOut,
        expirationTime,
        currentPrice,
        executionPrice,
        priceImpact,
        fee,
        remainingAccounts,
        executionPriceX64
      } = Clmm.computeAmountOutFormat({
        poolInfo: itemPool,
        tickArrayCache: tickCache[itemPool.id.toString()],
        amountIn,
        currencyOut: outputToken,
        slippage,
        token2022Infos: mintInfos,
        epochInfo,
        catchLiquidityInsufficient: true
      });
      return {
        allTrade,
        amountIn: realAmountIn,
        amountOut,
        minAmountOut,
        currentPrice,
        executionPrice,
        priceImpact,
        fee: [fee],
        remainingAccounts: [remainingAccounts],
        routeType: "amm",
        poolKey: [itemPool],
        poolReady: itemPool.startTime < chainTime,
        poolType: "CLMM",
        expirationTime: minExpirationTime(realAmountIn.expirationTime, expirationTime),
        slippage,
        clmmExPriceX64: [executionPriceX64]
      };
    } else {
      if (![1, 6, 7].includes(simulateCache[itemPool.id].status.toNumber())) throw Error("swap error");
      const { amountOut, minAmountOut, currentPrice, executionPrice, priceImpact, fee } = Liquidity.computeAmountOut({
        poolKeys: jsonInfo2PoolKeys(itemPool),
        poolInfo: simulateCache[itemPool.id],
        amountIn,
        currencyOut: outputToken,
        slippage
      });
      return {
        amountIn: { amount: amountIn, fee: void 0, expirationTime: void 0 },
        amountOut: { amount: amountOut, fee: void 0, expirationTime: void 0 },
        minAmountOut: { amount: minAmountOut, fee: void 0, expirationTime: void 0 },
        currentPrice,
        executionPrice,
        priceImpact,
        fee: [fee],
        routeType: "amm",
        poolKey: [itemPool],
        remainingAccounts: [],
        poolReady: simulateCache[itemPool.id].startTime.toNumber() < chainTime,
        poolType: itemPool.version === 5 ? "STABLE" : void 0,
        expirationTime: void 0,
        allTrade: true,
        slippage,
        clmmExPriceX64: [void 0]
      };
    }
  }
  static makeSwapInstruction({ routeProgram, ownerInfo, inputMint, swapInfo }) {
    var _a, _b, _c, _d, _e, _f;
    const slippage = swapInfo.slippage.numerator.toNumber() / swapInfo.slippage.denominator.toNumber();
    if (swapInfo.routeType === "amm") {
      if (swapInfo.poolKey[0].version === 6) {
        const _poolKey = swapInfo.poolKey[0];
        const sqrtPriceLimitX64 = inputMint.equals(_poolKey.mintA.mint) ? slippage > 0.5 || MIN_SQRT_PRICE_X64.add(ONE).gt(swapInfo.clmmExPriceX64[0].div(new import_bn17.default(10))) ? MIN_SQRT_PRICE_X64.add(ONE) : swapInfo.clmmExPriceX64[0].div(new import_bn17.default(10)) : slippage > 0.5 || MAX_SQRT_PRICE_X64.sub(ONE).lt(swapInfo.clmmExPriceX64[0].mul(new import_bn17.default(10))) ? MAX_SQRT_PRICE_X64.sub(ONE) : swapInfo.clmmExPriceX64[0].mul(new import_bn17.default(10));
        return Clmm.makeSwapBaseInInstructions({
          poolInfo: _poolKey,
          ownerInfo: {
            wallet: ownerInfo.wallet,
            tokenAccountA: _poolKey.mintA.mint.equals(inputMint) ? ownerInfo.sourceToken : ownerInfo.destinationToken,
            tokenAccountB: _poolKey.mintA.mint.equals(inputMint) ? ownerInfo.destinationToken : ownerInfo.sourceToken
          },
          inputMint,
          amountIn: swapInfo.amountIn.amount.raw,
          amountOutMin: swapInfo.minAmountOut.amount.raw.sub((_b = (_a = swapInfo.minAmountOut.fee) == null ? void 0 : _a.raw) != null ? _b : ZERO),
          sqrtPriceLimitX64,
          remainingAccounts: swapInfo.remainingAccounts[0]
        });
      } else {
        const _poolKey = swapInfo.poolKey[0];
        return Liquidity.makeSwapInstruction({
          poolKeys: jsonInfo2PoolKeys(_poolKey),
          userKeys: {
            tokenAccountIn: ownerInfo.sourceToken,
            tokenAccountOut: ownerInfo.destinationToken,
            owner: ownerInfo.wallet
          },
          amountIn: swapInfo.amountIn.amount.raw,
          amountOut: swapInfo.minAmountOut.amount.raw.sub((_d = (_c = swapInfo.minAmountOut.fee) == null ? void 0 : _c.raw) != null ? _d : ZERO),
          fixedSide: "in"
        });
      }
    } else if (swapInfo.routeType === "route") {
      const poolKey1 = swapInfo.poolKey[0];
      const poolKey2 = swapInfo.poolKey[1];
      if (ownerInfo.routeToken === void 0) throw Error("owner route token account check error");
      return {
        address: {},
        innerTransaction: {
          instructions: [
            routeInstruction(
              routeProgram,
              ownerInfo.wallet,
              ownerInfo.sourceToken,
              ownerInfo.routeToken,
              ownerInfo.destinationToken,
              inputMint.toString(),
              swapInfo.middleToken.mint.toString(),
              poolKey1,
              poolKey2,
              swapInfo.amountIn.amount.raw,
              swapInfo.minAmountOut.amount.raw.sub((_f = (_e = swapInfo.minAmountOut.fee) == null ? void 0 : _e.raw) != null ? _f : ZERO),
              swapInfo.remainingAccounts
            )
          ],
          signers: [],
          lookupTableAddress: [
            poolKey1.lookupTableAccount ? new PublicKey(poolKey1.lookupTableAccount) : PublicKey.default,
            poolKey2.lookupTableAccount ? new PublicKey(poolKey2.lookupTableAccount) : PublicKey.default
          ].filter((i) => i && !i.equals(PublicKey.default)),
          instructionTypes: [
            35
            /* routeSwap */
          ]
        }
      };
    } else {
      throw Error("route type error");
    }
  }
  static makeSwapInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      swapInfo,
      ownerInfo,
      computeBudgetConfig,
      routeProgram,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const endInstructions = [];
      const frontInstructionsType = [];
      const endInstructionsType = [];
      const signers = [];
      const amountIn = swapInfo.amountIn;
      const amountOut = swapInfo.amountOut;
      const useSolBalance = !(amountIn.amount instanceof TokenAmount);
      const outSolBalance = !(amountOut.amount instanceof TokenAmount);
      const inputMint = amountIn.amount instanceof TokenAmount ? amountIn.amount.token.mint : Token.WSOL.mint;
      const inputProgramId = amountIn.amount instanceof TokenAmount ? amountIn.amount.token.programId : Token.WSOL.programId;
      const outputMint = amountOut.amount instanceof TokenAmount ? amountOut.amount.token.mint : Token.WSOL.mint;
      const outputProgramId = amountOut.amount instanceof TokenAmount ? amountOut.amount.token.programId : Token.WSOL.programId;
      const sourceToken = yield this._selectOrCreateTokenAccount({
        programId: inputProgramId,
        mint: inputMint,
        tokenAccounts: useSolBalance ? [] : ownerInfo.tokenAccounts,
        createInfo: useSolBalance ? {
          connection,
          payer: ownerInfo.wallet,
          amount: amountIn.amount.raw,
          frontInstructions,
          endInstructions,
          signers,
          frontInstructionsType,
          endInstructionsType
        } : void 0,
        owner: ownerInfo.wallet,
        associatedOnly: useSolBalance ? false : ownerInfo.associatedOnly,
        checkCreateATAOwner: ownerInfo.checkCreateATAOwner
      });
      if (sourceToken === void 0) {
        throw Error("input account check error");
      }
      const destinationToken = yield this._selectOrCreateTokenAccount({
        programId: outputProgramId,
        mint: outputMint,
        tokenAccounts: ownerInfo.tokenAccounts,
        createInfo: {
          connection,
          payer: ownerInfo.wallet,
          amount: 0,
          frontInstructions,
          endInstructions: outSolBalance ? endInstructions : void 0,
          signers,
          frontInstructionsType,
          endInstructionsType
        },
        owner: ownerInfo.wallet,
        associatedOnly: ownerInfo.associatedOnly,
        checkCreateATAOwner: ownerInfo.checkCreateATAOwner
      });
      let routeToken = void 0;
      if (swapInfo.routeType === "route") {
        const middleMint = swapInfo.middleToken;
        routeToken = yield this._selectOrCreateTokenAccount({
          programId: middleMint.programId,
          mint: middleMint.mint,
          tokenAccounts: ownerInfo.tokenAccounts,
          createInfo: {
            connection,
            payer: ownerInfo.wallet,
            amount: 0,
            frontInstructions,
            endInstructions,
            signers,
            frontInstructionsType,
            endInstructionsType
          },
          owner: ownerInfo.wallet,
          associatedOnly: false,
          checkCreateATAOwner: ownerInfo.checkCreateATAOwner
        });
      }
      const ins = this.makeSwapInstruction({
        routeProgram,
        inputMint,
        swapInfo,
        ownerInfo: {
          wallet: ownerInfo.wallet,
          sourceToken,
          routeToken,
          destinationToken
        }
      });
      const transferIns = [];
      const transferInsType = [];
      if (swapInfo.feeConfig !== void 0) {
        transferIns.push(
          createTransferInstruction(
            sourceToken,
            swapInfo.feeConfig.feeAccount,
            ownerInfo.wallet,
            swapInfo.feeConfig.feeAmount.toNumber()
          )
        );
        transferInsType.push(
          4
          /* transferAmount */
        );
      }
      const transferAddCheck = yield splitTxAndSigners({
        connection,
        makeTxVersion,
        computeBudgetConfig,
        payer: ownerInfo.wallet,
        innerTransaction: [
          { instructionTypes: transferInsType, instructions: transferIns, signers: [] },
          ins.innerTransaction
        ],
        lookupTableCache
      });
      return {
        address: ins.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig,
          payer: ownerInfo.wallet,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            ...transferAddCheck.length > 1 ? [] : [{ instructionTypes: transferInsType, instructions: transferIns, signers: [] }],
            ins.innerTransaction,
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
};
function accountFlagsLayout(property = "accountFlags") {
  const ACCOUNT_FLAGS_LAYOUT = new WideBits(property);
  ACCOUNT_FLAGS_LAYOUT.addBoolean("initialized");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("market");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("openOrders");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("requestQueue");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("eventQueue");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("bids");
  ACCOUNT_FLAGS_LAYOUT.addBoolean("asks");
  return ACCOUNT_FLAGS_LAYOUT;
}
var MARKET_STATE_LAYOUT_V2 = struct50([
  blob3(5),
  accountFlagsLayout("accountFlags"),
  publicKey2("ownAddress"),
  u642("vaultSignerNonce"),
  publicKey2("baseMint"),
  publicKey2("quoteMint"),
  publicKey2("baseVault"),
  u642("baseDepositsTotal"),
  u642("baseFeesAccrued"),
  publicKey2("quoteVault"),
  u642("quoteDepositsTotal"),
  u642("quoteFeesAccrued"),
  u642("quoteDustThreshold"),
  publicKey2("requestQueue"),
  publicKey2("eventQueue"),
  publicKey2("bids"),
  publicKey2("asks"),
  u642("baseLotSize"),
  u642("quoteLotSize"),
  u642("feeRateBps"),
  u642("referrerRebatesAccrued"),
  blob3(7)
]);
var MarketV2 = class extends Base {
  static makeCreateMarketInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      wallet,
      baseInfo,
      quoteInfo,
      lotSize,
      // 1
      tickSize,
      // 0.01
      dexProgramId,
      makeTxVersion,
      lookupTableCache,
      requestQueueSpacce,
      eventQueueSpacce,
      orderbookQueueSpacce
    }) {
      const market = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const requestQueue = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const eventQueue = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const bids = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const asks = generatePubKey({ fromPublicKey: wallet, programId: dexProgramId });
      const baseVault = generatePubKey({ fromPublicKey: wallet, programId: TOKEN_PROGRAM_ID });
      const quoteVault = generatePubKey({ fromPublicKey: wallet, programId: TOKEN_PROGRAM_ID });
      const feeRateBps = 0;
      const quoteDustThreshold = new import_bn18.default(100);
      function getVaultOwnerAndNonce() {
        const vaultSignerNonce2 = new import_bn18.default(0);
        while (true) {
          try {
            const vaultOwner2 = PublicKey.createProgramAddressSync(
              [market.publicKey.toBuffer(), vaultSignerNonce2.toArrayLike(Buffer, "le", 8)],
              dexProgramId
            );
            return { vaultOwner: vaultOwner2, vaultSignerNonce: vaultSignerNonce2 };
          } catch (e) {
            vaultSignerNonce2.iaddn(1);
            if (vaultSignerNonce2.gt(new import_bn18.default(25555))) throw Error("find vault owner error");
          }
        }
      }
      const { vaultOwner, vaultSignerNonce } = getVaultOwnerAndNonce();
      const baseLotSize = new import_bn18.default(Math.round(__pow(10, baseInfo.decimals) * lotSize));
      const quoteLotSize = new import_bn18.default(Math.round(lotSize * __pow(10, quoteInfo.decimals) * tickSize));
      if (baseLotSize.eq(ZERO)) throw Error("lot size is too small");
      if (quoteLotSize.eq(ZERO)) throw Error("tick size or lot size is too small");
      const ins = yield this.makeCreateMarketInstruction({
        connection,
        wallet,
        marketInfo: {
          programId: dexProgramId,
          id: market,
          baseMint: baseInfo.mint,
          quoteMint: quoteInfo.mint,
          baseVault,
          quoteVault,
          vaultOwner,
          requestQueue,
          eventQueue,
          bids,
          asks,
          feeRateBps,
          quoteDustThreshold,
          vaultSignerNonce,
          baseLotSize,
          quoteLotSize,
          requestQueueSpacce,
          eventQueueSpacce,
          orderbookQueueSpacce
        }
      });
      return {
        address: ins.address,
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: wallet,
          innerTransaction: ins.innerTransactions,
          lookupTableCache
        })
      };
    });
  }
  static makeCreateMarketInstruction(_0) {
    return __async(this, arguments, function* ({
      connection,
      wallet,
      marketInfo
    }) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const ins1 = [];
      const accountLamports = yield connection.getMinimumBalanceForRentExemption(165);
      ins1.push(
        SystemProgram.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.baseVault.seed,
          newAccountPubkey: marketInfo.baseVault.publicKey,
          lamports: accountLamports,
          space: 165,
          programId: TOKEN_PROGRAM_ID
        }),
        SystemProgram.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.quoteVault.seed,
          newAccountPubkey: marketInfo.quoteVault.publicKey,
          lamports: accountLamports,
          space: 165,
          programId: TOKEN_PROGRAM_ID
        }),
        createInitializeAccountInstruction(marketInfo.baseVault.publicKey, marketInfo.baseMint, marketInfo.vaultOwner),
        createInitializeAccountInstruction(marketInfo.quoteVault.publicKey, marketInfo.quoteMint, marketInfo.vaultOwner)
      );
      const ins2 = [];
      ins2.push(
        SystemProgram.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.id.seed,
          newAccountPubkey: marketInfo.id.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption(MARKET_STATE_LAYOUT_V2.span),
          space: MARKET_STATE_LAYOUT_V2.span,
          programId: marketInfo.programId
        }),
        SystemProgram.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.requestQueue.seed,
          newAccountPubkey: marketInfo.requestQueue.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption((_a = marketInfo.requestQueueSpacce) != null ? _a : 5120 + 12),
          space: (_b = marketInfo.requestQueueSpacce) != null ? _b : 5120 + 12,
          programId: marketInfo.programId
        }),
        SystemProgram.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.eventQueue.seed,
          newAccountPubkey: marketInfo.eventQueue.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption((_c = marketInfo.eventQueueSpacce) != null ? _c : 262144 + 12),
          space: (_d = marketInfo.eventQueueSpacce) != null ? _d : 262144 + 12,
          programId: marketInfo.programId
        }),
        SystemProgram.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.bids.seed,
          newAccountPubkey: marketInfo.bids.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption((_e = marketInfo.orderbookQueueSpacce) != null ? _e : 65536 + 12),
          space: (_f = marketInfo.orderbookQueueSpacce) != null ? _f : 65536 + 12,
          programId: marketInfo.programId
        }),
        SystemProgram.createAccountWithSeed({
          fromPubkey: wallet,
          basePubkey: wallet,
          seed: marketInfo.asks.seed,
          newAccountPubkey: marketInfo.asks.publicKey,
          lamports: yield connection.getMinimumBalanceForRentExemption((_g = marketInfo.orderbookQueueSpacce) != null ? _g : 65536 + 12),
          space: (_h = marketInfo.orderbookQueueSpacce) != null ? _h : 65536 + 12,
          programId: marketInfo.programId
        }),
        this.initializeMarketInstruction({
          programId: marketInfo.programId,
          marketInfo: {
            id: marketInfo.id.publicKey,
            requestQueue: marketInfo.requestQueue.publicKey,
            eventQueue: marketInfo.eventQueue.publicKey,
            bids: marketInfo.bids.publicKey,
            asks: marketInfo.asks.publicKey,
            baseVault: marketInfo.baseVault.publicKey,
            quoteVault: marketInfo.quoteVault.publicKey,
            baseMint: marketInfo.baseMint,
            quoteMint: marketInfo.quoteMint,
            baseLotSize: marketInfo.baseLotSize,
            quoteLotSize: marketInfo.quoteLotSize,
            feeRateBps: marketInfo.feeRateBps,
            vaultSignerNonce: marketInfo.vaultSignerNonce,
            quoteDustThreshold: marketInfo.quoteDustThreshold
          }
        })
      );
      return {
        address: {
          marketId: marketInfo.id.publicKey,
          requestQueue: marketInfo.requestQueue.publicKey,
          eventQueue: marketInfo.eventQueue.publicKey,
          bids: marketInfo.bids.publicKey,
          asks: marketInfo.asks.publicKey,
          baseVault: marketInfo.baseVault.publicKey,
          quoteVault: marketInfo.quoteVault.publicKey,
          baseMint: marketInfo.baseMint,
          quoteMint: marketInfo.quoteMint
        },
        innerTransactions: [
          {
            instructions: ins1,
            signers: [],
            instructionTypes: [
              0,
              0,
              1,
              1
              /* initAccount */
            ]
          },
          {
            instructions: ins2,
            signers: [],
            instructionTypes: [
              0,
              0,
              0,
              0,
              0,
              7
              /* initMarket */
            ]
          }
        ]
      };
    });
  }
  static initializeMarketInstruction({
    programId,
    marketInfo
  }) {
    const dataLayout = struct50([
      u8210("version"),
      u3222("instruction"),
      u642("baseLotSize"),
      u642("quoteLotSize"),
      u164("feeRateBps"),
      u642("vaultSignerNonce"),
      u642("quoteDustThreshold")
    ]);
    const keys = [
      { pubkey: marketInfo.id, isSigner: false, isWritable: true },
      { pubkey: marketInfo.requestQueue, isSigner: false, isWritable: true },
      { pubkey: marketInfo.eventQueue, isSigner: false, isWritable: true },
      { pubkey: marketInfo.bids, isSigner: false, isWritable: true },
      { pubkey: marketInfo.asks, isSigner: false, isWritable: true },
      { pubkey: marketInfo.baseVault, isSigner: false, isWritable: true },
      { pubkey: marketInfo.quoteVault, isSigner: false, isWritable: true },
      { pubkey: marketInfo.baseMint, isSigner: false, isWritable: false },
      { pubkey: marketInfo.quoteMint, isSigner: false, isWritable: false },
      // Use a dummy address if using the new dex upgrade to save tx space.
      {
        pubkey: marketInfo.authority ? marketInfo.quoteMint : SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }
    ].concat(marketInfo.authority ? { pubkey: marketInfo.authority, isSigner: false, isWritable: false } : []).concat(
      marketInfo.authority && marketInfo.pruneAuthority ? { pubkey: marketInfo.pruneAuthority, isSigner: false, isWritable: false } : []
    );
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode(
      {
        version: 0,
        instruction: 0,
        baseLotSize: marketInfo.baseLotSize,
        quoteLotSize: marketInfo.quoteLotSize,
        feeRateBps: marketInfo.feeRateBps,
        vaultSignerNonce: marketInfo.vaultSignerNonce,
        quoteDustThreshold: marketInfo.quoteDustThreshold
      },
      data
    );
    return new TransactionInstruction({
      keys,
      programId,
      data
    });
  }
};
var _Utils1216 = class _Utils12162 extends Base {
  // pda
  static getPdaPoolId(programId, ammId) {
    return findProgramAddress([this.SEED_CONFIG.pool.id, ammId.toBuffer()], programId);
  }
  static getPdaOwnerId(programId, poolId, owner, version2) {
    return findProgramAddress(
      [
        this.SEED_CONFIG.owner.id,
        poolId.toBuffer(),
        owner.toBuffer(),
        // new BN(version).toBuffer()
        Buffer.from(new import_bn19.default(version2).toArray())
      ],
      programId
    );
  }
  static getAllInfo(_0) {
    return __async(this, arguments, function* ({
      connection,
      programId,
      poolIds,
      wallet,
      chainTime
    }) {
      if (poolIds.length === 0) return [];
      const allPoolPda = poolIds.map((id) => this.getPdaPoolId(programId, id).publicKey);
      const allOwnerPda = [];
      for (let itemVersion = 0; itemVersion < this.VERSION_PROJECT.length; itemVersion++) {
        allOwnerPda.push(...allPoolPda.map((id) => this.getPdaOwnerId(programId, id, wallet, itemVersion).publicKey));
      }
      const pdaInfo = yield getMultipleAccountsInfo(connection, [...allPoolPda, ...allOwnerPda]);
      const info = [];
      for (let index = 0; index < pdaInfo.length; index++) {
        const version2 = Math.floor(index / poolIds.length);
        const i = index % poolIds.length;
        const itemPoolId = allPoolPda[i];
        const itemOwnerId = allOwnerPda[index];
        const itemPoolInfoS = pdaInfo[i];
        const itemOwnerInfoS = pdaInfo[poolIds.length + index];
        if (!(itemPoolInfoS && itemOwnerInfoS)) continue;
        if (itemPoolInfoS.data.length !== this.POOL_LAYOUT.span || itemOwnerInfoS.data.length !== this.OWNER_LAYOUT.span)
          continue;
        const itemPoolInfo = this.POOL_LAYOUT.decode(itemPoolInfoS.data);
        const itemOwnerInfo = this.OWNER_LAYOUT.decode(itemOwnerInfoS.data);
        const openTime = itemPoolInfo.openTime.toNumber();
        const endTime = itemPoolInfo.endTime.toNumber();
        const hasCanClaimToken = itemOwnerInfo.tokenInfo.map((i2) => i2.debtAmount.gt(new import_bn19.default(0))).filter((i2) => !i2).length !== 3;
        const inCanClaimTime = chainTime > openTime && chainTime < endTime && itemPoolInfo.status === 1;
        const canClaim = hasCanClaimToken && inCanClaimTime;
        info.push({
          programId,
          poolId: itemPoolId,
          ammId: itemPoolInfo.ammId,
          ownerAccountId: itemOwnerId,
          snapshotLpAmount: itemOwnerInfo.lpAmount,
          project: this.VERSION_PROJECT[version2],
          openTime,
          endTime,
          canClaim,
          canClaimErrorType: !hasCanClaimToken ? "alreadyClaimIt" : !inCanClaimTime ? "outOfOperationalTime" : void 0,
          tokenInfo: itemPoolInfo.tokenInfo.map((itemPoolToken, i2) => ({
            programId: TOKEN_PROGRAM_ID,
            mintAddress: itemPoolToken.mintAddress,
            mintVault: itemPoolToken.mintVault,
            mintDecimals: itemPoolToken.mintDecimals,
            perLpLoss: itemPoolToken.perLpLoss,
            debtAmount: itemOwnerInfo.tokenInfo[i2].debtAmount.add(itemOwnerInfo.tokenInfo[i2].claimedAmount)
          }))
        });
      }
      return info;
    });
  }
  static makeClaimInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfo,
      ownerInfo,
      makeTxVersion,
      lookupTableCache
    }) {
      const frontInstructions = [];
      const frontInstructionsType = [];
      const endInstructions = [];
      const endInstructionsType = [];
      const instructions = [];
      const instructionsType = [];
      const signers = [];
      const ownerVaultList = [];
      for (const itemToken of poolInfo.tokenInfo) {
        ownerVaultList.push(
          yield this._selectOrCreateTokenAccount({
            programId: itemToken.programId,
            mint: itemToken.mintAddress,
            tokenAccounts: itemToken.mintAddress.equals(Token.WSOL.mint) ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.wallet,
              amount: 0,
              frontInstructions,
              endInstructions: itemToken.mintAddress.equals(Token.WSOL.mint) ? endInstructions : [],
              frontInstructionsType,
              endInstructionsType,
              signers
            },
            associatedOnly: itemToken.mintAddress.equals(Token.WSOL.mint) ? false : ownerInfo.associatedOnly,
            checkCreateATAOwner: ownerInfo.checkCreateATAOwner
          })
        );
      }
      instructions.push(
        this.makeClaimInstruction({
          programId: poolInfo.programId,
          poolInfo,
          ownerInfo: {
            wallet: ownerInfo.wallet,
            ownerPda: poolInfo.ownerAccountId,
            claimAddress: ownerVaultList
          }
        })
      );
      instructionsType.push(
        8
        /* util1216OwnerClaim */
      );
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.wallet,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: instructionsType, instructions, signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeClaimAllInstructionSimple(_0) {
    return __async(this, arguments, function* ({
      connection,
      poolInfos,
      ownerInfo,
      makeTxVersion,
      lookupTableCache
    }) {
      var _a;
      const frontInstructions = [];
      const frontInstructionsType = [];
      const endInstructions = [];
      const endInstructionsType = [];
      const instructions = [];
      const instructionsType = [];
      const signers = [];
      const tempNewVault = {};
      for (const poolInfo of poolInfos) {
        const ownerVaultList = [];
        for (const itemToken of poolInfo.tokenInfo) {
          const tempVault = (_a = tempNewVault[itemToken.mintAddress.toString()]) != null ? _a : yield this._selectOrCreateTokenAccount({
            programId: itemToken.programId,
            mint: itemToken.mintAddress,
            tokenAccounts: itemToken.mintAddress.equals(Token.WSOL.mint) ? [] : ownerInfo.tokenAccounts,
            owner: ownerInfo.wallet,
            createInfo: {
              connection,
              payer: ownerInfo.wallet,
              amount: 0,
              frontInstructions,
              endInstructions: itemToken.mintAddress.equals(Token.WSOL.mint) ? endInstructions : [],
              frontInstructionsType,
              endInstructionsType,
              signers
            },
            associatedOnly: itemToken.mintAddress.equals(Token.WSOL.mint) ? false : ownerInfo.associatedOnly,
            checkCreateATAOwner: ownerInfo.checkCreateATAOwner
          });
          tempNewVault[itemToken.mintAddress.toString()] = tempVault;
          ownerVaultList.push(tempVault);
        }
        instructions.push(
          this.makeClaimInstruction({
            programId: poolInfo.programId,
            poolInfo,
            ownerInfo: {
              wallet: ownerInfo.wallet,
              ownerPda: poolInfo.ownerAccountId,
              claimAddress: ownerVaultList
            }
          })
        );
        instructionsType.push(
          8
          /* util1216OwnerClaim */
        );
      }
      return {
        address: {},
        innerTransactions: yield splitTxAndSigners({
          connection,
          makeTxVersion,
          computeBudgetConfig: void 0,
          payer: ownerInfo.wallet,
          innerTransaction: [
            { instructionTypes: frontInstructionsType, instructions: frontInstructions, signers },
            { instructionTypes: instructionsType, instructions, signers: [] },
            { instructionTypes: endInstructionsType, instructions: endInstructions, signers: [] }
          ],
          lookupTableCache
        })
      };
    });
  }
  static makeClaimInstruction({
    programId,
    poolInfo,
    ownerInfo
  }) {
    const dataLayout = struct50([]);
    const keys = [
      { pubkey: ownerInfo.wallet, isSigner: true, isWritable: true },
      { pubkey: poolInfo.poolId, isSigner: false, isWritable: true },
      { pubkey: ownerInfo.ownerPda, isSigner: false, isWritable: true },
      ...ownerInfo.claimAddress.map((i) => ({ pubkey: i, isSigner: false, isWritable: true })),
      ...poolInfo.tokenInfo.map(({ mintVault }) => ({ pubkey: mintVault, isSigner: false, isWritable: true })),
      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false }
    ];
    const data = Buffer.alloc(dataLayout.span);
    dataLayout.encode({}, data);
    const aData = Buffer.from([...[10, 66, 208, 184, 161, 6, 191, 98], ...data]);
    return new TransactionInstruction({
      keys,
      programId,
      data: aData
    });
  }
};
_Utils1216.CLAIMED_NUM = 3;
_Utils1216.POOL_LAYOUT = struct50([
  blob3(8),
  u8210("bump"),
  u8210("status"),
  u642("openTime"),
  u642("endTime"),
  publicKey2("ammId"),
  seq22(
    struct50([
      u8210("mintDecimals"),
      publicKey2("mintAddress"),
      publicKey2("mintVault"),
      u642("perLpLoss"),
      u642("totalClaimedAmount")
    ]),
    _Utils1216.CLAIMED_NUM,
    "tokenInfo"
  ),
  seq22(u642(), 10, "padding")
]);
_Utils1216.OWNER_LAYOUT = struct50([
  blob3(8),
  u8210("bump"),
  u8210("version"),
  publicKey2("poolId"),
  publicKey2("owner"),
  u642("lpAmount"),
  seq22(struct50([publicKey2("mintAddress"), u642("debtAmount"), u642("claimedAmount")]), _Utils1216.CLAIMED_NUM, "tokenInfo"),
  seq22(u642(), 4, "padding")
]);
_Utils1216.DEFAULT_POOL_ID = [
  "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
  "6UmmUiYoBjSrhakAobJw8BvkmJtDVxaeBtbt7rxWo1mg",
  "AVs9TA4nWDzfPJE9gGVNJMVhcQy3V9PGazuz33BfG2RA",
  "DVa7Qmb5ct9RCpaU7UTpSaf3GVMYz17vNVU67XpdCRut",
  "7XawhbbxtsRcQA8KTkHT9f9nc6d69UwqCDh6U5EEbEmX",
  "6a1CsrpeZubDjEJE9s1CMVheB6HWM5d7m1cj2jkhyXhj",
  "EoNrn8iUhwgJySD1pHu8Qxm5gSQqLK3za4m8xzD2RuEb",
  "AceAyRTWt4PyB2pHqf2qhDgNZDtKVNaxgL8Ru3V4aN1P",
  "6tmFJbMk5yVHFcFy7X2K8RwHjKLr6KVFLYXpgpBNeAxB"
].map((i) => new PublicKey(i));
_Utils1216.SEED_CONFIG = {
  pool: {
    id: Buffer.from("pool_seed", "utf8")
  },
  owner: {
    id: Buffer.from("user_claim_seed", "utf8")
  }
};
_Utils1216.VERSION_PROJECT = [void 0, "Francium", "Tulip", "Larix"];
var Utils1216 = _Utils1216;
export {
  AMM_CONFIG_SEED,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  AccountMeta,
  AccountMetaReadonly,
  AmmConfigLayout,
  BIT_PRECISION,
  BNDivCeil,
  BNLayout,
  Base,
  BitStructure,
  Blob,
  Clmm,
  Currency,
  CurrencyAmount,
  DEVNET_FARM_POOLS,
  DEVNET_LP_TOKENS,
  DEVNET_OFFICIAL_LIQUIDITY_POOLS,
  DEVNET_PROGRAM_ID,
  DEVNET_SPL_TOKENS,
  DataElement,
  ENDPOINT,
  EXTENSION_TICKARRAY_BITMAP_SIZE,
  ErrorCode,
  FARM_LEDGER_LAYOUT_V3_1,
  FARM_LEDGER_LAYOUT_V3_2,
  FARM_LEDGER_LAYOUT_V5_1,
  FARM_LEDGER_LAYOUT_V5_2,
  FARM_LEDGER_LAYOUT_V6_1,
  FARM_STATE_LAYOUT_V3,
  FARM_STATE_LAYOUT_V5,
  FARM_STATE_LAYOUT_V6,
  FARM_VERSION_TO_LEDGER_LAYOUT,
  FARM_VERSION_TO_STATE_LAYOUT,
  FEE_RATE_DENOMINATOR,
  FETCH_TICKARRAY_COUNT,
  FIVE,
  Farm,
  Fee,
  Fraction,
  INSTRUCTION_PROGRAM_ID,
  InstructionType,
  LIQUIDITY_FEES_DENOMINATOR,
  LIQUIDITY_FEES_NUMERATOR,
  LIQUIDITY_STATE_LAYOUT_V4,
  LIQUIDITY_STATE_LAYOUT_V5,
  LIQUIDITY_VERSION_TO_STATE_LAYOUT,
  LOG_B_2_X32,
  LOG_B_P_ERR_MARGIN_LOWER_X64,
  LOG_B_P_ERR_MARGIN_UPPER_X64,
  LOOKUP_TABLE_CACHE,
  Layout,
  Liquidity,
  LiquidityMath,
  LiquidityPoolStatus,
  LogLevel,
  Logger,
  MAINNET_FARM_POOLS,
  MAINNET_LP_TOKENS,
  MAINNET_OFFICIAL_LIQUIDITY_POOLS,
  MAINNET_PROGRAM_ID,
  MAINNET_SPL_TOKENS,
  MARKET_STATE_LAYOUT_V2,
  MARKET_STATE_LAYOUT_V3,
  MARKET_VERSION_TO_STATE_LAYOUT,
  MAX_BASE64_SIZE,
  MAX_SQRT_PRICE_X64,
  MAX_TICK,
  MEMO_PROGRAM_ID,
  METADATA_PROGRAM_ID,
  MIN_SQRT_PRICE_X64,
  MIN_TICK,
  Market,
  MarketV2,
  MathUtil,
  MaxU64,
  MaxUint128,
  ModelDataInfo,
  ModelDataPubkey,
  NEGATIVE_ONE,
  ONE,
  OPERATION_SEED,
  ObservationInfoLayout,
  ObservationLayout,
  OperationLayout,
  OptionLayout,
  POOL_REWARD_VAULT_SEED,
  POOL_SEED,
  POOL_TICK_ARRAY_BITMAP_SEED,
  POOL_VAULT_SEED,
  POSITION_SEED,
  Percent,
  PoolInfoLayout,
  PoolUtils,
  PositionInfoLayout,
  PositionRewardInfoLayout,
  PositionUtils,
  Price,
  ProtocolPositionLayout,
  Q128,
  Q64,
  RAYDIUM_MAINNET,
  REAL_FARM_STATE_LAYOUT_V3,
  REAL_FARM_STATE_LAYOUT_V5,
  REAL_FARM_STATE_LAYOUT_V6,
  RENT_PROGRAM_ID,
  RewardInfo,
  Rounding,
  SERUM_PROGRAMID_TO_VERSION,
  SERUM_PROGRAM_ID_V3,
  SERUM_VERSION_TO_PROGRAMID,
  SOL,
  SPL_ACCOUNT_LAYOUT,
  SPL_MINT_LAYOUT,
  SYSTEM_PROGRAM_ID,
  SYSVAR_CLOCK_PUBKEY,
  SYSVAR_RENT_PUBKEY,
  Spl,
  SqrtPriceMath,
  Structure2 as Structure,
  SwapMath,
  TEN,
  TESTNET_FARM_POOLS,
  TESTNET_LP_TOKENS,
  TESTNET_OFFICIAL_LIQUIDITY_POOLS,
  TESTNET_SPL_TOKENS,
  THREE,
  TICK_ARRAY_BITMAP_SIZE,
  TICK_ARRAY_SEED,
  TICK_ARRAY_SIZE,
  TICK_SPACINGS,
  TOKEN_PROGRAM_ID,
  TWO,
  TickArrayBitmap,
  TickArrayBitmapExtension,
  TickArrayBitmapExtensionLayout,
  TickArrayLayout,
  TickLayout,
  TickMath,
  TickQuery,
  TickUtils,
  Token,
  TokenAmount,
  TokenList,
  TradeV2,
  TxVersion,
  U64Resolution,
  U64_IGNORE_RANGE,
  UInt,
  Union2 as Union,
  Utils1216,
  Voter,
  VoterDepositEntry,
  VoterLockup,
  VoterRegistrar,
  VoterVotingMintConfig,
  WSOL,
  WideBits,
  WrappedLayout,
  ZERO,
  _100,
  _1000,
  _10000,
  _100_PERCENT,
  _SERUM_PROGRAM_ID_V3,
  array,
  bits,
  blob3 as blob,
  bool22 as bool,
  buildSimpleTransaction,
  buildTransaction,
  chunkArray,
  closePositionInstruction,
  collectRewardInstruction,
  createPoolInstruction,
  cstr,
  currencyEquals,
  decodeBool,
  decreaseLiquidityInstruction,
  divCeil,
  encodeBool,
  f32,
  f32be,
  f64,
  f64be,
  fetchMultipleMintInfos,
  findProgramAddress,
  forecastTransactionSize,
  formatLayout,
  generatePubKey,
  getDxByDyBaseIn,
  getDyByDxBaseIn,
  getMultipleAccountsInfo,
  getMultipleAccountsInfoWithCustomFlags,
  getMultipleLookupTableInfo,
  getPdaAmmConfigId,
  getPdaExBitmapAccount,
  getPdaMetadataKey,
  getPdaOperationAccount,
  getPdaPersonalPositionAddress,
  getPdaPoolId,
  getPdaPoolRewardVaulId,
  getPdaPoolVaultId,
  getPdaProtocolPositionAddress,
  getPdaTickArrayAddress,
  getStablePrice,
  getTransferAmountFee,
  getWSOLAmount,
  greedy2 as greedy,
  i128,
  i16ToBytes,
  i32ToBytes,
  i64,
  i8,
  increasePositionFromBaseInstruction,
  increasePositionFromLiquidityInstruction,
  initRewardInstruction,
  initStableModelLayout,
  inspectAll,
  inspectBN,
  inspectCurrency,
  inspectPublicKey,
  inspectToken,
  intersection,
  isZero,
  jsonInfo2PoolKeys,
  leadingZeros,
  leastSignificantBit,
  minExpirationTime,
  mostSignificantBit,
  ns642 as ns64,
  ns64be,
  nu64,
  nu64be,
  offset,
  openPositionFromBaseInstruction,
  openPositionFromLiquidityInstruction,
  option,
  parseBigNumberish,
  parseSimulateLogToJson,
  parseSimulateValue,
  poolKeys2JsonInfo,
  poolTypeV6,
  publicKey2 as publicKey,
  rustEnum,
  s163 as s16,
  s16be,
  s24,
  s24be,
  s32,
  s32be,
  s40,
  s40be,
  s48,
  s48be,
  s8,
  seq22 as seq,
  setRewardInstruction,
  simulateMultipleInstruction,
  simulateTransaction,
  splitNumber,
  splitTxAndSigners,
  str,
  struct50 as struct,
  swapInstruction,
  tagged,
  tenExponentiate,
  trailingZeros,
  u128,
  u164 as u16,
  u16ToBytes,
  u16be,
  u24,
  u24be,
  u3222 as u32,
  u32ToBytes,
  u32be,
  u40,
  u40be,
  u48,
  u48be,
  u642 as u64,
  u8210 as u8,
  union2 as union,
  unionLayoutDiscriminator,
  uniq,
  unwarpSol,
  utf8,
  validateAndParsePublicKey,
  vec,
  vecU8,
  xor,
  zeros
};
/*! Bundled license information:

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.6.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

@raydium-io/raydium-sdk/dist/index.mjs:
  (*! Bundled license information:
  
  @noble/hashes/esm/utils.js:
    (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  *)
*/
//# sourceMappingURL=@raydium-io_raydium-sdk.js.map
